## Помечанные элементы кортежа

Скорость разработки программы зависит не только от уровня разработчиков, но и от семантики кода, которая способна вывести из зоны комфорта даже бывалого специалиста. Понимая это _TypeScript_ не перестает усовершенствовать систему типов стремясь сделать и без того _"говорящий код"_ максимально читаемым. Поэтому в версии `4.0` была добавлена возможность помечать элементы кортежа придавая им осмысленность.

До текущей версии встретив кортеж наподобие `[string, number]` было совершенно не понятно что в дейтвительности представляют эти типы.

`````typescript
// до версии 4.0

const f = (p: [string, number]) => {}

/**
 * автодополнение -> f(p: [string, number]): void
 * 
 * Совершенно не понятно чем конкретно являются
 * элементы представляемые типами string и number
 */
f0()
`````

Начиная с текущей версии безликим элементам кортежа стало возможно придавать осмысление за счет механизма добавления меток.


`````typescript
// начиная с версии 4.0

const f = (p: [a: string, b: number]) => {};

/**
 * автодополнение -> f(p: [a: string, b: number]): void
 * 
 * Теперь мы знаем что функция ожидает не просто 
 * строку и число, а аргумент "a" и аргумент "b",
 * которые в реальном проекте будут иметь более
 * осмысленное смысловое значение, например "name" и "age".
 */
f1()
`````

Поскольку метки являются исключительной частью синтаксиса _TypeScript_ они не имеют никакой силы в коде при деструктуризации массива представленного типом кортежа.

`````typescript
const f = (p: [a: string, b: number]) => {
    let [c, d] = p;
};
`````

Единственное правило касающееся данного механизма заключается в том, что кортеж содержащий метки не может содержать элементы описанные только типами.

`````typescript
type T = [a: number, b: string, boolean]; // Error -> Tuple members must all have names or all not have names.ts(5084)
`````


Невозможно умолчать, что данный механиз придется по нраву сообществу `react` поскольку помеченный кортеж придётся как нельзя лучше при создании пользовательских хуков. 

`````typescript
declare function useState<T>(initialState: T):[state: T, setState: (state: T) => void];

/**
 * автокомплит -> useState(initialState: number): [state: number, setState: (state: number) => void]
 * 
 * Даже в отсутствии комментариев известно
 * что именно предполагается в возвращаемом значении!
 */
let [state, setState] = useState(0);
`````


