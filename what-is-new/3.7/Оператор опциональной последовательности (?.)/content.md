##Оператор опциональной последовательности (?.)

Начиная с текущей (`v3.7`) версии, _TypeScript_ реализовал функционал обозначаемый как оператор опциональной последовательности (_optional chaining operator_) внесенный в спецификацию _ECMScript_ комитетом _TC39_. Оператор опциональной последовательности обозначается вопросительным знаком после которого следует точка `?.` и предназначен для безопасного обращения к членам объекта через ссылку, которая может иметь значение `null` или `undefined`. Этого функционала очень давно все ждали, поэтому не будем медлить и немедля приступим к его рассмотрению на простом пример.

```ts
/**
 * Вложенные друг в друга типы
 * (как матрешки) объявленные
 * семантически в обратном порядке.
 */
interface D {
    n: number;
}
interface C {
    d: D;
}
interface B {
    c: C;
}
interface A {
    b: B;
}

/**
 * Представьте сценарий по которому
 * ответ от сервера может представлять
 * из себя json соответствующий как типу
 * A так и объекту у которого отсутствуют
 * какие-либо признаки {}.
 */

let json = '{}';
let a: A = JSON.parse(json);

/**
 * При попытке обращения к несуществующим
 * полям объекта возникнет соответствующее
 * исключение.
 */
let b = a.b; // Ok! поскольку отсутствуют операции над значением undefined
let c = a.b.c; // Runtime Error!
let d = a.b.c.d; // Runtime Error!
let n = a.b.c.d.n; // Runtime Error!

/**
 * Подобное можно избежать произведя
 * проверку на существование ссылок.
 */

if (a.b && a.b.c && a.b.c.d) {
    /**
     * Здесь можно обратится к полю n,
     * которое также может быть не определенно
     *, что при попытке вызвать методы реализованные
     * в типе Number также приведет к исключению.
     * Чтобы этого избежать потребуется дополнительная
     * проверка. Но стоит сразу заметить, что обычной
     * проверки на существование поля a.b.c.d.n может
     * быть недостаточно, поскольку значение поля n може
     * быть 0, что при преобразовании типов преобразуется
     * в false. Поэтому помимо наличие самого поля необходимо
     * также проверить его значение.
     */

    if (a.b.c.d.n && !Number.isNaN(a.b.c.d.n)) {
        let r = a.b.c.d.n.toFixed(2);
    }
}
```

Сложно представить разработчика, который на практике не сталкивался с чем-то подобным и не испытывал желания избавится от написания утомительных проверок. И наконец свершилось! Разработчики _TypeScript_ реализовали оператор опциональной последовательности известный также как _элвис-оператор_.

Элвис-оператор позволяет избавится от написания утомительных условных инструкций требуя от разработчика своего указания лишь в потенциально опасных местах. Оценить его мощь будет проще переписав предыдущий пример.

```ts
interface D {
    n: number;
}
interface C {
    d: D;
}
interface B {
    c: C;
}
interface A {
    b: B;
}

let json = '{}';
let a: A = JSON.parse(json);

/**
 * Ещё раз стоит обратить внимание на то,
 *, что указание элвис-оператора требуется
 * во всех потенциально опасных местах, поскольку
 * наличие одной ссылки не гарантирует наличие остальных
 * во всей цепочки вызовов.
 *
 * 0) поскольку отсутствуют операции над значением undefined
 * 1) если ссылка на "b" существует вернуть значение ассоциированное с полем "c"
 * 2) если ссылки на "b" и "c" существуют вернуть значение ассоциированное с полем "d"
 * 3) если ссылки на "b" и "c" и "d" существуют вернуть значение ассоциированное с полем "n"
 * 4) если ссылки на "b" и "c" и "d" и "n" существуют вернуть значение возвращенное методом "toFixed"
 */
let b = a.b; // Ok! (0)
let c = a.b?.c; // Ok! (1)
let d = a.b?.c?.d; // Ok! (2)
let n = a.b?.c?.d?.n; // Ok! (3)
let r = a.b?.c?.d?.n?.toFixed(2); // Ok! (4)
```

В случаях, когда элвис-оператор обнаруживает ссылку со значением `null` или `undefined`, результатом возвращенным из выражения становится `undefined`.

```ts
interface IT {
    a: {
        n: number;
    };
}

let o0: IT = JSON.parse('{}');
let o1: IT = JSON.parse('{a: null}');

/**
 * Несмотря на то, что во втором случае
 * значение поля "a" равно null, n1,
 * также как и n0 будет иметь значение
 * и следовательно тип undefined.
 */
let n0 = o0?.a.n; // n0 имеет значение undefined;
let n1 = o0?.a.n; // n1 имеет значение;
```

кроме того важной особенностью при использовании элвис-оператора является тот факт, что вывод типов не определяет тип как объединение включающий тип `undefined`, что в свою очередь избавляет от дополнительных проверок.

```ts
interface IT {
    a: {
        n: number;
    };
}

let o0: IT = JSON.parse('{}');
let o1: IT = JSON.parse('{a: null}');

let n0 = o0?.a.n; // let n0: number; а не number | undefined
let n1 = o0?.a.n; // let n1: number; а не number | undefined
```

Кроме того, элвис-оператор также может быть применен при вызове методов, а в случае отсутствия ссылок на них результатом вызова также будет `undefined`.

```ts
interface IT {
    f: (() => number) | null;
}
class T implements IT {
    /**
     * Вводим вывод типов в вмешательство путем
     * присваивания функции в положительном случае
     * и null в отрицательном.
     */
    f = Math.round(Math.random() * 1) === 1 ? () => 10 : null;
}

let t = new T();
let n = t.f?.(); // результатом выражения вызова метода является undefined
```

Таким образом выход версии `v3.7` дал разработчикам на языке _TypeScript_ инструмент предотвращающий исключения связанные с обращением к отсутствующим ссылкам или ссылкам имеющим значение `null`, который кроме всего не чувствителен к значениям преобразование которых к типу Boolean принимает ложную форму (`0`, `NaN`, `false`), что в свою очередь ознаменовало начало эпохи в которой нет места конструкциям выполняющих утомительные и проверки наличия ссылок.
