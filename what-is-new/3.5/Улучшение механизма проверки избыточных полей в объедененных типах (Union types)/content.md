В *TypeScript* есть механизм называемый *проверкой избыточности свойств* (*excess property checking*), который призван выявлять опечатки в литералах объекта.

`````typescript
type RectCssStyle = {
    width: string;
    height: string;

    color?: string;
}


let graphics: RectCssStyle = {
    width: '24px',
    height: '24px',

    colour: 'red', // Error
}
`````

С этим механизмом связанно два неоднозначных момента. Первый момент заключается в том, что в *TypeScript*, в некоторых случаях, избыточность допускается. Один из таких случчаев является присвоение идентификатору, ассоциированного с типом Union, значения принадлежащего одновеременно ко всем типам определеляющих это объединение. 


`````typescript
// до версии v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};


/**
 * По логике, в данном объекте, либо поля xy либо поле z являются излишними,
 * так как тип Union одновременно представляет лишь один определяющий
 * его тип данных
 */
const coords: CoordXY | CoordZ = {
    x: 0,
    y: 0,

    z: 0
};
`````

Второй неоднозначный момент сокрыт в реализации описанного выше поведения, которая даже не предусматривает проверку типов для полей являющихся излишними.

`````typescript
// до версии v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};

// вывод типов считает что значение принадлежит к типу CoordXY
const coordsFirst: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: '' // Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает
};

// вывод типов считает что значение принадлежит к типу CoordZ
const coordsSecond: CoordXY | CoordZ = {
    x: '', // Ok...
    y: '', // Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает
    z: 0 
};
`````

Это поведение кажется нелогичным, поэтому Начиная с версии *TypeScript* `v3.5` частично было изменено. Теперь при проверке литералов объекта выполняется проверка типов, что устроняет второй неоднозначным случай.

`````typescript
// начиная с v3.5

type CoordXY = {
    x: number;
    y: number;
};

type CoordZ = {
    z: number;
};

const coordsFirst: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: '', // Error
};

const coordsSecond: CoordXY | CoordZ = {
    x: '', // Error
    y: '', // Error
    z: 0,
};

`````

Тем не менее, нужно помнить, что первый случай, который также быд обозначен как не совсем очевидный, остался.

`````typescript
// ... 


const coords: CoordXY | CoordZ = {
    x: 0,
    y: 0,
    z: 0,
}; // Ok
`````
