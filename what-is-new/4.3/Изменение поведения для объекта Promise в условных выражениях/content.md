## Изменение поведения для объекта Promise в условных выражениях

Представьте ситуацию, в которой ход выполнения программы зависит от существования объекта `Promise`. Существование объекта осуществляется при помощи одно из множества возможных условных выражений.

`````ts
/**
 * Фабрика возвращающая объект обещания.
 */
function factory(){
    return Promise.resolve(false);
}

/**
 * Действие, логика которого зависит от существования
 * объекта Promise.
 */
async function action() {
    /**
     * Если объект обещания существует, то выполняем 
     * некоторые действия. 
     */
    if(factory()){
        // ...
    }
}
`````

Но что, если по условию, в условном выражении требуется проверить не существование объекта `Promise`, а результат его выполнения. К тому, обещание является возвращаемым значением асинхронной функции являющейся асинхронным валидатором. Если разработчик упустит из внимания факт ассинхронности валидатора, то в приложении появится трудновыявляемая ошибка, поскольку без ключевого слова `await` в условном выражении проверятся будет не результат разрешения обещания, а существование его объекта.


`````ts
/**
 * [0] Асинхронный валидатор
 */

async function validate(): Promise<boolean> { // [0]
    return false;
}


/**
 * [1] Асинхронное действие результат выполнения которого
 * зависит от асинхронного валидатора.[2] Но несмотря на то, что
 * результатом выполнения функции validate() является значение flase,
 * выполнение программы все равно зайдет в блок if поскольку
 * валидатор, по невнимательности, был вызван без ключевого слова await.
 * 
 */ 
async function action(): Promise<void> {
    /**
     * --strictNullChecks = true
     * 
     * До текущей версии - Ok, поскольку компилятор проверяет существоание объекта Promise.
     * Начиная с текущей версии - Error.
     * 
     * This condition will always return true since this 'Promise<boolean>' appears to always be defined.ts(2801)
     */
    if (validate()) { // [2]
    }
}
`````

Поэтому, начиная с текущей версии, при активном флаге `--strictNullChecks` обещания в условных выражениях необходимо конкретизировать. Проверки на существование объекта `Promise` теперь необходимо выполнять явно.

`````ts
async function validate(): Promise<boolean> { // [0]
    return false;
}
async function action(): Promise<void> {
    /**
     * --strictNullChecks = true
     */
    if (validate()) { // Error
    }
    if (validate() !== null) { // Ok
    }


    validate() ? true : false; // Error
    validate() !== null ? true : false; // Ok

    validate() && true; // Error
    validate() !== null && true; // Ok

}
`````

Подобное поведение не допустит непредсказуемого поведения тогда, когда в условном выражении предполагается работа со значением являющимся результатом разрешения обещания, а не его объектом.

`````ts
    return false;
}
async function action(): Promise<void> {
    /**
     * --strictNullChecks = true
     */
    if (await validate()) { // Ok
    }

    await validate() ? true : false; // Ok

    await validate() && true; // Ok
    await validate() || true; // Ok

}
`````

Единственное о чем ещё стоет упомянуть, что на данный момент, по неизвестной причине, в условном выражении _ИЛИ_ (`||`), при отсутствии ключевого слова `await` ошибка не возникает.

`````ts
validate() || true; // Ok
validate() !== null || true; // Ok
`````
