## Абстрактные классы (abstract classes)
________________

Если у всех начинающих разработчиков, при размышлениях о интерфейсах, возникают вопросы, когда  и зачем их использовать, то при размышлении об абстрактных классах, ещё добавляются вопросы, чем они отличаются от интерфейсов и когда та или иная конструкция предпочтительней. Ответы на эти вопросы, я постараюсь дать в этой главе, но для начала стоит рассмотреть их общие характеристики.


## Общие характеристики
________________


В *TypeScript*, объявление абстрактного класса, отличается от объявления обычного класса, только добавлением ключевого слова `abstract` перед ключевым словом `class`.

~~~~~typescript
abstract class Identifier { }
~~~~~

Абстрактные классы, также как и обычные классы, могут расширять другие, как обычные, так и абстрактные классы, а также реализовывать интерфейсы.

~~~~~typescript
interface IInterface {}

class StandardClass {}

abstract class SuperAbstractClass extends StandardClass implements IInterface { } // абстрактный класс расширяет обычный класс и реализует интерфейс
abstract class SubAbstractClass extends SuperAbstractClass {} // абстрактный класс расширяет другой абстрактный класс
~~~~~

Несмотря на то, что абстрактный класс, все же класс, главное его отличие от обычного класса заключается в том, что идеологически не предполагается создания его экземпляров. Другими словами, нельзя создать экземпляр абстрактного класса.

~~~~~typescript
abstract class SuperAbstractClass { }
class SubStandartClass extends SuperAbstractClass {}

let v0: SuperAbstractClass = new SuperAbstractClass(); // Error, нельзя создавать экземпляры абстрактного класса
let v1: SuperAbstractClass = new SubStandartClass(); // Ok
let v2: SubStandartClass = new SubStandartClass(); // Ok
~~~~~

Абстрактные классы могут содержать абстрактные члены, принадлежность к которым, также, указывается с помощью ключевого слова `abstract`. С помощью ключевого слова `abstract` можно помечать поля, свойства (аксессоры), а также методы объекта. При этом свойства и методы не должны иметь реализацию. В отличие от них, полям, помеченным как абстрактные, может быть присвоено значение по умолчанию.

~~~~~typescript
abstract class Identifier {
  public abstract field: string = 'default value'; // реализация допустима
  public abstract get prop(): string; // реализация не допустима
  public abstract set prop(value:string); // реализация не допустима

  public abstract method(): void; // реализация не допустима
}
~~~~~

Абстрактный класс, который расширяет другой абстрактный класс, не обязан переопределять все абстрактные члены своего суперкласса. В отличии от абстрактных классов, обычные классы, которые расширяют абстрактные классы, обязанные переопределить все поля, свойства и методы, находящиеся в иерархической цепочке и помеченные ключевым словом `abstract`, если они не были реализованы предками ранее.

~~~~~typescript
abstract class SuperAbstractClass {
  public abstract field: string; // объявление абстрактного поля
}

abstract class SubAbstractClass extends SuperAbstractClass {} // в абстрактных потомках допускается не переопределять абстрактные члены предков 

class SubConcreteClass extends SubAbstractClass { // конкретный подкласс обязан переопределять абстрактные члены, если они...
  public field: string;
}
class SubSubConcreteClass extends SubConcreteClass {} // ююю если они не были переопределены в классах-предках
~~~~~

Как было сказано ранее, абстрактным полям может быть задано значение по умолчанию, но в этом случае, обратится к нему могут только абстрактные классы в иерархии наследования. 

~~~~~typescript
abstract class SuperAbstractClass {
  public abstract field0: string = 'default value'; // объявление абстрактного поля с значением по умолчанию
  public abstract field1: string;
  public abstract field2: string;
}

abstract class SubAbstractClass extends SuperAbstractClass {
  public field1:  string = this.field0; // переопределение абстрактного поля и инициализация его значением абстрактного поля, которому было присвоено значение по умолчанию в абстрактном предке
} 

class SuboncreteClass extends SubAbstractClass {
  public field0: string; // конкретному классу необходимо переопределить два абстрактных поля, так как в предках было переопределено только один член
  public field2: string;
}
~~~~~

Абстрактные члены в полной мере удовлетворяют все условия реализации интерфейса. Другими словами, абстрактный класс, который декларирует реализацию интерфейса, может не реализовывать его члены, а лишь пометить их как абстрактные и тем самым переложить реализацию на своих потомков.

~~~~~typescript
interface IInterface {
  field: string;
  method(): void;
}


abstract class AbstractSuperClass implements IInterface { // абстрактный класс декларирует реализацию интерфейса
  public  abstract field: string; // поле без реализации...
  public abstract method(): void; // ...метод без реализации. тем не менее ошибки не возникает
}
~~~~~

Кроме абстрактных членов, абстрактные классы могут содержать обычные члены, обращение к которым ничем не отличается от членов объявленных в обычных классах.

Как правило, абстрактные классы реализуют только ту логику, которая не будет ни при каких обстоятельствах противоречить логики своих подклассов.

~~~~~typescript
abstract class AbstractSuperClass {
  abstract name: string = "AbstractSuperClass";

  public toString(): string {
    // реализация общего не абстрактного метода
    return `[object ${this.name}]`;
  }
}

class FirstConcreteSubClass extends AbstractSuperClass {
  public name: string = "T2"; // реализуем абстрактное поле
}

class SecondConcreteSubClass extends AbstractSuperClass {
  public name: string = "T2"; // реализуем абстрактное поле
}

let first: FirstConcreteSubClass = new FirstConcreteSubClass();
let second: SecondConcreteSubClass = new SecondConcreteSubClass();

first.toString(); // [object FirstConcreteSubClass] реализация в абстрактном предке
second.toString(); // [object SecondConcreteSubClass] реализация в абстрактном предке
~~~~~


## Теория

________________

Пришло время разобраться в теории абстрактных классов, а именно ответить на вопросы, которые могут возникнуть при разработке программ.

Интерфейс или абстрактный класс - частый вопрос, ответ на который не всегда очевиден.  В действительности, это абсолютно разные конструкции, как с точки зрения реализации, так и идеологии. Интерфейсы предназначены для описания публичного *api*, которое служит для сопряжение с программой. Кроме того, они не должны, а в *TypeScript* и не могут, реализовывать бизнес логику той части, которую представляют. Они идеальные кандидаты для реализации *слабой связанности* (low coupling). При проектировании программ упор должен делаться именно на интерфейсы.


Абстрактные классы, при необходимости, должны реализовывать интерфейсы, в той же степени и для тех же целей, что и обычные классы. Их однозначно нужно использовать в качестве базового типа тогда, когда множество, логически связанных классов, имеет общую для всех логику. 

К примеру, абстрактный класс `Animal`, реализующий интерфейс `IAnimal`, с двумя членами, свойством `isLife` и методом `voice`, может и должен реализовать свойство `isLife`, так как это свойство имеет заранее известное количество состояний, жив или мертв, и не может отличаться в зависимости от потомка. В то время как метод `voice` (подать голос), как раз таки будет иметь разную реализацию, в зависимости от потомков, ведь коты мяукают, а вороны каркают. 

Тем не менее, резонно может возникнуть вопрос, а почему бы не вынести этот функционал в обычный базовый класс? 

Абстрактный класс способен не только подсказать архитектору, что данная сущность является абстрактной для предметной области, но и не позволить разработчику создать экземпляр класса, работа которого может сломать приложение. Ведь окажись на его месте обычный базовый класс, часть логики которого должна быть реализованной в потомках, то возникла бы возможность, что его экземпляр будет задействован в тех местах, которые зависят от этой логики и тогда её отсутствие приведет к непредсказуемому результату. 

Еще раз тоже самое, но другими словами. Базовый класс будет реализовывать основную часть базовых типов определенных интерфейсами, с помощью которых будет происходить сопряжение с остальными частями программы. Ведь как было рассмотрено в главе [“Типы - Interface”](), чтобы не нарушить *“Принцип разделения интерфейсов”*, интерфейс `IAnimal`, должен состоять из более специфичных (более конкретных) интерфейсов, на которых и будет завязана программа. А это в свою очередь означает, что экземпляр базового класса, который реализует интерфейс `IAnimal` и у которого отсутствует основная логика, может быть использован в тех частях программы, в которых предполагается использовать экземпляры более специфичных типов, принадлежащих  к типам этих интерфейсов (проще говоря потомков базового типа). 

И тот факт, что абстрактный класс мог бы уберечь от этого сценария, доказывает то, что обычный класс, в качестве его замены, может привести к ошибкам, которые могут возникнуть только на этапе выполнения. То есть обычный класс, в роли замены абстрактного класса, снижает типобезопасность программы. 

Кроме того, абстрактный класс, с помощью абстрактных членов, не даст разработчику забыть реализовать необходимую логику в потомках.

Но и это ещё не все. Интерфейс `IAnimal`, в реальности, будет составным типом. То есть, он будет принадлежать к типам `ILiveable`, описывающим свойство `isLife` и `IVoiceable`, описывающим метод `voice`. Реализовать подобное с помощью абстрактного класса не получится, так как один класс может расширять только один класс. В то время, как интерфейсы могу расширять множество других интерфейсов, а следовательно и принадлежит ко множеству типов данных одновременно. Что и делает интерфейс `IAnimal` расширяя интерфейсы `ILiveable` и `IVoiceable`. Но даже, если бы язык поддерживал механизм мультинаследования, то в реальности функционал `IAnimal` одним методом `voice` не ограничивался. Как минимум были ли бы ещё `move` (передвижение), `eat` (кушать). И несмотря на то, что все эти методы могут быть объединены в одном классе, так как они логически связаны (описывают механизмы жизнедеятельности животного), в программе, в тех её местах, которые будут их использовать, они не могут быть представлены типом этого класса. Они должны быть представлены типами, которые будут описывать только их область функциональности. Например `IMovable`, помимо метода move, может ещё включать в себя поле `speed` (скорость), так как скорость непосредственно связана с передвижением.

Если, в рассуждениях, пойти ещё дальше и представить совсем уже бессмысленную ситуацию, когда каждый метод будет реализован в одном классе, чтобы не нарушить *“Принцип разделения интерфейсов”*, то создав в программе множество маленьких  классов, будет реализован такой архитектурный антипаттерн, как *“Мышиная возня”*.

Бывает так, что при проектировании компонента программы, разработчик, уже на стадии проектирования, знает, что их функционал, в будущем, будет расширен. И может показаться, что точка сопряжения, в данной ситуации, кандидат на использование абстрактного класса, вместо интерфейса. С одной стороны, да. Если заменить тип интерфейса ,на тип представляемый абстрактным классом, то в дальнейшем, при расширении его логики, можно воспользоваться механизмом наследования (`extends`), который для этого и предназначен. Но с другой стороны, существует такое устоявшееся правило, которое гласит - *“Предпочитайте композицию наследованию класса”* (*“Банда Четырех”*), что склоняет к использованию интерфейса. Тем не менее выбор не заключается между лучшим и худшим. В конкретном случае разработчику просто предстоит выбрать один, из двух вариантов. И если вы относитесь к тем, кто предпочитает композицию наследованию, то обязательно должны знать, что существует случай, который в общей практике и является исключительным, но в контексте *TypeScript*, его, скорее всего, правильно причислить к “щекотливым”.


Существуют ситуации, когда архитектору заранее известно, что внутренний функционал программы в будущем будет расширен. То есть, описание точки сопряжения будет дополнена новыми членами.


Если в этом случае будет использоваться интерфейс, то добавление в него новой декларации члена, будет требовать вмешательства разработчика в существующий код. Ведь классы, реализующие интерфейсы, обязаны реализовывать все его члены. Следовательно, декларирование в интерфейс нового члена приведет к обязательному изменению (дополнению) кода использующего его.


В случае декларирования нового члена в абстрактном классе появляется возможность изменения без вмешательства в основной код. Хотя при декларировании новых членов придется отказаться от модификатора `abstract`, так как при его использовании, точно также, как и при использовании интерфейса, потребуется вмешательства в код. Но зато, в отличии от случаев при которых используется интерфейс, это хотя бы становится возможным. А добавление нового функционала, на самом деле, очень частая практика, на начальных этапах разработки. Кто тому же абстрактный класс, все также устраняет недостатки обычных классов. 

Хотя интерфейсы в *TypeScript* могут иметь необязательные члены (глава [“Операторы - Optional, Not-Null, Not-Undefined, Definite Assignment Assertion”]()), что в некоторой степени, сводит на нет преимущество абстрактных классов в ситуациях, когда точки соприкосновения подвержены добавлению новых членов.

И последняя момент, о котором стоит упомянуть, что технически, абстрактный класс состоящий только из абстрактных членов, может исполнять ту роль в программе, которая идеологически, была отведена интерфейсу. Но это не лучшая идея.
