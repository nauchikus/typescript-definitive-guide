<section id="Vspomogatelnyi-tip-Omit" name="Вспомогательный тип Omit" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vspomogatelnyi-tip-Omit" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Вспомогательный тип Omit
        </h2>
        <hr>
        <p>В повседневной разработке очень часто требуется определить новый тип описывающий некоторую часть существующего. До версии <em>TypeScript</em> <code class="inline-code">3.5</code> подобное можно было реализовать при помощи типов <code class="inline-code">Exclude&#x3C;T, U></code> и <code class="inline-code">Pick&#x3C;T, K></code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Person = {
    firstName: <span class="hljs-built_in">string</span>;
    lastName: <span class="hljs-built_in">string</span>;

    age: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">/**
 * определяем тип Union состоящий из строковых литеральных типов
 * представляемых ключами типа Person, за исключением исключенного
 * поля age.
 * 
 * type RemainingKeys = "firstName" | "lastName"
 */</span>
<span class="hljs-keyword">type</span> RemainingKeys = Exclude&#x3C;keyof Person, <span class="hljs-string">"age"</span>>;

<span class="hljs-comment">/**
 * определяем новый тип состоящий из ключей
 * полученных на предыдущем шаге.
 * 
 * type PersonName = {
 *  firstName: string;
 *  lastName: string;
 * }
 */</span>
<span class="hljs-keyword">type</span> PersonName = Pick&#x3C;Person, RemainingKeys>;</code></pre>
<p>Поскольку потребность в сужении типа возникает довольно часто, это вынуждает разработчиков выносить требующийся функционал в отдельную сущность, что неизбежно затрудняет чтение кода другими разработчиками, так как знакомый всем механизм скрыт за незнакомым им идентификатором типа (именем типа).</p>
<p>По этой причине разработчики <code class="inline-code">TypeScript</code> расширили стандартную библиотеку <code class="inline-code">lib.d.ts</code> новым вспомогательным типом <code class="inline-code">Omit&#x3C;T, K></code>, который стандартизирует, обсуждаемую на протяжении главы, логику.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Person = {
    firstName: <span class="hljs-built_in">string</span>;
    lastName: <span class="hljs-built_in">string</span>;

    age: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">/**
 * type PersonName = {
 *  firstName: string;
 *  lastName: string;
 * }
 */</span>
<span class="hljs-keyword">type</span> PersonName = Omit&#x3C;Person, <span class="hljs-string">'age'</span>>;</code></pre>

    </section>
<section id="Uluchshenie-mehanizma-proverki-izbytochnyh-polei-v-obedenennyh-tipah-Union-types" name="Улучшение механизма проверки избыточных полей в объедененных типах (Union types)" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Uluchshenie-mehanizma-proverki-izbytochnyh-polei-v-obedenennyh-tipah-Union-types" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Улучшение механизма проверки избыточных полей в объедененных типах (Union types)
        </h2>
        <hr>
        <p>В <em>TypeScript</em> есть механизм называемый <em>проверкой избыточности свойств</em> (<em>excess property checking</em>), который призван выявлять опечатки в литералах объекта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> RectCssStyle = {
    width: <span class="hljs-built_in">string</span>;
    height: <span class="hljs-built_in">string</span>;

    color?: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">let</span> graphics: RectCssStyle = {
    width: <span class="hljs-string">'24px'</span>,
    height: <span class="hljs-string">'24px'</span>,

    colour: <span class="hljs-string">'red'</span>, <span class="hljs-comment">// Error</span>
}</code></pre>
<p>С этим механизмом связанно два неоднозначных момента. Первый момент заключается в том, что в <em>TypeScript</em>, в некоторых случаях, избыточность допускается. Один из таких случчаев является присвоение идентификатору, ассоциированного с типом Union, значения принадлежащего одновеременно ко всем типам определеляющих это объединение. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до версии v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};


<span class="hljs-comment">/**
 * По логике, в данном объекте, либо поля xy либо поле z являются излишними,
 * так как тип Union одновременно представляет лишь один определяющий
 * его тип данных
 */</span>
<span class="hljs-keyword">const</span> coords: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,

    z: <span class="hljs-number">0</span>
};</code></pre>
<p>Второй неоднозначный момент сокрыт в реализации описанного выше поведения, которая даже не предусматривает проверку типов для полей являющихся излишними.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// до версии v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// вывод типов считает что значение принадлежит к типу CoordXY</span>
<span class="hljs-keyword">const</span> coordsFirst: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,
    z: <span class="hljs-string">''</span> <span class="hljs-comment">// Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает</span>
};

<span class="hljs-comment">// вывод типов считает что значение принадлежит к типу CoordZ</span>
<span class="hljs-keyword">const</span> coordsSecond: CoordXY | CoordZ = {
    x: <span class="hljs-string">''</span>, <span class="hljs-comment">// Ok...</span>
    y: <span class="hljs-string">''</span>, <span class="hljs-comment">// Ok, несмотря на то, что тип определен как number при присваивании значения принадлежащего к типу string ошибки не возникает</span>
    z: <span class="hljs-number">0</span> 
};</code></pre>
<p>Это поведение кажется нелогичным, поэтому Начиная с версии <em>TypeScript</em> <code class="inline-code">v3.5</code> частично было изменено. Теперь при проверке литералов объекта выполняется проверка типов, что устроняет второй неоднозначным случай.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// начиная с v3.5</span>

<span class="hljs-keyword">type</span> CoordXY = {
    x: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> CoordZ = {
    z: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> coordsFirst: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span>,
    y: <span class="hljs-number">0</span>,
    z: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
};

<span class="hljs-keyword">const</span> coordsSecond: CoordXY | CoordZ = {
    x: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
    y: <span class="hljs-string">''</span>, <span class="hljs-comment">// Error</span>
    z: <span class="hljs-number">0</span>,
};</code></pre>
<p>Тем не менее, нужно помнить, что первый случай, который также быд обозначен как не совсем очевидный, остался.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// ... </span>


<span class="hljs-keyword">const</span> coords: CoordXY | CoordZ = {
    x: <span class="hljs-number">0</span><span class="hljs-string">',
    y: 0'</span>,
    z: <span class="hljs-number">0</span>,
}; <span class="hljs-comment">// Ok</span></code></pre>

    </section>
<section id="Vvedenie-novogo-flaga-allowUmdGlobalAccess" name="Введение нового флага --allowUmdGlobalAccess" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vvedenie-novogo-flaga-allowUmdGlobalAccess" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Введение нового флага --allowUmdGlobalAccess
        </h2>
        <hr>
        <p>Посколько, до недавнего времени, спецификация <em>ESMAScript</em> не предлагала модульную систему, разработчикам приходилось прибегать к использованию множества несовместимых между собой реализаций поражденных сообществом, которые затем были унифицированы за счет так называемой <em>универсальной модульной системы</em> (<em>UMD</em>). Кроме того,библиотеки создавались таким образом чтобы быть доступными через глобальную область видимости.</p>
<p>Со стандартизацией <em>esmodules</em>, в <em>TypeScript</em>, при попытке обратится к библиотеке через объявленный в глобальной области идентификатор, возникает ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Rx <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> ref = React.createRef(); <span class="hljs-comment">// Error, обращение к глобальным переменным в модулях недопустимо</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Rx <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> ref = React.createRef(); <span class="hljs-comment">// Ok, так как импортирован модуль</span></code></pre>
<p>Но посколько со стороны сообщества неоднократно поступали просьбы сделать доступными в модулях глобальные определения, разработчики <em>TypeScript</em> ввели новый флаг <code class="inline-code">--allowUmdGlobalAccess</code> благодаря которому появилась такая возможность.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// tsconfig.json</span>

{
  {
    <span class="hljs-string">"compilerOptions"</span>: {
      <span class="hljs-string">"allowUmdGlobalAccess"</span>: <span class="hljs-literal">false</span>
    }
  }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Rx <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> ref = React.createRef(); <span class="hljs-comment">// Ok, доступ к глобальному определению из модуля</span></code></pre>

    </section>
<section id="Uluchshenie-mehanizma-proverki-obedinennyh-tipov" name="Улучшение механизма проверки объединенных типов" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Uluchshenie-mehanizma-proverki-obedinennyh-tipov" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Улучшение механизма проверки объединенных типов
        </h2>
        <hr>
        <pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Source = { done: <span class="hljs-built_in">boolean</span>, value: <span class="hljs-built_in">number</span> }
<span class="hljs-keyword">type</span> Target =
    | { done: <span class="hljs-literal">false</span>, value: <span class="hljs-built_in">number</span> }
    | { done: <span class="hljs-literal">true</span>, value: <span class="hljs-built_in">number</span> };

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> source: Source;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> target: Target;

target = source; <span class="hljs-comment">// Error, до v3.5 и Ok после</span></code></pre>
<p>Поскольку в примере выше тип <code class="inline-code">Source</code>, за исключением поля <code class="inline-code">done</code>, идентичен типу <code class="inline-code">Target</code>, новый механизм проверки объедененных типов допускает присвоение значения первого типа идентификатору принадлежащего ко второму типу.</p>

    </section>
<section id="Uluchshenie-mehanizma-vyvoda-tipa-vysshego-poryadka-dlya-obobshchennyh-konstruktorov" name="Улучшение механизма вывода типа высшего порядка для обобщенных конструкторов" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Uluchshenie-mehanizma-vyvoda-tipa-vysshego-poryadka-dlya-obobshchennyh-konstruktorov" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Улучшение механизма вывода типа высшего порядка для обобщенных конструкторов
        </h2>
        <hr>
        <p>В <em>TypeScript</em> версии <code class="inline-code">v3.4</code> был усовершенствован механизм вывода типов для обобщенных функций реализующих функциональную композицию. Это в свою очередь повысило эффективность использования   <em>функциональных-hoc</em> при разработке <em>React-приложений</em>. С выходом версии <code class="inline-code">v3.5</code> подобный механизм был перенесен на конструкторы классов, что также повысило эффективность вывода типов при использования их в качестве <em>классовых-hoc</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ComponentClass&#x3C;P> = <span class="hljs-keyword">new</span> (props: P) => Component&#x3C;P>;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> Component&#x3C;P> {
    props: P;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">props: P</span>);
}

type HocProps = { hocProp: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoc</span>&#x3C;<span class="hljs-title">WrappedProps</span>>(<span class="hljs-params">WrappedComponent: ComponentClass&#x3C;WrappedProps></span>): <span class="hljs-title">ComponentClass</span>&#x3C;<span class="hljs-title">WrappedProps</span> &#x26; <span class="hljs-title">HocProps</span>> </span>;

<span class="hljs-keyword">type</span> NestedProps&#x3C;T> = { nestedProp: T };
<span class="hljs-keyword">class</span> CustomComponent&#x3C;T> <span class="hljs-keyword">extends</span> Component&#x3C;NestedProps&#x3C;T>> {}

<span class="hljs-comment">/**
 * &#x3C;v3.5
 * const WrappedComponent: ComponentClass&#x3C;NestedProps&#x3C;{}> &#x26; HocProps>
 * 
 * >=v3.5
 * const WrappedComponent: new &#x3C;T>(props: NestedProps&#x3C;T> &#x26; HocProps) => Component&#x3C;NestedProps&#x3C;T> &#x26; HocProps>
 * 
 */</span>
<span class="hljs-keyword">const</span> WrappedComponent = hoc(CustomComponent);</code></pre>

    </section>
<section id="Kriticheskie-izmeneniya-Neyavnoe-ogranichenie-obobshchennyh-parametrov-tipom-unknown" name="[Критические изменения] Неявное ограничение обобщенных параметров типом unknown" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Kriticheskie-izmeneniya-Neyavnoe-ogranichenie-obobshchennyh-parametrov-tipom-unknown" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [Критические изменения] Неявное ограничение обобщенных параметров типом unknown
        </h2>
        <hr>
        <p>Начиная с версии <code class="inline-code">v3.5</code> обобщенные параметры типа неявно определяются как принадлежащие к типу <code class="inline-code">unknown</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> Stack&#x3C;T> {
    getItem():T;
}


<span class="hljs-comment">/**
 * &#x3C;v3.5
 * let item: {}
 * 
 * >= v3.5
 * let item: unknown
 */</span>
<span class="hljs-keyword">let</span> stack = <span class="hljs-keyword">new</span> Stack();
<span class="hljs-keyword">let</span> item = stack.getItem();</code></pre>

    </section>
<section id="Kriticheskie-izmeneniya-Izmeneniya-pravil-dlya-tipa-unknown-i-indeksnoi-signature" name="[Критические изменения] Изменения правил для типа unknown и индексной сигнатуре" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Kriticheskie-izmeneniya-Izmeneniya-pravil-dlya-tipa-unknown-i-indeksnoi-signature" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [Критические изменения] Изменения правил для типа unknown и индексной сигнатуре
        </h2>
        <hr>
        <p>В <em>TypeScript</em> тип представленный индексной сигнатурой ассоциированной с типом <code class="inline-code">any</code>, совместим с любым объектным типом. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Dictionary = {[key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>};

<span class="hljs-keyword">let</span> dictionary: Dictionary;

<span class="hljs-keyword">class</span> SomeClass {};
<span class="hljs-keyword">const</span> literalObjectType = {f0: <span class="hljs-number">0</span>, f1: <span class="hljs-string">''</span>};
<span class="hljs-keyword">const</span> anyType: <span class="hljs-built_in">any</span> = <span class="hljs-number">5</span>;

dictionary = {}; <span class="hljs-comment">// Ok</span>
dictionary = literalObjectType; <span class="hljs-comment">// Ok</span>
dictionary = anyType;
dictionary = <span class="hljs-keyword">new</span> SomeClass(); <span class="hljs-comment">// Ok</span>
dictionary = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}; <span class="hljs-comment">// Ok</span>
dictionary = <span class="hljs-built_in">Boolean</span>; <span class="hljs-comment">// Ok</span></code></pre>
<p>До версии <code class="inline-code">v3.5</code> тип <code class="inline-code">unknown</code> в индексной сигнатуре вел себя аналогичным образом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;v3.5</span>

<span class="hljs-keyword">type</span> Dictionary = {[key: <span class="hljs-built_in">string</span>]: unknown};

<span class="hljs-keyword">let</span> dictionary: Dictionary;

<span class="hljs-keyword">class</span> SomeClass {};
<span class="hljs-keyword">const</span> literalObjectType = {f0: <span class="hljs-number">0</span>, f1: <span class="hljs-string">''</span>};
<span class="hljs-keyword">const</span> anyType: <span class="hljs-built_in">any</span> = <span class="hljs-number">5</span>;

dictionary = {}; <span class="hljs-comment">// Ok</span>
dictionary = literalObjectType; <span class="hljs-comment">// Ok</span>
dictionary = anyType;
dictionary = <span class="hljs-keyword">new</span> SomeClass(); <span class="hljs-comment">// Ok</span>
dictionary = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}; <span class="hljs-comment">// Ok</span>
dictionary = <span class="hljs-built_in">Boolean</span>; <span class="hljs-comment">// Ok</span></code></pre>
<p>Начиная с версии <code class="inline-code">v3.5</code> поведение для типа <code class="inline-code">unknown</code> в индексной сигнатуре было изменено. Теперь он совместим лишь с типами представляемыми литералами объектов и типом <code class="inline-code">any</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// >= 3.5</span>

<span class="hljs-keyword">type</span> Dictionary = {[key: <span class="hljs-built_in">string</span>]: unknown};

<span class="hljs-keyword">let</span> dictionary: Dictionary;

<span class="hljs-keyword">class</span> SomeClass {};
<span class="hljs-keyword">const</span> literalObjectType = {f0: <span class="hljs-number">0</span>, f1: <span class="hljs-string">''</span>};
<span class="hljs-keyword">const</span> anyType: <span class="hljs-built_in">any</span> = <span class="hljs-number">5</span>;

dictionary = {}; <span class="hljs-comment">// Ok</span>
dictionary = literalObjectType; <span class="hljs-comment">// Ok</span>
dictionary = anyType;
dictionary = <span class="hljs-keyword">new</span> SomeClass(); <span class="hljs-comment">// Error</span>
dictionary = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}; <span class="hljs-comment">// Error</span>
dictionary = <span class="hljs-built_in">Boolean</span>; <span class="hljs-comment">// Error</span></code></pre>

    </section>
<section id="Kriticheskoe-izmenenie-Izmenenie-logiki-dlya-Object-keys-dlya-versii-es5" name="[Критическое изменение] Изменение логики для Object.keys для версии es5" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Kriticheskoe-izmenenie-Izmenenie-logiki-dlya-Object-keys-dlya-versii-es5" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [Критическое изменение] Изменение логики для Object.keys для версии es5
        </h2>
        <hr>
        <p>Начиная с версии <em>es6</em> метод <code class="inline-code">Object.keys</code> при передави в качестве аргументов значения не принадлежащему к типу <code class="inline-code">object</code> возвращает пустой массив. Тем не менее в аналогичной ситуации в версии <em>es5</em> возникает исключение. Поэтому начиная с версии <em>v3.5</em> поведение для метода <code class="inline-code">Object.keys</code> при передачи в него аргументов не совместымых с типом <code class="inline-code">object</code> было изменено.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * tsconfig.json
 * "target": "es5" or\and "lib": ["es5"]
 * 
 * v&#x3C;3.5 is Ok, let keys: string[]
 * v>=3.5 is Error
 */</span>
<span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-number">50</span>);</code></pre>

    </section>