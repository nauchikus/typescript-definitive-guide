<section id="Import-i-eksport-tolko-tipa-i-flag-importsNotUsedAsValues" name="Импорт и экспорт только типа и флаг --importsNotUsedAsValues" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Import-i-eksport-tolko-tipa-i-flag-importsNotUsedAsValues" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Импорт и экспорт только типа и флаг --importsNotUsedAsValues
        </h2>
        <hr>
        <p>Механизм уточнения импорта и экспорта (<code class="inline-code">import\export</code>) выступает в качестве указаний компилятору что данную конструкцию следует воспринимать исключительно как тип. Форма уточняющего импорта и экспорта включает в себя ключевое слово <code class="inline-code">type</code> идущее следом за ключевым словом <code class="inline-code">import</code> либо <code class="inline-code">export</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {Type} <span class="hljs-keyword">from</span> <span class="hljs-string">"./type"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {Type};</code></pre>
<p>Уточнению могут подвергаться только конструкции расцениваемые исключительно как типы (<code class="inline-code">interface</code>, <code class="inline-code">type alias</code> и <code class="inline-code">class</code>). </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType{}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {ClassType, IInterfaceType, AliasType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {ClassType, IInterfaceType, AliasType};</code></pre>
<p>Значения к которым можно отнести как экземпляры объектов, так и функции (<code class="inline-code">function expression</code> и <code class="inline-code">function declaration</code>) уточнятся, как в отдельности так и в одной форме с типами, не могут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IInterfaceType{}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> AliasType = {};


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> o = {};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fe = <span class="hljs-function"><span class="hljs-params">()</span>=></span>{};
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fd</span>(<span class="hljs-params"></span>)</span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">// import type {o, fe, fd} from "./types"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// import type {o, fe, fd, ClassType, IInterfaceType, AliasType} from "./types"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">import</span> {o, fe, fd} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>; <span class="hljs-comment">// Ok!</span>


<span class="hljs-comment">// export type {o, fe, fd}; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-comment">// export type {o, fe, fd, ClassType, IInterfaceType, AliasType} from "./types"; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)</span>
<span class="hljs-keyword">export</span> {o, fe, fd}; <span class="hljs-comment">// Ok!</span></code></pre>
<p>Кроме того уточненая форма импорта и экспорта не может одновременно содержать импорт\экспорт поумолчанию и не поумолчанию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file types.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> DefaultExportType {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ExportType {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * Error!
 * All imports in import declaration are unused.ts(6192)
 * A type-only import can specify a default import or named bindings, but not both.ts(1363)
 */</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> DefaultType, {ExportType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;</code></pre>
<p>Также не будет лишним оговорить, что классы экспортированные как уточненные само собой разумеется не могут участвовать в механизме наследования.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Base.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Base {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {Base} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Base"</span>;

<span class="hljs-keyword">class</span> Derivied <span class="hljs-keyword">extends</span> Base{}; <span class="hljs-comment">// 'Base' only refers to a type, but is being used as a value here.ts(2693)</span></code></pre>
<p>В дополнение механизму уточнения формы импорта\экспорта был добавлен флаг <code class="inline-code">--importsNotUsedAsValues</code> ожидаемый одно из трех значений. Но прежде чем познакомится с каждым предлагаю поглубже погрузится в природу возникновения необходимости в данном механизме.</p>
<p>Большинство разработчиков используя в повседневной работе механизм импорта\экспорта даже не подозревают что с ним связанно немало различных трудностей, которые возникают из-за механизмов призванных оптимизировать код. Но для начала рассмотрим несколько простых вводных примеров.</p>
<p>Представьте ситуацию при которой один модуль импортирует необходимый ему тип представленный такой конструкцией как <code class="inline-code">interface</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {IPerson} <span class="hljs-keyword">from</span> <span class="hljs-string">"./IPerson"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:IPerson</span>)</span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Поскольку интерфейс является конструкцией присущей исключительно <em>TypeScript</em> то не удивительно что после компиляции от неё не останется и следа.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Теперь представьте что один модуль импортирует конструкцию представленную классом, который задействован в логике уже знакомой нам функции <code class="inline-code">action()</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file IPerson.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IPerson {
    name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name:<span class="hljs-built_in">string</span></span>){}

    toString(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {IPerson} <span class="hljs-keyword">from</span> <span class="hljs-string">"./IPerson"</span>;
<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:IPerson</span>)</span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>

<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-keyword">new</span> Person(person);
}</code></pre>
<p>В этом случае класс <code class="inline-code">Person</code> был включон в скомпилированный файл поскольку необходим для правильного выполнения программы.</p>
<p>А теперь представьте ситуацию когда класс <code class="inline-code">Person</code> задействован в том же модуле <code class="inline-code">action.ts</code>, но исключительно в качестве типа. Другими словами он не задействован в логике работы модуля.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file Person.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Person {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name:<span class="hljs-built_in">string</span></span>){}

    toString(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">`[person <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>]`</span>;
    }
}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file action.ts</span>

<span class="hljs-keyword">import</span> {Person} <span class="hljs-keyword">from</span> <span class="hljs-string">"./Person"</span>;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person:Person</span>)</span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подумайте, что должна включать в себя итоговая сборка? Если вы выбрали вариант идентичный первому то вы совершенно правы! Поскольку класс <code class="inline-code">Person</code> используется в качестве типа то нет смысла включать его в результатирующий файл.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file action.js</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">person</span>)</span>{
    <span class="hljs-comment">//...</span>
}</code></pre>
<p>Подобное поведение кажется логичным и возможно благодаря механизму называемому <em>import elision</em>. Этот механизм определяет что конструкции которые теоретически могут быть включены в скомпилированный модуль требуются ему исключительно в качестве типа. И как уже можно было догадаться именно с этим механизмом и связанны моменты мешающие оптимизизаци кода. Тут-то и вступает в дело механизм уточнения формы импорта\экспорта.</p>
<p>Механизм уточнения способен разрешить возникающие перед <em>import-elision</em> трудности при ре-экспорте модулей предотвращению которых способствует установленный в значение <code class="inline-code">true</code> флаг <code class="inline-code">--isolatedModules</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IActionParams{}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">params:IActionParams</span>)</span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> {IActionParams, action} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-comment">/**
 * [Error! ts &#x3C;3.8] > Cannot re-export a type when the '--isolatedModules' flag is provided.ts(1205)
 * 
 * [Error! ts >=3.8] > Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.ts(1205)
 */</span>
<span class="hljs-keyword">export</span> {IActionParams, action};


<span class="hljs-comment">/**
 * 
 * Поскольку компиляторы как TypeScript так и Babel
 * в контексте файла неспособны определить является
 * ли конструкция IActionParams допустимой для JavaScript
 * существует вероятность возникновения ошибки. Простыми
 * словами механизмы обоих компиляторов не знаю нужно ли
 * удалять следы связанные с IActionParams из скомпилированного
 * .js кода или нет. Именно поэтому был добавлен флаг 
 * --isolatedModules который предупреждает о опасной ситуации.
 */</span>

 </code></pre>
<p>Рассмотренный выше случай можно разрешить с помощью явного уточнения формы импорта\экспорта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file re-export.ts</span>

<span class="hljs-keyword">import</span> {IActionParams, action} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-comment">/**
 * Явно указываем что IActionParams это тип.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> {IActionParams};
<span class="hljs-keyword">export</span> {action};</code></pre>
<p>Специально введенный и ранее упомянутый флаг <code class="inline-code">--importsNotUsedAsValues</code>, как уже было сказанно, ожидает одно из трех возможных на данный момент значений - <code class="inline-code">remove</code>, <code class="inline-code">preserve</code> или <code class="inline-code">error</code>.</p>
<p>Значение <code class="inline-code">remove</code> активирует или другими словами оставляет поведение реализуемое до версии <code class="inline-code">3.8</code>.
Значения <code class="inline-code">preserve</code> способно разрешить проблему возникающую при экспорте так называемых сайд-эффектов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects{};

incrementVisitCounterLocalStorage(); <span class="hljs-comment">// ожидается что вызов произойдет в момент подключения модуля</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-keyword">let</span> data:IDataFromModuleWithSideEffects = {};

<span class="hljs-comment">/**
 * Несмотря на то что модуль module.ts
 * задействован в коде, его содержимое
 * не будет включено в скомпилированную
 * программу, поскольку компилятор исключает
 * импорты конструкций не учавствующих в её логике.
 * Таким образом функция incrementVisitCounterLocalStorage()
 * никогда не будет вызвана, а значит программа не будет
 * работать корректно! 
 */</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> data = {};

<span class="hljs-comment">/**
 * В итоге программе ничего не
 * известно о модуле module-with-side-effects.ts
 */</span></code></pre>
<p>Решение из ситуации описанной выше заключается в повторном указании импорта всего модуля. Но не всем такое решение кажется очевидным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects"</span>; <span class="hljs-comment">// импорт всего модуля</span>

<span class="hljs-keyword">let</span> data:IDataFromModuleWithSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects.js"</span>;

<span class="hljs-keyword">let</span> data = {};

<span class="hljs-comment">/**
 * Теперь программа выполнится так как и ожидалось.
 * То есть модуль module-with-side-effects.ts включен
 * в её состав.
 */</span></code></pre>
<p>Поэтому прежде всего начиная с версии <code class="inline-code">3.8</code> сама <code class="inline-code">ide</code> укажит на возможность уточнения импорта исключительно типов, что в свою очередь должно подтолкнуть на размышление о удалении импорта при компиляции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>; <span class="hljs-comment">//This import may be converted to a type-only import.ts(1372)</span></code></pre>
<p>Кроме того флаг <code class="inline-code">preserve</code> в отсутствие уточнения поможет избавится от повторного указания импорта. Простыми словами значение <code class="inline-code">preserve</code> указывает компилятору импортировать все модули полностью.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-with-side-effects.ts</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementVisitCounterLocalStorage</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// увеличиваем счетчик посещаемости в localStorage</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithSideEffects{};

incrementVisitCounterLocalStorage(); </code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file module-without-side-effects.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IDataFromModuleWithoutSideEffects{};</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>


<span class="hljs-comment">// Без уточнения</span>
<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./module-without-side-effects"</span>;

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};

<span class="hljs-comment">/**
 * 
 * Несмотря на то что импортировались
 * исключительно конструкции-типы, модули
 * были импортированны полностью.
 */</span></code></pre>
<p>В случае уточнения поведение при компиляции останется прежднем. То есть в импорты в скомпилированный файл включены не будут.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>


<span class="hljs-comment">// С уточнением</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// после компиляции @file index.js</span>

<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects = {};

<span class="hljs-comment">/**
 * 
 * Импорты отсутствуют.
 */</span></code></pre>
<p>Если же флагу <code class="inline-code">--importsNotUsedAsValues</code> задано значение <code class="inline-code">error</code>, то при импортировании типов без явного уточнения будет считаться ошибочным поведением.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * 
 * [0][1] Error > This import is never used as a value and must use 'import type' because the 'importsNotUsedAsValues' is set to 'error'.ts(1371)
 */</span>

<span class="hljs-keyword">import</span> {IDataFromModuleWithSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-with-side-effects"</span>;
<span class="hljs-keyword">import</span> {IDataFromModuleWithoutSideEffects} <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-without-side-effects"</span>;


<span class="hljs-keyword">let</span> dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};
<span class="hljs-keyword">let</span> dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};</code></pre>
<p>Скомпилированный код выше после устранения ошибок, то есть после уточнения, включать в себя импорты не будет.</p>
<p>В заключение стоит заметить что в теории уточнение такой конструкции как класс способно ускорить компиляцию посколько избавляет компилятор от ненужных проверок на вовлечении его в логику работы модуля. Ну и кроме того, уточнения формы импорта\экспорта, это ещё один способ сделать код более информативным.</p>
<p>Также стоит обратить особое внимание, что на данный момент <em>конструкции-значения<strong> уточненные как </strong>конструкции-типы</em> не могут участвовать как в механизме наследования при объявлении декларации (<code class="inline-code">declare</code>), так и при запросе типа (<code class="inline-code">typeof</code>). Но эти недоработки планируется устранить в следующих версиях.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file ClassType.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ClassType {}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {ClassType} <span class="hljs-keyword">from</span> <span class="hljs-string">"./ClassType"</span>;

<span class="hljs-comment">/**
 * [0][1] Error! > 'ClassType' only refers to a type, but is being used as a value here.ts(2693)
 */</span>

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> T <span class="hljs-keyword">extends</span> ClassType{} <span class="hljs-comment">// [0]</span>

<span class="hljs-keyword">let</span> prop: <span class="hljs-keyword">typeof</span> ClassType; <span class="hljs-comment">// [1]</span></code></pre>

    </section>
<section id="Zakrytye-polya-ECMScript" name="Закрытые поля ECMScript" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zakrytye-polya-ECMScript" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Закрытые поля ECMScript
        </h2>
        <hr>
        <p>Помимо сокрытия полей класса от внешней среды с помощью модификатора доступа <code class="inline-code">private</code>, присущего исключительно <em>TypeScript</em>, начиная с версии <code class="inline-code">3,8</code> появилась возможность прибегнуть к механизму предусмотренного спецификацией <em>ECMScript</em>. Для того чтобы воспользоваться данным механизмом идентификаторы скрываемых полей должны начинаться с символа решетка <code class="inline-code">#</code>.
Доступ к защещенному полю класса ограничивается областью видимости класса в котором оно объявленно, а при обращении к нему необходимо также указывать символ решетка. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>

    <span class="hljs-keyword">get</span> isLife(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#isLife;
    }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();
<span class="hljs-built_in">console</span>.log(animal.isLife); <span class="hljs-comment">// обращение к аксессору, а не защищенному полю</span></code></pre>
<p>Поскольку доступ ограничивается областью видимости класса, потомки не могут обращаться к защищенным полям своих предков.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// защищенное поле класса</span>
}
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.#isLife; <span class="hljs-comment">// Error! > Property '#isLife' is not accessible outside class 'Animal' because it has a private identifier.ts(18013)</span>
    }
}</code></pre>
<p>В отличии от модификатора доступа <code class="inline-code">private</code> данный механизм не может быть применен к методам класса, но так как за его появлением стоит спецификация <em>ECMScript</em>, он продолжает действовать в скомпилированной программе. Именно поэтому, в отличии от сценария с модификатором доступа <code class="inline-code">private</code>, <em>потомки</em> могут без страха нарушить ожидаемый ход выполнения программы объявлять защищенные поля чьи идентификаторы идентичны объявлениям в их <em>супер-классах</em>. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// сценарий с модификатором доступа private</span>

<span class="hljs-keyword">class</span> Animal {
    <span class="hljs-keyword">private</span> _isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
    
}
<span class="hljs-comment">/**
 * Error!
 * 
 * Class 'Bird' incorrectly extends base class 'Animal'.
  Types have separate declarations of a private property '_isLife'.ts(2415)
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    <span class="hljs-keyword">private</span> _isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// сценарий с защищенными полями предусмотренными спецификацией ECMScript</span>

<span class="hljs-keyword">class</span> Animal {
    #isLife:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
    
}
<span class="hljs-comment">/**
 * Ok!
 */</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
    #isLife: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

}</code></pre>
<p>И в заклчение стоит упомянуть что существует несколько нюансов. Один из них заключается в том, что закрытые поля нельзя объявлять непосредственно в конструкторе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
    <span class="hljs-comment">// Parameter declaration expected.ts(1138)</span>
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">#isLife=<span class="hljs-literal">true</span></span>){}
    
}</code></pre>
<p>Другой нюанс связан с тем, что код содержащий закрытые поля класса может быть скомпилирован исключительно в версии <code class="inline-code">es6</code> и выше.</p>

    </section>
<section id="await-vysshego-urovnya" name="await высшего уровня" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="await-vysshego-urovnya" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            await высшего уровня
        </h2>
        <hr>
        <p>Поскольку современную разработку на языке <em>JavaScript</em> сложно представить без таких конструкций как <code class="inline-code">Promise</code>, которые выглядят намного привлекательней при использовании совместно с таким механизмом активирующимся при помощи ключевого слова <code class="inline-code">await</code>. Но правилами установлено, что ключевое слово <code class="inline-code">await</code> должно указываться исключительно в функциях объявленных с использованием ключевого слова <code class="inline-code">async</code>. Это в свою очередь, в некоторых случаях вынуждало разработчиков объявлять нетребующиеся им функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">/**
 * Применение ключевого слова await
 * требует объявления функции в которой
 * появляется потребность исключительно
 * из-за необходимости в ключевом слове async
 */</span>

<span class="hljs-keyword">const</span> run = <span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hello`</span>);
    <span class="hljs-keyword">let</span> world = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`World`</span>);
    
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${hello}</span> <span class="hljs-subst">${world}</span>!`</span>
};

run().then(<span class="hljs-function"><span class="hljs-params">greeting</span>=></span> <span class="hljs-built_in">console</span>.log(greeting));</code></pre>
<p>Создатели спецификации <em>ECMScript</em> обратили на это внимание и добавили в неё такой механизм, как <code class="inline-code">await</code> высшего уровня (<em>top-level await</em>). <code class="inline-code">await</code> высшего уровня позволяет избавится от нетребующейся функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file index.ts</span>

<span class="hljs-comment">/**
 * Внимание, псевдо код!
 * Данный код находящийся
 * в файле index.ts не считается
 * модулем. Объяснение дается далее
 * по содержанию. 
 */</span>

<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hello`</span>);
<span class="hljs-keyword">let</span> world = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`World`</span>);

<span class="hljs-keyword">let</span> greeting = <span class="hljs-string">`<span class="hljs-subst">${hello}</span> <span class="hljs-subst">${world}</span>!`</span>;

<span class="hljs-built_in">console</span>.log(greeting);</code></pre>
<p>Единственное стоит всегда помнить, что высшим уровнем считается модуль, а файл в <em>TypeScript</em> считается модулем тогда, когда включает в себя хотя бы одно упоминания импорта или экспорта. Поэтому не исключено что в особых случаях появится необходимость приведения к модулю.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file gtreeting-utils.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> toMessage = <span class="hljs-function">(<span class="hljs-params">hello:<span class="hljs-built_in">string</span>,world:<span class="hljs-built_in">string</span></span>) =></span> 
    <span class="hljs-string">`<span class="hljs-subst">${hello}</span> <span class="hljs-subst">${world}</span>!`</span>;</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример с import</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> GreetingUtils <span class="hljs-keyword">from</span> <span class="hljs-string">"./greeting-utils"</span>;

<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hello`</span>);
<span class="hljs-keyword">let</span> world = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`World`</span>);

<span class="hljs-keyword">let</span> greeting = GreetingUtils.toMessage(hello, world);

<span class="hljs-built_in">console</span>.log(greeting);</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// пример с пустым экспортом</span>

<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hello`</span>);
<span class="hljs-keyword">let</span> world = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`World`</span>);

<span class="hljs-keyword">let</span> greeting = <span class="hljs-string">`<span class="hljs-subst">${hello}</span> <span class="hljs-subst">${world}</span>!`</span>;

<span class="hljs-built_in">console</span>.log(greeting);

<span class="hljs-keyword">export</span> {};</code></pre>
<p>Кроме того поддержка <code class="inline-code">await</code> высшего уровня становится доступной при компиляции в версию начиная с <code class="inline-code">es2017</code>, а в качестве модулей выбрано <code class="inline-code">esnext</code> или <code class="inline-code">system</code>.</p>

    </section>
<section id="Realizaciya-novoi-formy-re-eksporta" name="Реализация новой формы ре-экспорта" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Realizaciya-novoi-formy-re-eksporta" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Реализация новой формы ре-экспорта
        </h2>
        <hr>
        <p>Зачастую появляется необходимость ре-экспорта содержимого модуля, как единую точку входа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// @file utils.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span>, b:<span class="hljs-built_in">number</span></span>) =></span> a + b;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mul = <span class="hljs-function">(<span class="hljs-params">a:<span class="hljs-built_in">number</span>, b:<span class="hljs-built_in">number</span></span>) =></span> a * b;</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// MathUtils.ts</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> MathUtils <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils"</span>;
<span class="hljs-keyword">export</span> {MathUtils};</code></pre>
<p>Подоное встречается столь часто, что в спецификацию <em>ECMScript 2020</em> была включена новая форма ре-экспорта всего содержимого.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> Identificator <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;</code></pre>
<p>Благодаря разработчикам языка <em>TypeScript</em> подобная форма ре-экспорта стала доступной начиная с версии <code class="inline-code">3.8</code>. Предыдущий пример с применением нового синтаксиса мог бы сократится до одной строчки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// MathUtils.ts</span>

<span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> MathUtils <span class="hljs-keyword">from</span> <span class="hljs-string">"./utils"</span>;</code></pre>

    </section>
<section id="Novaya-konfiguracionnaya-gruppa-parametrov-watchOptions" name="Новая конфигурационная группа параметров watchOptions" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Novaya-konfiguracionnaya-gruppa-parametrov-watchOptions" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Новая конфигурационная группа параметров watchOptions
        </h2>
        <hr>
        <p>Оптимольно организовать наблюдение за файловой системой дело довольно не простое поскольку ресурсоемкость и энергозатратность сильно зависит как от <em>api</em> платформы, так и от предоставляемых различными библиотеками деклараций. И это не удивительно, ведь ОС по разному реализуют процесс наблюдения и тем самым затрудняют поддержание актуальности при интенсивном изменении отслежываемых файлов. И кроме того, только задумайтесь, сколько пакетов в директории <em>node_modules</em> и каково суммарное количество строк предоставляемых ими деклараций <em>.d.ts</em>?</p>
<p>Поэтому перед разработчиками <em>TypeScript</em> всегда остро стояла задача максимально оптимизировать этот процесс. Как следствие в конфигурационном файле <em>tsconfig.json</em> появилась новая группа для конфигурирования <code class="inline-code">watchOptions</code> позволяющая выбрать оптимальную стратегию в зависимости от самого проекта.</p>
<pre><code class="hljs language-json"><span class="hljs-comment">// tsconfig.json</span>

{
    <span class="hljs-attr">"compilerOptions"</span>: {},
    <span class="hljs-comment">// новое поле</span>
    <span class="hljs-attr">"watchOptions"</span>: {

    }
}</code></pre>
<p>Так новая группа реализует четыре параметра - <code class="inline-code">watchFile</code>, <code class="inline-code">watchDirectory</code>, <code class="inline-code">fallbackPolling</code> и <code class="inline-code">synchronousWatchDirectory</code>.</p>
<pre><code class="hljs language-json"><span class="hljs-comment">// tsconfig.json</span>

{
    <span class="hljs-attr">"compilerOptions"</span>: {},
    <span class="hljs-comment">// новое поле</span>
    <span class="hljs-attr">"watchOptions"</span>: {
        <span class="hljs-attr">"watchFile"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-attr">"watchDirectory"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-attr">"fallbackPolling"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-attr">"synchronousWatchDirectory"</span>: <span class="hljs-string">"..."</span>
    }
}</code></pre>
<ul class="book__list">
<li class="book__list__item"><code class="inline-code">watchFile</code>: стратегия наблюдения за отдельными файлами<ul class="book__list">
<li class="book__list__item"><code class="inline-code">fixedPollingInterval</code>: Проверять каждый файл на наличие изменений несколько раз в секунду с фиксированным интервалом.</li>
<li class="book__list__item"><code class="inline-code">priorityPollingInterval</code>: Проверяйть каждый файл на наличие изменений несколько раз в секунду, но использовать эвристику для проверки файлов определенных типов реже, чем других.</li>
<li class="book__list__item"><code class="inline-code">dynamicPriorityPolling</code>: Использовать динамическую очередь, в которой менее часто изменяемые файлы будут проверяться реже.</li>
<li class="book__list__item"><code class="inline-code">useFsEvents</code> [ПО УМОЛЧАНИЮ]: Пытаться использовать собственные события операционной системы / файловой системы для изменения файлов.</li>
<li class="book__list__item"><code class="inline-code">useFsEventsOnParentDirectory</code>: Пытаться использовать собственные события операционной системы/файловой системы для прослушивания изменений в каталогах, содержащих файл. Это может использовать меньше файловых наблюдателей, но также быть менее точным.</li>
</ul></li>
<li class="book__list__item"><code class="inline-code">watchDirectory</code>: стратегия наблюдения за целыми деревьями каталогов в системах, в которых отсутствует рекурсивная функция наблюдения за файлами.<ul class="book__list">
<li class="book__list__item"><code class="inline-code">fixedPollingInterval</code>: Проверять каждый каталог на наличие изменений несколько раз в секунду с фиксированным интервалом.</li>
<li class="book__list__item"><code class="inline-code">dynamicPriorityPolling</code>: Использовать динамическую очередь, в которой менее часто изменяемые каталоги будут проверяться реже.</li>
<li class="book__list__item"><code class="inline-code">useFsEvents</code>[ПО УМОЛЧАНИЮ]: Пытаться использовать собственные события операционной системы / файловой системы для изменений каталога.</li>
</ul></li>
<li class="book__list__item"><code class="inline-code">fallbackPolling</code>: при использовании событий файловой системы этот параметр определяет стратегию опроса, которая используется, когда в системе заканчиваются собственные наблюдатели файлов и / или не поддерживаются собственные средства простмотра файлов.<ul class="book__list">
<li class="book__list__item"><code class="inline-code">fixedPollingInterval</code>: см выше.</li>
<li class="book__list__item"><code class="inline-code">priorityPollingInterval</code>[ПО УМОЛЧАНИЮ]: см выше.</li>
<li class="book__list__item"><code class="inline-code">dynamicPriorityPolling</code>: см выше.</li>
</ul></li>
<li class="book__list__item"><code class="inline-code">synchronousWatchDirectory</code>: Отключить отложенное наблюдение за каталогами.<ul class="book__list">
<li class="book__list__item"><code class="inline-code">true</code></li>
<li class="book__list__item"><code class="inline-code">false</code>[ПО УМОЛЧАНИЮ]</li>
</ul></li>
</ul>

    </section>
<section id="Novyi-flag-assumeChangesOnlyAffectDirectDependencies" name="Новый флаг --assumeChangesOnlyAffectDirectDependencies" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Novyi-flag-assumeChangesOnlyAffectDirectDependencies" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Новый флаг --assumeChangesOnlyAffectDirectDependencies
        </h2>
        <hr>
        <p>С помощью таких опций компилятора как <code class="inline-code">--watch</code> и <code class="inline-code">--incremental</code> можно значительно сократить время сборки проекта. Напомню, что первый активирует наблюдение за файлами, а второй устанавливает связи между ними при помощи генерации файла с метаинформацией .tsbuildinf.</p>
<p>Но на очень больших проектах этих мер по сокращению время сборки довольно недостаточно. Поэтому многие разраюотчики высказываются за сокращение время сборки в угоду точности проверок изменений. Итогом подобных рассуждений стал новый флаг компилятора <code class="inline-code">--assumeChangesOnlyAffectDirectDependencies</code> при активации которой компилятор не будет перепроверять\перестраивать файлы, которые на основе метоинформации считаюся затронутыми. Вместо этого будет перепроверятся\перестраиваться только непосредственно именненые файлы и файлы их импортирующие.</p>
<p>Представьте что <code class="inline-code">fileA.ts</code> импортирует <code class="inline-code">fileB.ts</code>, который импортирует <code class="inline-code">fileC.ts</code>, который импортирует <code class="inline-code">fileD.td</code>.</p>
<p>При активном рижиме <code class="inline-code">--watch</code> изменения в файле <code class="inline-code">fileD.ts</code> означает что как минимум будут проверены <code class="inline-code">fileC.ts</code>, <code class="inline-code">fileB.ts</code> и <code class="inline-code">fileA.ts</code>. При активной опциеи <code class="inline-code">--assumeChangesOnlyAffectDirectDependencies</code> проверке подвергнется лишь <code class="inline-code">fileA.ts</code> и <code class="inline-code">fileB.ts</code>.</p>
<p>Как отмечают первые испытатели, данное нововведение в некоторых случаях сократило время сборки в 14 раз, что можно назвать очень значительным, когда компиляция длится четверть минуты.
</p>

    </section>
<section id="Modifikatory-JSDocs" name="Модификаторы JSDocs" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Modifikatory-JSDocs" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            Модификаторы JSDocs
        </h2>
        <hr>
        <p>Компиляция <em>.js</em> файлов доступная за флагом <code class="inline-code">allowJs</code> была бы не эффективной если бы отсутствовало аннотирование <em>JavaScript</em> кода при помощи <em>JSDoc комментариев</em> активируемых флагом <code class="inline-code">checkJs</code> или <em>комментарной диррективой</em> <code class="inline-code">// @ts-check</code>. Чтобы повысить эффективность данного механизма были добавлены новые <em>JSDoc</em> директивы. Так компилятор <em>TypeScript</em> получил поддержку модифицирующих директив как <code class="inline-code">@public</code>, <code class="inline-code">@private</code> и <code class="inline-code">@protected</code>, чье поведение полностью соответствует поведению одноименных модификаторов из <em>TypeScript</em>. Кроме того без изменений остался список <em>членов класса</em> к которым эти модификаторы могут быть примененны (<em>поля</em>, <em>свойства</em>, <em>методы</em> как экземпляра так и самого класса).</p>
<pre><code class="hljs language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
    <span class="hljs-keyword">constructor</span>(){
        <span class="hljs-comment">/**@public */</span>
        <span class="hljs-keyword">this</span>.public = <span class="hljs-number">0</span>;

        <span class="hljs-comment">/**@private */</span>
        <span class="hljs-keyword">this</span>.private = <span class="hljs-number">0</span>;

        <span class="hljs-comment">/**@protected */</span>
        <span class="hljs-keyword">this</span>.protected = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/**@private */</span>
    method(){}
}</code></pre>
<p>Помимо этого также был добавлен модификатор <code class="inline-code">/** @readonly */</code> чьё поведение также полностью идентичное одноименному модификатору из <em>TypeScript</em>, который к тому же можно совмещать с другими модификаторами.</p>
<pre><code class="hljs language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
    <span class="hljs-comment">/**@readonly */</span>
    <span class="hljs-keyword">static</span> READONLY = <span class="hljs-literal">true</span>;

    <span class="hljs-comment">/**@protected @readonly */</span>
    <span class="hljs-keyword">static</span> PROTECTED_READONLY = <span class="hljs-literal">true</span>;
}</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Bolee-strogie-proverki-obedinenii-imeushchih-s-indeksnoi-signaturoi" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Более строгие проверки объединений имеющих с индексной сигнатурой" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Bolee-strogie-proverki-obedinenii-imeushchih-s-indeksnoi-signaturoi" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Более строгие проверки объединений имеющих с индексной сигнатурой
        </h2>
        <hr>
        <p>До текущей версии типу объединения включающего тип с индексной сигнатурой было возможно присвоить значение имеющее поля неудовлетворяющие этой индексной сигнатуре. Начиная с версии <code class="inline-code">3.8</code> это поведение стало строже и описанный выше сценарий считается ошибочным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> o0: { [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> } | { field: <span class="hljs-built_in">number</span> };
<span class="hljs-comment">/**
 * [&#x3C; v3.8] Ok
 * [>= v3.8] Error
 * Type 'string' is not assignable to type 'number'.ts(2322)
 */</span>
o0 = { field: <span class="hljs-number">5</span>, dynamicKey: <span class="hljs-string">''</span> };


<span class="hljs-keyword">let</span> o1: { [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> } | { [key: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> };
<span class="hljs-comment">/**
 * [&#x3C; v3.8] Ok
 * [>= v3.8] Error
 * Type 'string' is not assignable to type 'number'.ts(2322)
 */</span>
o1 = { dynamicKey: <span class="hljs-string">''</span> };</code></pre>

    </section>
<section id="KRITIChESKOE-IZMENENIE-Tip-object-v-JSDoc-pri-aktivnom-flage-noImplicitAny-bolshe-ne-rasscenivaetsya-kak-any" name="[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Тип object в JSDoc при активном флаге --noImplicitAny больше не рассценивается как any" class="subchapter">
        <h2 class="subchapter-title">
            <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="KRITIChESKOE-IZMENENIE-Tip-object-v-JSDoc-pri-aktivnom-flage-noImplicitAny-bolshe-ne-rasscenivaetsya-kak-any" type="absolute-url">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <use href="#icon_link"/>
                </svg>
            </button>
            [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Тип object в JSDoc при активном флаге --noImplicitAny больше не рассценивается как any
        </h2>
        <hr>
        <p>До текущей версии тип <code class="inline-code">object</code> указанный в <em>JSDoc</em> при активном флаге <code class="inline-code">--noImplicitAny</code> рассценивался <em>TypeScript</em> как тип <code class="inline-code">any</code>. Нчиная с текщей версии поведение типа <code class="inline-code">object</code> синхронизированно с поведением реализуемым <em>TypeScript</em>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * @param p0 {Object}
 * @param p1 {object}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p0, p1</span>)</span>{}</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// --noImplicitAny: true</span>

<span class="hljs-keyword">import</span> {f} <span class="hljs-keyword">from</span> <span class="hljs-string">"./jsdocs"</span>;

<span class="hljs-comment">/**
 * [&#x3C;  3.8] f(p0: Object, p1: any): void
 * [>= 3.8] f(p0: Object, p1: object): void
 */</span></code></pre>

    </section>