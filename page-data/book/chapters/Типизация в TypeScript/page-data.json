{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/Типизация в TypeScript","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Бесплатная pdf книга на русском по языку TypeScript."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Типизация в TypeScript","section":"Типизация","path":"tipizaciya v typescript","subtitles":[{"subtitle":"Общие сведения","path":"tipizaciya v typescript#obshchie svedeniya"},{"subtitle":"Статическая типизация (static typing)","path":"tipizaciya v typescript#staticheskaya tipizaciya (static typing)"},{"subtitle":"Сильная типизация (strongly typed)","path":"tipizaciya v typescript#silnaya tipizaciya (strongly typed)"},{"subtitle":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"tipizaciya v typescript#yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"subtitle":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"tipizaciya v typescript#sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"subtitle":"Вариантность (variance)","path":"tipizaciya v typescript#variantnost (variance)"},{"subtitle":"Наилучший общий тип (Best common type)","path":"tipizaciya v typescript#nailuchshii obshchii tip (best common type)"},{"subtitle":"Контекстный тип (Contextual Type)","path":"tipizaciya v typescript#kontekstnyi tip (contextual type)"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Типизация в TypeScript</span></h1><p class=\"content__paragraph\">Данная глава поможет разработчикам не просто писать типизированный код, а делать это в полной мере осмысленно. Для этого необходимо ещё раз повторить все концепции нашедшие свое применение в языке <em>TypeScript</em>.</p></section>\n<section class=\"content__section\" id=\"Общие сведения\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obshchie svedeniya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Общие сведения</span></h2><p class=\"content__paragraph\">Самое время взять паузу и рассмотреть типизацию в <em>TypeScript</em> более детально через призму полученных знаний.</p><p class=\"content__paragraph\">Итак, что известно о <em>TypeScript</em>? <em>TypeScript</em> это язык:</p><ol class=\"content__list\">\n<li>Статически типизированный с возможностью динамического связывания</li>\n<li>Сильно типизированный</li>\n<li>Явно типизированный с возможностью вывода типов</li>\n<li>Совместимость типов в <em>TypeScript</em> проходит по правилам структурной типизации </li>\n<li>Совместимость типов зависит от вариантности, чей конкретный вид определяется конкретным случаем</li>\n</ol><p class=\"content__paragraph\">Кроме этого, существуют понятия являющиеся частью перечисленных, но в <em>TypeScript</em>, выделенные в отдельные определения. По этой причине они будут рассматриваться отдельно. Такими понятиями являются: </p><ol class=\"content__list\">\n<li>Наилучший общий тип</li>\n<li>Контекстный тип</li>\n</ol><p class=\"content__paragraph\">Начнем с повторения определений в том порядке, в котором они были перечислены.</p></section>\n<section class=\"content__section\" id=\"Статическая типизация (static typing)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"staticheskaya tipizaciya (static typing)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Статическая типизация (static typing)</span></h2><p class=\"content__paragraph\"><em>Статическая типизация</em> обуславливается тем, что связывание с типом данных происходит на этапе компиляции и при этом тип не может изменится на протяжении всего своего существования.</p><p class=\"content__paragraph\">Статическая типизация в <em>TypeScript</em> проявляется в том, что к моменту окончания компиляции компилятору известно к какому конкретному типу принадлежат конструкции нуждающиеся в аннотации типа.</p></section>\n<section class=\"content__section\" id=\"Сильная типизация (strongly typed)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"silnaya tipizaciya (strongly typed)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Сильная типизация (strongly typed)</span></h2><p class=\"content__paragraph\">Язык с <em>сильной типизацией</em> не позволяет операции с несовместимыми типами, а также не выполняет явного преобразования типов.</p><p class=\"content__paragraph\">Сильная типизация в <em>TypeScript</em> проявляет себя в случаях схожих с операцией сложения числа с массивом. В этом случае компилятор выбрасывает ошибки.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Явно типизированный (explicit typing) с выводом типов (type inference)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Явно типизированный (explicit typing) с выводом типов (type inference)</span></h2><p class=\"content__paragraph\">Язык с <em>явной типизацией</em> предполагает, что указание типов будет выполнено разработчиком. Но современные языки с явной типизацией имеют возможность указывать типы неявно. Это становится возможным за счет механизма <em>вывода типов</em>.</p><p class=\"content__paragraph\">Вывод типов — это возможность компилятора (интерпретатора) самостоятельно выводить-указывать тип данных на основе анализа выражения.</p><p class=\"content__paragraph\">В <em>TypeScript</em>, если тип не указывается явно, компилятор с помощью вывода типов выводит и указывает тип самостоятельно.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> animal<span class=\"token operator\">:</span> Animal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animal: Animal</span>\n<span class=\"token keyword\">var</span> animal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animal: Animal</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Совместимость типов (Type Compatibility), структурная типизация (structural typing)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Совместимость типов (Type Compatibility), структурная типизация (structural typing)</span></h2><p class=\"content__paragraph\"><em>Совместимость типов</em> — это механизм по которому происходит сравнение типов.</p><p class=\"content__paragraph\">Простыми словами, совместимость типов — это совокупность правил, на основе которых программа анализируя два типа данных, выясняет, производить над ними операции считая их совместимыми, либо для этого требуется преобразование. Правила совместимости типов делятся на три вида, один из которых имеет название структурная типизация.</p><p class=\"content__paragraph\"><em>Структурная Типизация</em> - это принцип определяющий совместимость типов основываясь не на иерархии наследования или явной реализации интерфейсов, а на их описании.</p><p class=\"content__paragraph\">Несмотря на то, что <code>Bird</code> и <code>Fish</code> не имеют явно заданного общего предка, <em>TypeScript</em> разрешает присваивать экземпляр класса <code>Fish</code> переменной с типом <code>Bird</code> (и наоборот).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В таких языках, как <em>Java</em> или <em>C#</em>, подобное поведение недопустимо. В <em>TypeScript</em> это становится возможно из-за структурной типизации.</p><p class=\"content__paragraph\">Так как совместимость типов происходит на основе их описания, в первом случае компилятор запоминает все члены типа <code>Fish</code> и если он находит аналогичные члены в типе <code>Bird</code>, то они считаются совместимыми. То же самое компилятор проделывает тогда, когда во втором случае присваивает экземпляр класса <code>Bird</code> переменной с типом <code>Fish</code>. Так как оба типа имеют по одному полю, с одинаковым типом и идентификатором, то они считаются совместимыми.</p><p class=\"content__paragraph\">Если добавить классу <code>Bird</code> поле <code>wings</code>, то при попытке присвоить его экземпляр переменной с типом <code>Fish</code> возникнет ошибка, так как в типе <code>Fish</code> отсутствует после <code>wings</code>. Обратное действие, то есть присвоение экземпляра класса <code>Bird</code> переменной с типом <code>Fish</code>, ошибки не вызовет, так как в типе <code>Bird</code> будут найдены все члены объявленные в типе <code>Fish</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> wings<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">var</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Стоит добавить, что правилам структурной типизации подчиняются все объекты в <em>TypeScript</em>. А, как известно, в <em>JavaScript</em> все, кроме примитивных типов, объекты. Это же утверждение верно и для <em>TypeScript</em>.</p></section>\n<section class=\"content__section\" id=\"Вариантность (variance)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"variantnost (variance)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вариантность (variance)</span></h2><p class=\"content__paragraph\">Простыми словами, <em>вариантность</em> — это механизм, определяющий правила на основе которых принимается решение о совместимости двух типов. Правила зависят от конкретного вида вариантности — <em>ковариантность</em>, <em>контравариантность</em>, <em>бивариантность</em> и <em>инвариантность</em>. В случае с <em>TypeScript</em> нас интересуют первые три.</p><p class=\"content__paragraph\">Ковариантность позволяет большему типу быть совместимым с меньшим типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IAnimal <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> IAnimal <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'animal'</span> \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IBird <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> IBird <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'bird'</span><span class=\"token punctuation\">,</span> \n        <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Контравариантность позволяет меньшему типу быть совместимым с большим типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IAnimal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IBird<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Бивариантность, доступная исключительно для параметров функций при условии, что флаг <code>--strictFunctionTypes</code> установлен в значение <code>false</code>, делает возможной совместимость как большего типа с меньшим, так и наоборот — меньшего с большим.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IAnimal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IBird<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok, (--strictFunctionTypes === false)</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Не будет лишним упомянуть, что бивариантность снижает уровень типобезопасности программы и поэтому рекомендуется вести разработку с флагом <code>--strictFunctionTypes</code> установленным в значение <code>true</code>.</p></section>\n<section class=\"content__section\" id=\"Наилучший общий тип (Best common type)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"nailuchshii obshchii tip (best common type)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Наилучший общий тип (Best common type)</span></h2><p class=\"content__paragraph\">С выводом типов в <em>TypeScript</em> связано такое понятие, как наилучший общий тип. Это очень простое правило, название которого в большей мере раскрывает его суть. </p><p class=\"content__paragraph\">Как уже было сказано, <em>TypeScript</em> — статически типизированный язык, и поэтому он пытается всему указать типы. В случаях, когда тип не был указан явно, в работу включается вывод типов. Предположим, что существует массив ссылка на который присваивается переменной объявленной без явного указания типа. Для того, чтобы вывод типов смог вывести тип для переменной, ему нужно проанализировать данные хранящиеся в массиве (если они хранятся).</p><p class=\"content__paragraph\">Для примера представьте массив хранящий экземпляры классов <code>Animal</code>, <code>Elephant</code> и <code>Lion</code>, последние два из которых расширяют первый. И кроме того, ссылка на данный массив присваивается переменной.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: Animal[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Так как <em>TypeScript</em> проверяет совместимость типов по правилам структурной типизации и все три типа идентичны с точки зрения их описания, то с точки зрения вывода типов все они идентичны. Поэтому он выберет в качестве типа тот который является более общим, то есть тип <code>Animal</code>.</p><p class=\"content__paragraph\">Если типу <code>Elephant</code> будет добавлено поле, например, хобот (<code>trunk</code>), что сделает его отличным от всех, то вывод типов будет вынужден указать массиву базовый для всех типов тип <code>Animal</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> thrunk<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: Animal[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае, если в массиве не будет присутствовать базовый для всех типов тип <code>Animal</code>, то вывод типов будет расценивать массив как принадлежащий к типу объединение <code>Elephant | Lion</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> thrunk<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: (Elephant | Lion)[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Как видно, ничего неожиданного или сложного в теме наилучшего общего типа совершенно нет.</p></section>\n<section class=\"content__section\" id=\"Контекстный тип (Contextual Type)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"kontekstnyi tip (contextual type)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Контекстный тип (Contextual Type)</span></h2><p class=\"content__paragraph\">Контекстным называется тип, который при не явном объявлении указывается за счет декларации контекста, а не с помощью вывода типов.</p><p class=\"content__paragraph\">Лучшим примером контекстного типа может служить подписка <code>document</code> на событие мыши <code>mousedown</code>. Так как у слушателя события тип параметра <code>event</code> не указан явно, а также ему в момент объявления не было присвоено значение, то вывод типов должен был указать тип <code>any</code>. Но в данном случае компилятор указывает тип <code>MouseEvent</code>, потому что именно он указан в декларации типа слушателя событий. В случае подписания <code>document</code> на событие <code>keydown</code>, компилятор указывает тип как <code>KeyboardEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mousedown'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// event: MouseEvent</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// event: KeyboardEvent</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Для того чтобы понять, как это работает, опишем случай из жизни зоопарка — представление с морским львом. Для этого создадим класс морской лев <code>SeaLion</code> и объявим в нем два метода: вращаться (<code>rotate</code>) и голос (<code>voice</code>).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SeaLion</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Далее, создадим класс дрессировщик <code>Trainer</code> и объявим в нем метод <code>addEventListener</code> с двумя параметрами: <code>type</code> с типом <code>string</code> и <code>handler</code> с типом <code>Function</code>. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Затем объявим два класса события, выражающие команды дрессировщика <code>RotateTrainerEvent</code> и <code>VoiceTrainerEvent</code>. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">RotateTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">VoiceTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">После объявим два псевдонима (<code>type</code>) для литеральных типов <code>string</code>. Первому зададим имя <code>RotateEventType</code> и в качестве значения присвоим строковой литерал <code>\"rotate\"</code>. Второму зададим имя <code>VoiceEventType</code> и в качестве  значения присвоим строковой литерал <code>\"voice\"</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"rotate\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"voice\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Теперь осталось только задекларировать ещё два псевдонима типов для функциональных типов у обоих из которых будет один параметр <code>event</code> и отсутствовать возвращаемое значение. Первому псевдониму зададим имя <code>RotateTrainerHandler</code>, а его параметру установим тип  <code>RotateTrainerEvent</code>. Второму псевдониму зададим имя <code>VoiceTrainerHandler</code>, а его параметру установим тип <code>VoiceTrainerEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> RotateTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> VoiceTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Соберём части воедино. Для этого в классе дрессировщик <code>Trainer</code> перегрузим метод <code>addEventListener</code>. У первого перегруженного метода параметр <code>type</code> будет иметь тип <code>RotateEventType</code>, а параметру <code>handler</code> укажем тип <code>RotateTrainerHandler</code>. Второму перегруженному методу в качестве типа параметра <code>type</code> укажем <code>VoiceEventType</code>, а параметру <code>handler</code> укажем тип <code>VoiceTrainerHandler</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> RotateEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> RotateTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> VoiceEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> VoiceTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Осталось только убедиться что все работает правильно. Для этого создадим экземпляр класса <code>Trainer</code> и подпишемся на события. Сразу можно увидеть подтверждение того, что цель достигнута. У слушателя события <code>RotateTrainerEvent</code> параметру <code>event</code> указан контекстный тип <code>RotateTrainerEvent</code>. А слушателю события <code>VoiceTrainerEvent</code> параметру <code>event</code> указан контекстный тип <code>VoiceTrainerEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> RotateTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> VoiceTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"rotate\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"voice\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RotateTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">VoiceTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SeaLion</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> RotateEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> RotateTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> VoiceEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> VoiceTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> seaLion<span class=\"token operator\">:</span> SeaLion <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SeaLion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> trainer<span class=\"token operator\">:</span> Trainer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Trainer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntrainer<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'rotate'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> seaLion<span class=\"token punctuation\">.</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntrainer<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'voice'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> seaLion<span class=\"token punctuation\">.</span><span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>","commitInfoAll":[{"committedDate":"2020-09-24T12:55:59Z","message":"book(изменение основного контента): rethink chapter 041\n\nrethink chapter 041","messageHeadline":"book(изменение основного контента): rethink chapter 041","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/041\\.\\(Типизация\\) Типизация в TypeScript/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"Что такое и для чего нужен TypeScript","sections":[{"name":"Что такое TypeScript","path":"Что такое TypeScript"},{"name":"История TypeScript","path":"История TypeScript"},{"name":"Для чего нужен TypeScript","path":"Для чего нужен TypeScript"},{"name":"Зачем разработчику TypeScript","path":"Зачем разработчику TypeScript"}]},{"name":"Вступление","path":"Вступление","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"Система типов, тип данных, значимые и ссылочные типы","sections":[{"name":"Система Типов","path":"Система Типов"},{"name":"Тип данных (тип)","path":"Тип данных (тип)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"Тип данных, передающийся по значению (примитивный тип)"},{"name":"Тип данных, передающийся по ссылке","path":"Тип данных, передающийся по ссылке"}]},{"name":"Связывание, типизация, вывод типов","path":"Связывание, типизация, вывод типов","sections":[{"name":"Обработка кода компилятором","path":"Обработка кода компилятором"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"Лексический анализ (токенизация - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"Синтаксический анализ (разбор - parsing)"},{"name":"Семантический анализ","path":"Семантический анализ"},{"name":"Связывание (Binding)","path":"Связывание (Binding)"},{"name":"Типизация","path":"Типизация"},{"name":"Вывод Типов (type inference)","path":"Вывод Типов (type inference)"}]},{"name":"Преобразование типов","path":"Преобразование типов","sections":[{"name":"Неявные Преобразования","path":"Неявные Преобразования"},{"name":"Явные Преобразования","path":"Явные Преобразования"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"Типизированные и нетипизированные языки программирования","sections":[{"name":"Нетипизированные языки","path":"Нетипизированные языки"},{"name":"Типизированные языки","path":"Типизированные языки"}]},{"name":"Статическая и динамическая типизация","path":"Статическая и динамическая типизация","sections":[{"name":"Статическая типизация (Static Typing)","path":"Статическая типизация (Static Typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"Динамическая Типизация (Dynamic Typing)"}]},{"name":"Сильная и слабая типизация","path":"Сильная и слабая типизация","sections":[{"name":"Сильная типизация (strongly typed)","path":"Сильная типизация (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"Слабая типизация (weakly typed)"}]},{"name":"Явная и неявная типизация","path":"Явная и неявная типизация","sections":[{"name":"Явная типизация (explicit typing)","path":"Явная типизация (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"Неявная типизация (implicit typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"Совместимость типов на основе вида типизации","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"Совместимость типов (Types Compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"Номинативная Типизация (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"Структурная Типизация (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"Утиная Типизация (Duck typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"Совместимость типов на основе вариантности","sections":[{"name":"Вариантность","path":"Вариантность"},{"name":"Иерархия наследования","path":"Иерархия наследования"},{"name":"Ковариантность","path":"Ковариантность"},{"name":"Контравариантность","path":"Контравариантность"},{"name":"Инвариантность","path":"Инвариантность"},{"name":"Бивариантность","path":"Бивариантность"}]},{"name":"Аннотация Типов","path":"Аннотация Типов","sections":[{"name":"Аннотация Типов - общее","path":"Аннотация Типов - общее"},{"name":"Аннотация типа","path":"Аннотация типа"},{"name":"Синтаксические конструкции var, let, const","path":"Синтаксические конструкции var, let, const"},{"name":"Функции (function)","path":"Функции (function)"},{"name":"Стрелочные Функции (arrow function)","path":"Стрелочные Функции (arrow function)"},{"name":"Классы (class)","path":"Классы (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"Сравнение Синтаксиса TypeScript и JavaScript"},{"name":"Итог","path":"Итог"}]},{"name":"Базовый Тип Any","path":"Базовый Тип Any","sections":[{"name":"Any (any) произвольный тип","path":"Any (any) произвольный тип"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"Примитивные типы Number, String, Boolean, Symbol, BigInt","sections":[{"name":"Важно","path":"Важно"},{"name":"Number (number) примитивный числовой тип","path":"Number (number) примитивный числовой тип"},{"name":"String (string) примитивный строковый тип","path":"String (string) примитивный строковый тип"},{"name":"Boolean (boolean) примитивный логический тип","path":"Boolean (boolean) примитивный логический тип"},{"name":"Symbol (symbol) примитивный символьный тип","path":"Symbol (symbol) примитивный символьный тип"},{"name":"BigInt (bigint) примитивный числовой тип","path":"BigInt (bigint) примитивный числовой тип"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Примитивные типы Null, Undefined, Void, Never, Unknown","sections":[{"name":"Важно","path":"Важно"},{"name":"Null (null) примитивный null тип","path":"Null (null) примитивный null тип"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"Undefined (undefined) примитивный неопределенный тип"},{"name":"Void (void) отсутствие конкретного типа","path":"Void (void) отсутствие конкретного типа"},{"name":"Never (never) примитивный тип","path":"Never (never) примитивный тип"},{"name":"Unknown (unknown)","path":"Unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"Примитивный Тип Enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"Enum (enum) примитивный перечисляемый тип"},{"name":"Перечисления с числовым значением","path":"Перечисления с числовым значением"},{"name":"Перечисления со строковым значением","path":"Перечисления со строковым значением"},{"name":"Смешанное перечисление (mixed enum)","path":"Смешанное перечисление (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"Перечисление в качестве типа данных"},{"name":"Перечисление const с числовым и строковым значением","path":"Перечисление const с числовым и строковым значением"},{"name":"Когда стоит применять enum?","path":"Когда стоит применять enum?"}]},{"name":"Типы - Union, Intersection","path":"Типы - Union, Intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"Тип Объединение (Union Types)"},{"name":"Тип Пересечение (Intersection Type)","path":"Тип Пересечение (Intersection Type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type Queries (запросы типа), Alias (псевдонимы типа)","sections":[{"name":"Запросы Типа (Type Queries)","path":"Запросы Типа (Type Queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"Псевдонимы Типов (Type Aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"Литеральный тип Number (Numeric Literal Types)"},{"name":"Литеральный тип String (String Literal Types)","path":"Литеральный тип String (String Literal Types)"},{"name":"Шаблонный литеральный тип String (Template String Literal Types)","path":"Шаблонный литеральный тип String (Template String Literal Types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"Литеральный Тип Boolean (Boolean Literal Types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"Литеральный тип Enum (Enum Literal Types)"}]},{"name":"Object, Array, Tuple","path":"Object, Array, Tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"Object (object) — ссылочный объектный тип"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"Array (type[]) ссылочный массивоподобный тип"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"Tuple ([T0, T1, …, Tn]) тип кортеж"}]},{"name":"Function, Functional Types","path":"Function, Functional Types","sections":[{"name":"Function Types - тип функция","path":"Function Types - тип функция"},{"name":"Functional Types - функциональный тип","path":"Functional Types - функциональный тип"},{"name":"this в сигнатуре функции","path":"this в сигнатуре функции"}]},{"name":"Interfaces","path":"Interfaces","sections":[{"name":"Общая теория","path":"Общая теория"},{"name":"Интерфейс в TypeScript","path":"Интерфейс в TypeScript"},{"name":"Объявление (declaration)","path":"Объявление (declaration)"},{"name":"Конвенции именования интерфейсов","path":"Конвенции именования интерфейсов"},{"name":"Реализация интерфейса (implements)","path":"Реализация интерфейса (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"Декларация свойств get и set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"Указание интерфейса в качестве типа (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"Расширение интерфейсов (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"Расширение интерфейсом класса (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"Описание класса (функции-конструктора)"},{"name":"Описание функционального выражения","path":"Описание функционального выражения"},{"name":"Описание индексных членов в объектных типов","path":"Описание индексных членов в объектных типов"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"Инлайн интерфейсы (Inline Interface)"},{"name":"Слияние интерфейсов","path":"Слияние интерфейсов"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","sections":[{"name":"Индексные члены (определение динамических ключей)","path":"Индексные члены (определение динамических ключей)"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"Модификаторы доступа (Access Modifiers)","sections":[{"name":"Модификатор доступа public (публичный)","path":"Модификатор доступа public (публичный)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"Модификатор доступа private (закрытый или скрытый)"},{"name":"Модификатор доступа protected (защищенный)","path":"Модификатор доступа protected (защищенный)"},{"name":"Модификаторы доступа и конструкторы класса","path":"Модификаторы доступа и конструкторы класса"},{"name":"Быстрое объявление полей","path":"Быстрое объявление полей"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"Закрытые поля определенные спецификацией ECMAScript","sections":[{"name":"Нативный закрытый (private) модификатор доступа","path":"Нативный закрытый (private) модификатор доступа"}]},{"name":"Абстрактные классы (abstract classes)","path":"Абстрактные классы (abstract classes)","sections":[{"name":"Общие характеристики","path":"Общие характеристики"},{"name":"Теория","path":"Теория"}]},{"name":"Полиморфный тип this","path":"Полиморфный тип this","sections":[{"name":"this - как тип","path":"this - как тип"}]},{"name":"Модификатор readonly (только для чтения)","path":"Модификатор readonly (только для чтения)","sections":[{"name":"Модификатор readonly","path":"Модификатор readonly"}]},{"name":"Definite Assignment Assertion Modifier","path":"Definite Assignment Assertion Modifier","sections":[{"name":"Модификатор утверждения не принадлежности значения к типу undefined","path":"Модификатор утверждения не принадлежности значения к типу undefined"}]},{"name":"Классы — Тонкости","path":"Классы — Тонкости","sections":[{"name":"Классы - Тонкости implements","path":"Классы - Тонкости implements"},{"name":"Частичное слияние интерфейса с классом","path":"Частичное слияние интерфейса с классом"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"Переопределение свойств полями и наоборот при наследовании"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","sections":[{"name":"Нюансы на практике","path":"Нюансы на практике"}]},{"name":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","sections":[{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"Оператор ! (Non-Null and Non-Undefined Operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"Оператор ! (Definite Assignment Assertion)"}]},{"name":"Обобщения (Generics)","path":"Обобщения (Generics)","sections":[{"name":"Обобщения - общие понятия","path":"Обобщения - общие понятия"},{"name":"Обобщения в TypeScript","path":"Обобщения в TypeScript"},{"name":"Параметры типа - extends (generic constraints)","path":"Параметры типа - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"Параметра типа - значение по умолчанию = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"Параметры типа - как тип данных"}]},{"name":"Дискриминантное объединение (Discriminated Union)","path":"Дискриминантное объединение (Discriminated Union)","sections":[{"name":"Дискриминантное объединение","path":"Дискриминантное объединение"}]},{"name":"Импорт и экспорт только типа","path":"Импорт и экспорт только типа","sections":[{"name":"Предыстория возникновения import type и export type","path":"Предыстория возникновения import type и export type"},{"name":"import type и export type - форма объявления","path":"import type и export type - форма объявления"},{"name":"Импорт и экспорт только типа на практике","path":"Импорт и экспорт только типа на практике"},{"name":"Вспомогательный флаг --importsNotUsedAsValues","path":"Вспомогательный флаг --importsNotUsedAsValues"}]},{"name":"Утверждение типов (Type Assertion)","path":"Утверждение типов (Type Assertion)","sections":[{"name":"Утверждение типов - общее","path":"Утверждение типов - общее"},{"name":"Утверждение типа <Type> синтаксис","path":"Утверждение типа <Type> синтаксис"},{"name":"Утверждение типа с помощью оператора as","path":"Утверждение типа с помощью оператора as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"Приведение (утверждение) к константе (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"Утверждение в сигнатуре (Signature Assertion)"}]},{"name":"Защитники типа","path":"Защитники типа","sections":[{"name":"Защитники Типа - общее","path":"Защитники Типа - общее"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"Сужение диапазона множества типов на основе типа данных"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"Сужение диапазона множества типов на основе доступных членов объекта"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"Сужение диапазона множества типов на основе функции, определенной пользователем"}]},{"name":"Вывод типов","path":"Вывод типов","sections":[{"name":"Вывод типов - общие сведения","path":"Вывод типов - общие сведения"},{"name":"Вывод примитивных типов","path":"Вывод примитивных типов"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)"},{"name":"Вывод объектных типов","path":"Вывод объектных типов"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"Вывод типа для полей класса на основе инициализации их в конструкторе"},{"name":"Вывод объединенных (Union) типов","path":"Вывод объединенных (Union) типов"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"Вывод пересечения (Intersection) с дискриминантными полями"},{"name":"Вывод типов кортеж (Tuple)","path":"Вывод типов кортеж (Tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"Совместимость объектных типов (Compatible Object Types)","sections":[{"name":"Важно","path":"Важно"},{"name":"Совместимость объектных типов в TypeScript","path":"Совместимость объектных типов в TypeScript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"Совместимость функциональных типов (Compatible Function Types)","sections":[{"name":"Важно","path":"Важно"},{"name":"Совместимость параметров","path":"Совместимость параметров"},{"name":"Совместимость возвращаемого значения","path":"Совместимость возвращаемого значения"}]},{"name":"Совместимость объединений (Union Types)","path":"Совместимость объединений (Union Types)","sections":[{"name":"Совместимость","path":"Совместимость"}]},{"name":"Типизация в TypeScript","path":"Типизация в TypeScript","sections":[{"name":"Общие сведения","path":"Общие сведения"},{"name":"Статическая типизация (static typing)","path":"Статическая типизация (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"Сильная типизация (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"Явно типизированный (explicit typing) с выводом типов (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)"},{"name":"Вариантность (variance)","path":"Вариантность (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"Наилучший общий тип (Best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"Контекстный тип (Contextual Type)"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","sections":[{"name":"Запрос ключей keyof","path":"Запрос ключей keyof"},{"name":"Поиск типов (Lookup Types)","path":"Поиск типов (Lookup Types)"},{"name":"Сопоставление типов (Mapped Types)","path":"Сопоставление типов (Mapped Types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"Префиксы + и - в сопоставленных типах"}]},{"name":"Условные типы (Conditional Types)","path":"Условные типы (Conditional Types)","sections":[{"name":"Условные типы на практике","path":"Условные типы на практике"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"Распределительные условные типы (Distributive Conditional Types)"},{"name":"Вывод типов в условном типе","path":"Вывод типов в условном типе"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"Readonly, Partial, Required, Pick, Record","sections":[{"name":"Readonly<T> (сделать члены объекта только для чтения)","path":"Readonly<T> (сделать члены объекта только для чтения)"},{"name":"Partial<T> (сделать все члены объекта необязательными)","path":"Partial<T> (сделать все члены объекта необязательными)"},{"name":"Required<T> (сделать все необязательные члены обязательными)","path":"Required<T> (сделать все необязательные члены обязательными)"},{"name":"Pick (отфильтровать объектный тип)","path":"Pick (отфильтровать объектный тип)"},{"name":"Record<K, T> (динамически определить поле в объектном типе)","path":"Record<K, T> (динамически определить поле в объектном типе)"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","sections":[{"name":"Exclude<T, U> (исключает из T признаки присущие U)","path":"Exclude<T, U> (исключает из T признаки присущие U)"},{"name":"Extract<T, U> (общие для двух типов признаки)","path":"Extract<T, U> (общие для двух типов признаки)"},{"name":"NonNullable<T> (удаляет типы null и undefined)","path":"NonNullable<T> (удаляет типы null и undefined)"},{"name":"ReturnType<T> (получить тип значения возвращаемого функцией)","path":"ReturnType<T> (получить тип значения возвращаемого функцией)"},{"name":"InstanceType<T> (получить через тип класса тип его экземпляра)","path":"InstanceType<T> (получить через тип класса тип его экземпляра)"},{"name":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)","path":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)"},{"name":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)","path":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)"},{"name":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)","path":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","sections":[{"name":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)","path":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)"},{"name":"ReadonlyArray<T> (неизменяемый массив)","path":"ReadonlyArray<T> (неизменяемый массив)"},{"name":"ReadonlyMap<K, V> (неизменяемая карта)","path":"ReadonlyMap<K, V> (неизменяемая карта)"},{"name":"ReadonlySet<T> (неизменяемое множество)","path":"ReadonlySet<T> (неизменяемое множество)"}]},{"name":"Синтаксические конструкции и операторы","path":"Синтаксические конструкции и операторы","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"Операнды для delete должны быть необязательными"}]},{"name":"Типизированный React","path":"Типизированный React","sections":[{"name":"Расширение .tsx","path":"Расширение .tsx"}]},{"name":"Функциональные компоненты","path":"Функциональные компоненты","sections":[{"name":"Определение компонента как Function Declaration","path":"Определение компонента как Function Declaration"},{"name":"Определение компонента как Function Expression","path":"Определение компонента как Function Expression"}]},{"name":"Классовые компоненты","path":"Классовые компоненты","sections":[{"name":"Производные от Component<P, S, SS>","path":"Производные от Component<P, S, SS>"},{"name":"Производные от PureComponent<Props, State, Snapshot>","path":"Производные от PureComponent<Props, State, Snapshot>"}]},{"name":"Универсальные компоненты","path":"Универсальные компоненты","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"Обобщенные компоненты (Generics Component)"}]},{"name":"Типизированные хуки","path":"Типизированные хуки","sections":[{"name":"Предопределенные хуки - useState<T>()","path":"Предопределенные хуки - useState<T>()"},{"name":"Предопределенные хуки - useEffect() и useLayoutEffect()","path":"Предопределенные хуки - useEffect() и useLayoutEffect()"},{"name":"Предопределенные хуки - useContext<T>()","path":"Предопределенные хуки - useContext<T>()"},{"name":"Предопределенные хуки - useReducer<R>()","path":"Предопределенные хуки - useReducer<R>()"},{"name":"Предопределенные хуки - useCallback<T>()","path":"Предопределенные хуки - useCallback<T>()"},{"name":"Предопределенные хуки - useRef<T>()","path":"Предопределенные хуки - useRef<T>()"},{"name":"Предопределенные хуки - useImperativeHandle<T, R>()","path":"Предопределенные хуки - useImperativeHandle<T, R>()"},{"name":"Предопределенные хуки - useMemo<T>()","path":"Предопределенные хуки - useMemo<T>()"},{"name":"Предопределенные хуки - useDebugValue<T>()","path":"Предопределенные хуки - useDebugValue<T>()"},{"name":"Пользовательский хук","path":"Пользовательский хук"}]},{"name":"Контекст (Context)","path":"Контекст (Context)","sections":[{"name":"Определение контекста","path":"Определение контекста"}]},{"name":"HOC (Higher-Order Components)","path":"HOC (Higher-Order Components)","sections":[{"name":"Определение hoc","path":"Определение hoc"},{"name":"Определение hoc на основе функционального компонента","path":"Определение hoc на основе функционального компонента"},{"name":"Определение hoc на основе классового компонента","path":"Определение hoc на основе классового компонента"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"Пространства имен (namespace) и модули (module)","sections":[{"name":"Namespace и module — предназначение","path":"Namespace и module — предназначение"},{"name":"Namespace - определение","path":"Namespace - определение"},{"name":"Модули (export, import) — определение","path":"Модули (export, import) — определение"},{"name":"Конфигурирование проекта","path":"Конфигурирование проекта"}]},{"name":"Настройка рабочего окружения","path":"Настройка рабочего окружения","sections":[{"name":"Настройка рабочего окружения","path":"Настройка рабочего окружения"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"Сборка проекта с помощью tsc (TypeScript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"Сборка с использованием ссылок на проекты","sections":[{"name":"Ссылки на проекты","path":"Ссылки на проекты"}]},{"name":"Декларации","path":"Декларации","sections":[{"name":"Что такое декларация (Declaration)","path":"Что такое декларация (Declaration)"},{"name":"Установка деклараций с помощью @types","path":"Установка деклараций с помощью @types"},{"name":"Подготовка к созданию декларации","path":"Подготовка к созданию декларации"},{"name":"Разновидности деклараций","path":"Разновидности деклараций"},{"name":"Декларации и область видимости","path":"Декларации и область видимости"},{"name":"Декларации для библиотек с одной точкой входа","path":"Декларации для библиотек с одной точкой входа"},{"name":"Декларации для библиотек с множеством точек входа","path":"Декларации для библиотек с множеством точек входа"},{"name":"Создание деклараций вручную","path":"Создание деклараций вручную"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"Директива с тройным слешем (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"Импортирование декларации (import)"}]},{"name":"Публикация TypeScript","path":"Публикация TypeScript","sections":[{"name":"Публикация","path":"Публикация"}]},{"name":"Опции компилятора","path":"Опции компилятора","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressExcessPropertyErrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressImplicitAnyIndexErrors"},{"name":"noImplicitAny","path":"noImplicitAny"},{"name":"checkJs","path":"checkJs"},{"name":"JSX","path":"JSX"},{"name":"jsxFactory","path":"jsxFactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysStrict"},{"name":"strictNullChecks","path":"strictNullChecks"},{"name":"stripInternal","path":"stripInternal"},{"name":"noImplicitThis","path":"noImplicitThis"},{"name":"noImplicitUseStrict","path":"noImplicitUseStrict"},{"name":"baseUrl","path":"baseUrl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootDir"},{"name":"rootDirs","path":"rootDirs"},{"name":"traceResolution","path":"traceResolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"noLib"},{"name":"noResolve","path":"noResolve"},{"name":"noStrictGenericChecks","path":"noStrictGenericChecks"},{"name":"preserveConstEnums","path":"preserveConstEnums"},{"name":"removeComments","path":"removeComments"},{"name":"noUnusedLocals","path":"noUnusedLocals"},{"name":"noUnusedParameters","path":"noUnusedParameters"},{"name":"skipLibCheck","path":"skipLibCheck"},{"name":"declarationDir","path":"declarationDir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeRoots"},{"name":"allowUnusedLabels","path":"allowUnusedLabels"},{"name":"noImplicitReturns","path":"noImplicitReturns"},{"name":"noFallthroughCasesInSwitch","path":"noFallthroughCasesInSwitch"},{"name":"outFile","path":"outFile"},{"name":"allowSyntheticDefaultImports","path":"allowSyntheticDefaultImports"},{"name":"allowUnreachableCode","path":"allowUnreachableCode"},{"name":"allowJs","path":"allowJs"},{"name":"reactNamespace","path":"reactNamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleResolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noEmitHelpers"},{"name":"newLine","path":"newLine"},{"name":"inlineSourceMap","path":"inlineSourceMap"},{"name":"inlineSources","path":"inlineSources"},{"name":"noEmitOnError","path":"noEmitOnError"},{"name":"noEmit","path":"noEmit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downlevelIteration"},{"name":"emitBOM","path":"emitBOM"},{"name":"emitDecoratorMetadata","path":"emitDecoratorMetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceConsistentCasingInFileNames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importHelpers"},{"name":"isolatedModules","path":"isolatedModules"},{"name":"listEmittedFiles","path":"listEmittedFiles"},{"name":"listFiles","path":"listFiles"},{"name":"sourceRoot","path":"sourceRoot"},{"name":"mapRoot","path":"mapRoot"},{"name":"maxNodeModuleJsDepth","path":"maxNodeModuleJsDepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preserveSymlinks"},{"name":"strictFunctionTypes","path":"strictFunctionTypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctPropertyInitialization"},{"name":"esModuleInterop","path":"esModuleInterop"},{"name":"emitDeclarationsOnly","path":"emitDeclarationsOnly"},{"name":"resolveJsonModule","path":"resolveJsonModule"},{"name":"declarationMap","path":"declarationMap"},{"name":"strictBindCallApply","path":"strictBindCallApply"},{"name":"showConfig","path":"showConfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsBuildInfoFile"},{"name":"allowUmdGlobalAccess","path":"allowUmdGlobalAccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disableSourceOfProjectReferenceRedirect"},{"name":"useDefineForClassFields","path":"useDefineForClassFields"},{"name":"importsNotUsedAsValues","path":"importsNotUsedAsValues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumeChangesOnlyAffectDirectDependencies"},{"name":"watchFile","path":"watchFile"},{"name":"watchDirectory","path":"watchDirectory"},{"name":"fallbackPolling","path":"fallbackPolling"},{"name":"synchronousWatchDirectory","path":"synchronousWatchDirectory"}]}]}},"staticQueryHashes":["408059355","63159454"]}