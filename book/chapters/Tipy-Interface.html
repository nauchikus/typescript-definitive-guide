<section id="Tipy-Interfaces" name="Типы - Interfaces" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipy-Interfaces" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типы - Interfaces
            </h2>
        
<hr>
<p><em>TypeScript</em> предлагает новый тип данных, определяемый с помощью синтаксической конструкции под названием <em>интерфейс</em> (<code class="inline-code">interface</code>). </p>
<p>Interface - это синтаксическая конструкция, определяющая характеристики объектов. Другими словами, интерфейс, - это тип, который содержит описание состояния и поведения объекта без реализации. Класс, реализующий интерфейс, обязан реализовать все его члены. Поэтому, интерфейс является гарантией наличия у объекта, реализующего его, описанных в нем характеристик. Все члены, описанные в интерфейсе, неявно имеют модификатор доступа <code class="inline-code">public</code>. Интерфейс предназначен для описания открытого api объекта. То есть, с его помощью декларируют те члены, которые объект предоставляет программе.</p>
<p>Кроме того, интерфейсы являются фундаментальной составляющей идеологии как типизированных языков, так и объектно-ориентированного программирования.</p>
<p>Такая известная группа программистов, как <em>“Банда четырех”</em> (Gang of Four, сокращённо GoF), в своей книге, положившей начало популяризации шаблонов проектирования, описывали интерфейс, как ключевую концепцию объектно-ориентированного программирования. Понятие интерфейса является настолько важным, что в книге был сформулирован принцип объектно-ориентированного проектирования, который звучит, как - <em>Программируйте в соответствии с интерфейсом, а не с реализацией.</em></p>
<p>Другими словами, авторы советуют создавать систему, которой вообще ничего не будет известно, о реализации. Проще говоря, создаваемая система должна быть построена на типах, определяемых интерфейсами, а не на типах, определяемых классами.</p>
</section><section id="Obyavlenie-declaration" name="Объявление (declaration)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Obyavlenie-declaration" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Объявление (declaration)
            </h2>
        
<hr>
<p>В <em>TypeScript</em> интерфейс объявляется с помощью ключевого слова <code class="inline-code">interface</code>, после которого идет идентификатор, после которого начинается тело интерфейса, заключенное в фигурные скобки. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier {
    <span class="hljs-comment">// тело интерфейса </span>
}</code></pre>
<p>Объявление интерфейса возможно как в контексте модуля, так и в контексте функции или метода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier { } <span class="hljs-comment">//  контекст модуля</span>

<span class="hljs-keyword">class</span> T {
   <span class="hljs-keyword">public</span> method(): <span class="hljs-built_in">void</span> {
       <span class="hljs-keyword">interface</span> Identifier { } <span class="hljs-comment">//  контекст метода</span>
   }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
   <span class="hljs-keyword">interface</span> Identifier { } <span class="hljs-comment">//  контекст функции</span>
}</code></pre>
</section><section id="Konvencii-imenovaniya-interfeisov" name="Конвенции именования интерфейсов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Konvencii-imenovaniya-interfeisov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Конвенции именования интерфейсов
            </h2>
        
<hr>
<p>Прежде чем продолжить дальше, нужно обратить внимание на такой аспект, как конвенции именования интерфейсов. Существует два вида именования. </p>
<p>Первый вид конвенций родом из <em>java</em>, они предлагают именовать интерфейсы, точно так же, как и классы. Допускаются имена прилагательные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier { }</code></pre>
<p>Второй вид, предлагает использовать конвенции такого языка, как <em>c#</em>, по которым, интерфейсы именуются так же как классы, но с префиксом <code class="inline-code">I</code>, что в сокращении означает <em>Interface</em>. Такой вид записи получил название “венгерская нотация” в честь программиста венгерского происхождения работавшего в компании <em>MicroSoft</em>. Допускаются имена прилагательные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifier { }</code></pre>
<p>Чтобы сразу расставить все точки над i, стоит заметить, что в дальнейшем идентификаторы интерфейсов будут указываться по конвенциям <code class="inline-code">c#</code>.</p>
</section><section id="Realizaciya-interfeisa-implements" name="Реализация интерфейса (implements)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Realizaciya-interfeisa-implements" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Реализация интерфейса (implements)
            </h2>
        
<hr>
<p>Как уже было сказано в самом начале, все члены интерфейса являются открытыми (<code class="inline-code">public</code>) и не могут быть объявлены с модификатором <code class="inline-code">static</code>. Кроме того, в <em>TypeScript</em> интерфейсы не могут содержать реализацию.</p>
<p>Класс, реализующий интерфейс, обязан реализовывать его в полной мере. Любой класс, который хочет реализовать интерфейс, должен указать это с помощью ключевого слова <code class="inline-code">implements</code>, после которого следует идентификатор реализуемого интерфейса. Указание реализации классом интерфейса располагается между идентификатором класса и его телом. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
 nickname: <span class="hljs-built_in">string</span>;

 execute( command: <span class="hljs-built_in">string</span> ): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
 nickname: <span class="hljs-built_in">string</span>;

 execute( command: <span class="hljs-built_in">string</span> ): <span class="hljs-built_in">void</span> {}
}</code></pre>
<p>Один класс может реализовывать сколько угодно интерфейсов. В этом случае реализуемые интерфейсы должны быть перечислены через запятую.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal { }
<span class="hljs-keyword">interface</span> IOviparous { } <span class="hljs-comment">// указывает на возможность откладывать яйца</span>

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal, IOviparous { } </code></pre>
<p>В случае, когда класс расширяет другой класс, декларация реализации (<code class="inline-code">implements</code>) следует после декларации расширения (<code class="inline-code">extends</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal { }
<span class="hljs-keyword">interface</span> IOviparous { } 


<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal, IOviparous { } 

<span class="hljs-keyword">interface</span> IFlyable { }

<span class="hljs-keyword">class</span> Eagle <span class="hljs-keyword">extends</span> Bird <span class="hljs-keyword">implements</span> IFlyable {}</code></pre>
</section><section id="Deklaraciya-aksessorov-get-set-accessors" name="Декларация аксессоров get\set (accessors)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Deklaraciya-aksessorov-get-set-accessors" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Декларация аксессоров get\set (accessors)
            </h2>
        
<hr>
<p>Несмотря на то, что в интерфейсе можно декларировать поля и методы, в нем нельзя декларировать аксессоры (<code class="inline-code">get</code> \ <code class="inline-code">set</code>). Но несмотря на это, поле задекларированное в интерфейсе может быть совместимо не только с полем, но и аксессорами. При этом нет разницы, будет в объекте объявлен <em>getter</em>, <em>setter</em> или оба одновременно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
 id: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// только get</span>
<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
   <span class="hljs-keyword">get</span> id(): <span class="hljs-built_in">string</span> {
       <span class="hljs-keyword">return</span> <span class="hljs-string">'bird'</span>;
   }
}

<span class="hljs-comment">// только set</span>
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal {
   <span class="hljs-keyword">set</span> id(value: <span class="hljs-built_in">string</span>) { }
}

<span class="hljs-comment">// и get и set</span>
<span class="hljs-keyword">class</span> Insect <span class="hljs-keyword">implements</span> IAnimal {
 <span class="hljs-keyword">get</span> id(): <span class="hljs-built_in">string</span> {
     <span class="hljs-keyword">return</span> <span class="hljs-string">'insect'</span>;
 }

 <span class="hljs-keyword">set</span> id( value: <span class="hljs-built_in">string</span> ){}
}</code></pre>
</section><section id="Ukazanie-interfeisa-v-kachestve-tipa-interface-types" name="Указание интерфейса в качестве типа (interface types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Ukazanie-interfeisa-v-kachestve-tipa-interface-types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Указание интерфейса в качестве типа (interface types)
            </h2>
        
<hr>
<p>Класс, реализующий интерфейс, принадлежит к типу этого интерфейса. Класс, унаследованный от класса, реализующего интерфейс, также принадлежит к типу интерфейса. В таких случаях говорят, что класс наследует интерфейс.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {}

<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird();
<span class="hljs-keyword">let</span> raven: IAnimal = <span class="hljs-keyword">new</span> Raven();</code></pre>
<p>Класс, реализующий множество интерфейсов, принадлежит к типу каждого из них. Когда экземпляру класса (который сам по себе является типом), реализующего интерфейс, присваивают ссылки с типом интерфейса, то говорят, что ссылку ограничивают типом интерфейса. То есть, функционал экземпляра класса урезается до описанного в интерфейсе (подробнее об этом речь пойдет в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-obektov" title="Типизация - Совместимость объектов" target="_blank">Типизация - Совместимость объектов</a> и <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-funkcii" title="Типизация - Совместимость функций" target="_blank">Типизация - Совместимость функций</a>). </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
   name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IFlyable{
   flightHeight: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IIdentifiable{
   id: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
   <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name: <span class="hljs-built_in">string</span></span>){}
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal <span class="hljs-keyword">implements</span> IFlyable  {
   <span class="hljs-keyword">public</span> flightHeight: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;
}

<span class="hljs-keyword">var</span> animal: IAnimal = <span class="hljs-keyword">new</span> Bird( <span class="hljs-string">'bird'</span> ); <span class="hljs-comment">// принадлежит к типу IAnimal</span>
<span class="hljs-keyword">var</span> fly: IFlyable = <span class="hljs-keyword">new</span> Bird( <span class="hljs-string">'bird'</span> ); <span class="hljs-comment">// принадлежит к типу IFlyable</span></code></pre>
<p>Несмотря на то, что интерфейс является синтаксической конструкцией и может указываться в качестве типа, после компиляции от него не остается и следа. Это в свою очередь означает, что интерфейс, как тип данных, может использоваться только на этапе компиляции. Другими словами, компилятор сможет предупредить об ошибках несоответствия объекта описанному интерфейсу, но проверить на принадлежность к типу интерфейса, с помощью таких операторов, как <code class="inline-code">typeof</code> или <code class="inline-code">instanceof</code>,  во время выполнения не получится. Но в <em>TypeScript</em> существует механизм (который будет рассмотрен далее в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Zashchitniki-tipa" title="Типизация - Защитники типа" target="_blank">Типизация - Защитники типа</a> ) позволяющий в некоторой мере решить эту проблему.</p>
</section><section id="Rasshirenie-interfeisov-extends-interface" name="Расширение интерфейсов (extends interface)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-interfeisov-extends-interface" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширение интерфейсов (extends interface)
            </h2>
        
<hr>
<p>Если множество логически связанных интерфейсов требуется объединить в один тип, то нужно воспользоваться механизмом расширения интерфейсов (<code class="inline-code">extends</code>).
Наследование интерфейсов осуществляется с помощью ключевого слова <code class="inline-code">extends</code>, после которого идет один или несколько (через запятую) идентификаторов расширяемых интерфейсов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifiable { }
<span class="hljs-keyword">interface</span> ILiving { }

<span class="hljs-comment">// интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, которую можно выделить в тип интерфейс IAnimal</span>


<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> IIdentifiable, ILiving { }</code></pre>
<p>Для тех, кто только знакомится с таким понятием, как интерфейсы, будет не лишним узнать о таком принципе, как <em>“Принцип разделения интерфейсов”</em> (Interface Segregation Principle или сокращенно ISP). Этот принцип гласит, что более крупные интерфейсы нужно “дробить” на более мелкие интерфейсы. </p>
<p>Но нужно понимать, что условия дробления диктуются конкретным приложением. Если во всех случаях руководствоваться только  правилами, то можно раздуть небольшое приложение до масштабов вселенной.</p>
<p>Для примера представьте приложение, которое только выводит в консоль информацию о животных. Так как над объектом <code class="inline-code">Animal</code> будет выполняться только одна операция, то можно не бояться разгневать богов объектно-ориентированного проектирования и включить все нужные характеристики прямо в интерфейс <code class="inline-code">IAnimal</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
 id: <span class="hljs-built_in">string</span>;
 age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
 <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

 <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly id: <span class="hljs-built_in">string</span></span>) { }
}

<span class="hljs-keyword">class</span> AnimalUtil {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> print(animal: IAnimal): <span class="hljs-built_in">void</span> {
   <span class="hljs-built_in">console</span>.log( animal );
 }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal { }
<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {
 <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">super</span>(<span class="hljs-string">'raven'</span>);
 }
}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.print(raven);</code></pre>
<p>В такой программе, кроме интересов архитектора, ничего пострадать не может, так как она выполняет только одну операцию вывода информации о животном.</p>
<p>Но если переписать программу, чтобы она выполняла несколько, не связанных логически операций над одним типом, в данном случае <code class="inline-code">IAnimal</code>, то ситуация изменится на противоположную.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> AnimalUtil {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IAnimal): <span class="hljs-built_in">void</span> {
   <span class="hljs-built_in">console</span>.log( animal.id ); <span class="hljs-comment">// вывод  id</span>
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: IAnimal): <span class="hljs-built_in">void</span> {
   <span class="hljs-built_in">console</span>.log( animal.age ); <span class="hljs-comment">// вывод age</span>
 }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal { }
<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.printId(raven);
AnimalUtil.printAge(raven);</code></pre>
<p>В этом случае программа нарушает принцип <em>ISP</em>, так как статические методы <code class="inline-code">printId</code> и <code class="inline-code">printAge</code> получили доступ к данным, которые им не требуются для успешного выполнения. Это может привести к намеренной или по неосторожности порче данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> AnimalUtil {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IAnimal): <span class="hljs-built_in">void</span> {
   <span class="hljs-comment">// для успешного выполнения этого метода </span>
   <span class="hljs-comment">// не требуется доступ к данным о animal.age</span>

   <span class="hljs-built_in">console</span>.log( animal.id );
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: IAnimal): <span class="hljs-built_in">void</span> {
   <span class="hljs-comment">// для успешного выполнения этого метода </span>
   <span class="hljs-comment">// не требуется доступ к данным о animal.id</span>

   <span class="hljs-built_in">console</span>.log( animal.age );
 }
}</code></pre>
<p>Поэтому в подобных ситуациях, настоятельно рекомендуется “дробить” типы интерфейсов на меньшие составляющие, а затем с их помощью ограничивать доступ к данным в тех местах, где это требуется правилами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIdentifiable { }
<span class="hljs-keyword">interface</span> ILiving { }

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> IIdentifiable, ILiving {<span class="hljs-comment">/*...*/</span> }

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">class</span> AnimalUtil {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printId(animal: IIdentifiable): <span class="hljs-built_in">void</span> {
   <span class="hljs-comment">// параметр animal ограничен типом IIdentifiable</span>

   <span class="hljs-built_in">console</span>.log( animal.id );
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> printAge(animal: ILiving): <span class="hljs-built_in">void</span> {
   <span class="hljs-comment">// параметр animal ограничен типом ILiving</span>

   <span class="hljs-built_in">console</span>.log( animal.age );
 }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal { }
<span class="hljs-keyword">class</span> Raven <span class="hljs-keyword">extends</span> Bird {<span class="hljs-comment">/*...*/</span>}

<span class="hljs-keyword">let</span> raven: Raven = <span class="hljs-keyword">new</span> Raven();

AnimalUtil.printId(raven);
AnimalUtil.printAge(raven);</code></pre>
</section><section id="Rasshirenie-interfeisom-klassa-extends-class" name="Расширение интерфейсом класса (extends class)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirenie-interfeisom-klassa-extends-class" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширение интерфейсом класса (extends class)
            </h2>
        
<hr>
<p>В случаях, когда нужно создать интерфейс для уже имеющегося класса, больше не нужно тратить силы на перечисление членов класса в интерфейсе. В <em>TypeScript</em> интерфейсу достаточно расширить класс.</p>
<p>Когда интерфейс расширяет класс, он наследует описание членов, но не их реализацию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
  nickname: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
  nickname:<span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird();</code></pre>
<p>Но с расширением класса интерфейсом существует один нюанс.</p>
<p>Наравне с публичными (<code class="inline-code">public</code>), интерфейс также наследует закрытые (<code class="inline-code">private</code>) и защищенные (<code class="inline-code">protected</code>) члены класса. Подобный интерфейс может быть реализован только самим классам или его потомками.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
 <span class="hljs-keyword">private</span> uid: <span class="hljs-built_in">string</span>;
 <span class="hljs-keyword">protected</span> maxAge: <span class="hljs-built_in">number</span>;
 <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IAnimal <span class="hljs-keyword">extends</span> Animal {}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal <span class="hljs-keyword">implements</span> IAnimal { <span class="hljs-comment">// Ok</span>
 <span class="hljs-comment">// private uid: string = ''; // Error, private</span>
 <span class="hljs-keyword">protected</span> maxAge: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// Ok, protected</span>
 <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>; <span class="hljs-comment">// Ok,  public</span>
}

<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal { <span class="hljs-comment">// Error</span>
 <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'fish'</span>;
}

<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird(); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> fish: IAnimal = <span class="hljs-keyword">new</span> Fish(); <span class="hljs-comment">// Error</span></code></pre>
</section><section id="Opisanie-klassa-funkcii-konstruktora" name="Описание класса (функции-конструктора)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-klassa-funkcii-konstruktora" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание класса (функции-конструктора)
            </h2>
        
<hr>
<p>Известный факт, что в <em>JavaScript</em>, а следовательно и в TypeScript, конструкция <code class="inline-code">class</code> - это всего навсего <em>“синтаксический сахар”</em> над старой доброй функцией-конструктором. Эта особенность позволяет описывать интерфейсы не только для экземпляров класса, но и для самих классов (функций-конструкторов). Другими словами, в интерфейсе можно описать конструктор, а также статические члены класса, с одной оговоркой. Этот интерфейс можно использовать только в качестве типа. То есть класс не может указывать реализацию такого интерфейса с помощью ключевого слова <code class="inline-code">implements</code>.</p>
<p>Описывать интерфейс для функции конструктора может потребоваться тогда, когда в качестве значения выступает сам класс.</p>
<p>Конструктор указывается с помощью ключевого слова new, после которого указываются фигурные скобки в которых, при наличии, указываются параметры, после которых следует указания возвращаемого типа <code class="inline-code">new(p1: type, p2: type): type;</code>.</p>
<p>Статические члены описываются также, как и обычные.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  nickname: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> Animal <span class="hljs-keyword">implements</span> IAnimal {
  nickname: <span class="hljs-built_in">string</span>;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"> nickname: <span class="hljs-built_in">string</span> </span>){
      <span class="hljs-keyword">this</span>.nickname = nickname;
  }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Animal {
  <span class="hljs-keyword">static</span> DEFAULT_NAME: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>;
  <span class="hljs-keyword">static</span> create(): IAnimal {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bird( Bird.DEFAULT_NAME );
  }
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">extends</span> Animal {
  <span class="hljs-keyword">static</span> DEFAULT_NAME: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bird'</span>;
  <span class="hljs-keyword">static</span> create(): IAnimal {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bird( Bird.DEFAULT_NAME );
  }
}


<span class="hljs-keyword">let</span> a: IAnimal[] = [ <span class="hljs-keyword">new</span> Bird( <span class="hljs-string">'bird'</span> ), <span class="hljs-keyword">new</span> Fish( <span class="hljs-string">'fish'</span> ) ]; <span class="hljs-comment">// Ok, массив экземпляров классов реализующих интерфейс IAnimal</span>
<span class="hljs-keyword">let</span> b: IAnimal[] = [Bird, Fish]; <span class="hljs-comment">// Error, массив классов</span>


<span class="hljs-keyword">interface</span> IAnimalConstructor { <span class="hljs-comment">// декларация интерфейса для класса</span>
  create(): IAnimal; <span class="hljs-comment">// static method</span>
  <span class="hljs-keyword">new</span> ( nickname: <span class="hljs-built_in">string</span> ): IAnimal; <span class="hljs-comment">// constructor</span>
}


<span class="hljs-keyword">let</span> c: IAnimalConstructor[] = [Bird, Fish]; <span class="hljs-comment">// Ok, массив классов</span>
<span class="hljs-keyword">let</span> d: IAnimal[ ] = c.map( <span class="hljs-function"><span class="hljs-params">item</span> =></span> item.create() ); <span class="hljs-comment">// Ok, экземпляры классов реализующих интерфейс IAnimal</span></code></pre>
</section><section id="Opisanie-funkcionalnogo-vyrajeniya" name="Описание функционального выражения" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-funkcionalnogo-vyrajeniya" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание функционального выражения
            </h2>
        
<hr>
<p>Помимо экземпляров и самих классов, интерфейсы можно описывать для функциональных выражений. Это очень удобно, когда функциональный тип имеет очень большую сигнатуру, которая делает код менее читабельным. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;</span>
<span class="hljs-keyword">var</span> callback: <span class="hljs-function">(<span class="hljs-params"> previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[ ] </span>) =></span> <span class="hljs-built_in">number</span>;</code></pre>
<p>В большинство подобных случаев, можно прибегнуть к помощи вывода типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;</span>

<span class="hljs-keyword">var</span> callback: <span class="hljs-function">(<span class="hljs-params"> previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[ ] </span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">var</span> callback = <span class="hljs-function">(<span class="hljs-params"> previusValue: <span class="hljs-built_in">number</span>, currentValue: <span class="hljs-built_in">number</span>, currentIndex: <span class="hljs-built_in">number</span>, array: <span class="hljs-built_in">number</span>[ ] </span>) =></span> previusValue + currentValue;

<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[ ] = [ <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span> ];

<span class="hljs-keyword">let</span> sum: <span class="hljs-built_in">number</span> = numberAll.reduce( callback ); <span class="hljs-comment">// 50</span></code></pre>
<p>Но в случае, если функциональное выражение является параметром функции, как например метод массива <code class="inline-code">reduce</code>, то решением может служить только явная декларация типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Collection&#x3C;T> {
  reduce(callbackfn: <span class="hljs-function">(<span class="hljs-params">previousValue: T, currentValue: T, currentIndex: <span class="hljs-built_in">number</span>, array: T[]</span>) =></span> T, initialValue?: T): T {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}</code></pre>
<p>Поэтому тогда, когда необходимо указать тип явно, помимо рассмотренного в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Type-Queries-zaprosy-tipa-Alias-psevdonimy-tipa" title="Типы - Type Queries (запросы типа), Alias (псевдонимы типа)" target="_blank">Типы - Type Queries (запросы типа), Alias (псевдонимы типа)</a> механизма создания псевдонимов типа (<code class="inline-code">type</code>), можно описать функциональное выражение с помощью интерфейса.</p>
<p>Для этого, в теле интерфейса декларируется сигнатура функции без указания идентификатора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> ISumAll {
 ( ...valueAll: <span class="hljs-built_in">number</span>[ ] ): <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> sumAll: ISumAll = <span class="hljs-function">(<span class="hljs-params"> ...valueAll: <span class="hljs-built_in">number</span>[ ] </span>) =></span> valueAll
 .reduce( <span class="hljs-function">(<span class="hljs-params"> result, value </span>) =></span> result += value, <span class="hljs-number">0</span> );


<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[ ] = [ <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span> ];

<span class="hljs-keyword">let</span> sum: <span class="hljs-built_in">number</span> = sumAll( ...numberAll );</code></pre>
</section><section id="Opisanie-indeksnyh-chlenov-v-obektnyh-tipov" name="Описание индексных членов в объектных типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Opisanie-indeksnyh-chlenov-v-obektnyh-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Описание индексных членов в объектных типов
            </h2>
        
<hr>
<p>Индексные члены подробно будут рассматриваться в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obektnye-tipy-s-indeksnymi-chlenami-obektnyi-tip-s-dinamicheskimi-kluchami" title="Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)" target="_blank">Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)</a>, но не будет лишним и здесь просто указать способ их декларации в типе интерфейсе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIndentifier  {
  [ BindingIdentifier: <span class="hljs-built_in">string</span> ]: Type;
  [ BindingIdentifier: <span class="hljs-built_in">number</span> ]: Type;
}</code></pre>
</section><section id="Inlain-interfeisy-Inline-Interface" name="Инлайн интерфейсы (Inline Interface)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Inlain-interfeisy-Inline-Interface" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Инлайн интерфейсы (Inline Interface)
            </h2>
        
<hr>
<p>Помимо описания объекта, в конструкции объявляемой с помощью ключевого слова <code class="inline-code">interface</code>, тип объекта можно описать прямо в месте указания типа. Такой способ объявления типа данных, неформально называют <em>инлайн интерфейс</em> (inline interface). Всё ранее описанное для типов определяемых интерфейсами, полностью верно для типов определяемых инлайн интерфейсами.</p>
<p>Различие между обычным интерфейсом и инлайн интерфейсом в том, что второй имеет только тело и объявляется прямо в аннотации типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> identifier: { p1: <span class="hljs-keyword">type</span>, p2: <span class="hljs-keyword">type</span> };</code></pre>
<p>Интерфейс, объявленный с помощью  ключевого слова <code class="inline-code">interface</code> считается идентичным инлайн интерфейсу, если их описание совпадает. Но стоит обратить внимание, что это возможно благодаря структурной типизации, которая рассматривается в главе <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-vida-tipizacii" title="Экскурс в типизацию - Совместимость типов на основе вида типизации" target="_blank">Экскурс в типизацию - Совместимость типов на основе вида типизации</a>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  nickname: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">implements</span> IAnimal {
  nickname: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">class</span> Fish <span class="hljs-keyword">implements</span> IAnimal {
  nickname: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">let</span> bird: IAnimal = <span class="hljs-keyword">new</span> Bird(); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> fish: {nickname:<span class="hljs-built_in">string</span>} = <span class="hljs-keyword">new</span> Fish(); <span class="hljs-comment">// Ok</span></code></pre>
<p>Как было сказано ранее, инлайн интерфейс можно объявлять в тех местах, в которых допускается указание типа. Тем не менее реализовывать (<code class="inline-code">implements</code>) и расширять (<code class="inline-code">extends</code>) инлайн интерфейс нельзя. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IT1{}
<span class="hljs-keyword">interface</span> IT2{}

<span class="hljs-keyword">interface</span> IT3 <span class="hljs-keyword">extends</span> { f1: IT1, f2: IT2 } { <span class="hljs-comment">// Error</span>

}

<span class="hljs-keyword">class</span> T4 <span class="hljs-keyword">implements</span> { f1: T1, f2: T2 } { <span class="hljs-comment">// Error</span>

}</code></pre>
<p>Хотя последнее утверждение и не совсем верно. В дальнейшем будет рассказано о такой замечательной конструкции, как обобщения (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obobshcheniya-Generics" title="Типы - Обобщения (Generics)" target="_blank">Типы - Обобщения (Generics)</a>), в которых, как раз таки возможно расширять (<code class="inline-code">extends</code>) инлайн интерфейсы.</p>
</section><section id="Sliyanie-interfeisov" name="Слияние интерфейсов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sliyanie-interfeisov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Слияние интерфейсов
            </h2>
        
<hr>
<p>В случае, если в одной области видимости объявлено несколько одноименных интерфейсов, то они будут объединены в один.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// так видят разработчики</span>
<span class="hljs-keyword">interface</span> IAnimal {
  name: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> IAnimal {
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">//так видит компилятор</span>
<span class="hljs-comment">/**
interface IAnimal {
  name: string;
  age: number;
}
*/</span>

<span class="hljs-comment">// разработчики получают то, что видит компилятор</span>
<span class="hljs-keyword">let</span> animal: IAnimal;
animal.name = <span class="hljs-string">'animal'</span>; <span class="hljs-comment">// Ok</span>
animal.age = <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok</span></code></pre>
<p>При попытке переопределить тип поля, возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> IAnimal {
  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>
  age: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Если в нескольких одноименных интерфейсах будут описаны одноименные методы с разными сигнатурами, то они будут расценены, как описание перегрузки. К тому же интерфейсы, которые описывают множество одноименных методов, сохраняют свой внутренний порядок.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IBird {}
<span class="hljs-keyword">interface</span> IFish {}
<span class="hljs-keyword">interface</span> IInsect {}
<span class="hljs-keyword">interface</span> IReptile {}

<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
  getAnimalByID(id: <span class="hljs-built_in">number</span>): IBird;
}
<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
  getAnimalByID(id: <span class="hljs-built_in">string</span>): IFish;
}
<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
  getAnimalByID(id: <span class="hljs-built_in">boolean</span>): IInsect;
  getAnimalByID(id: object): IReptile;
}

<span class="hljs-comment">/**
interface IAnimalFactory { // after
  getAnimalByID(id: string): IInsect;
  getAnimalByID(id: string): IReptile;
  getAnimalByID(id: string): IFish;
  getAnimalByID(id: string): IBird;
}
*/</span>
<span class="hljs-keyword">let</span> animal: IAnimalFactory;
<span class="hljs-keyword">let</span> v1 = animal.getAnimalByID( <span class="hljs-number">0</span> ); <span class="hljs-comment">// Ok -> v1: IBird</span>
<span class="hljs-keyword">let</span> v2 = animal.getAnimalByID( <span class="hljs-string">'5'</span> ); <span class="hljs-comment">// Ok -> v2: IFish</span>
<span class="hljs-keyword">let</span> v3 = animal.getAnimalByID( <span class="hljs-literal">true</span> ); <span class="hljs-comment">// Ok -> v3: IInsect</span>
<span class="hljs-keyword">let</span> v4 = animal.getAnimalByID( {} ); <span class="hljs-comment">// Ok -> v4: IReptile</span></code></pre>
<p>Исключением из этого правила являются сигнатуры, которые имеют в своем описании литеральные строковые типы данных (<code class="inline-code">literal String Types</code>). Дело в том, что сигнатуры содержащие в своем описании литеральные строковые типы, всегда размещаются перед сигнатурами, у которых нет в описании литеральных строковых типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IBird {}
<span class="hljs-keyword">interface</span> IFish {}
<span class="hljs-keyword">interface</span> IInsect {}
<span class="hljs-keyword">interface</span> IReptile {}

<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
 getAnimalByID(id: <span class="hljs-built_in">string</span>): IBird;
}
<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
 getAnimalByID(id: <span class="hljs-string">'fish'</span>): IFish;
}
<span class="hljs-keyword">interface</span> IAnimalFactory { <span class="hljs-comment">// before</span>
 getAnimalByID(id: <span class="hljs-string">'insect'</span>): IInsect;
 getAnimalByID(id: <span class="hljs-built_in">number</span>): IReptile;
}

<span class="hljs-comment">/**
interface IAnimalFactory { // after
 getAnimalByID(id: 'fish'): IFish;
 getAnimalByID(id: 'insect'): IInsect;
 getAnimalByID(id: number): IReptile;
 getAnimalByID(id: string): IBird;
}
*/</span></code></pre>
</section>