<section id="Ekskurs-v-tipizaciu-yavnaya-i-neyavnaya-tipizaciya" name="Экскурс в типизацию — явная и неявная типизация" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Ekskurs-v-tipizaciu-yavnaya-i-neyavnaya-tipizaciya" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Экскурс в типизацию — явная и неявная типизация
            </h2>
        
<hr>
<p>Помимо разделения на <em>статическую/динамическую</em> и <em>сильную/слабую</em> типизацию, языки программирования разделяются на языки с <em>явной</em> и <em>неявной</em> типизацией. </p>
</section><section id="Yavnaya-tipizaciya-explicit-typing" name="Явная типизация (explicit typing)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Yavnaya-tipizaciya-explicit-typing" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Явная типизация (explicit typing)
            </h2>
        
<hr>
<p>Язык с <em>явной типизацией</em> предполагает, что указание принадлежности к конкретному типу при объявлении языковых элементов возлагается на разработчика.</p>
<p>Явная типизация за счет наличия типизированных параметров и возвращаемого типа у функций и методов, а также указания типов при объявлении переменных, свойств и полей, делает код более понятным (читабельным) и позволяет разработчикам, не знакомым с кодом, быстрее включатся в процесс разработки, тем самым снижая время на модификацию программы.</p>
<p>Явная типизация обязывает явно указывать типы и тем самым способствует развитию у разработчика навыков, необходимых при проектировании архитектуры программ.</p>
<p>В львиной доле языков с явной типизацией существует возможность указывать типы неявно.</p>
<p>Рассмотрим пример кода демонстрирующего явную типизацию.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Controller {
    <span class="hljs-keyword">public</span> check(eggs: IEgg[]): <span class="hljs-built_in">boolean</span> {
        <span class="hljs-keyword">const</span> isValid: <span class="hljs-built_in">boolean</span> = Validator.valid(eggs);
        
        <span class="hljs-keyword">return</span> isValid;
    }
}</code></pre>
<p>Класс <code class="inline-code">Controller</code> содержит метод <code class="inline-code">check</code>, который имеет один обязательный параметр <code class="inline-code">eggs</code> c типом <code class="inline-code">IEgg[ ]</code> и возвращающий тип <code class="inline-code">boolean</code>. Если бы не явно указанные типы параметров, то разработчикам пришлось бы только гадать с чем  именно им предстоит работать. Это же относится и к возвращаемому типу.</p>
<p>Результатом выполнения <code class="inline-code">Validator.valid( eggs )</code> внутри метода <code class="inline-code">check</code> является возвращаемое из функции значение типа <code class="inline-code">boolean</code>. Если бы при объявлении переменной <code class="inline-code">isValid</code> тип <code class="inline-code">boolean</code> не был бы указан явно, то было бы сильно сложнее догадаться что же возвращает метод <code class="inline-code">valid</code>.</p>
<p>Разработчику впервые увидевшему этот код или тому, кто имел с ним дело очень давно, не составит труда разобраться за что отвечает данный участок кода.</p>
<p>К языкам с явной типизацией относятся <em>С++</em>, <em>С#</em> и многие другие.</p>
</section><section id="Neyavnaya-tipizaciya-implicit-typing" name="Неявная типизация (implicit typing)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Neyavnaya-tipizaciya-implicit-typing" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Неявная типизация (implicit typing)
            </h2>
        
<hr>
<p>Язык с <em>неявной типизацией</em> при объявлении языковых элементов не требует от разработчика указания принадлежности к конкретному типу данных и возлагает определение типов на компилятор или интерпретатор.</p>
<p>За основу примера неявной типизации возьмем код из предыдущего примера и лишим его всей атрибутики, связанной с явной типизации.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Controller {
    check(eggs) {
        <span class="hljs-keyword">const</span> isValid = Validator.valid(eggs);
        
        <span class="hljs-keyword">return</span> isValid;
    }
}</code></pre>
<p>Этот код стал занимать меньше места, что является одним из нескольких доводов, которые можно услышать в пользу языков с неявной типизацией. Но на самом деле это не так.</p>
<p>На практике считается хорошим тоном при объявлении языковых элементов уделять особое внимание именованию. Ведь именно от выбора названия будет зависеть то время, которое уйдет у программиста на понимание участка кода при отладке, рефакторинге или модернизации.</p>
<p>Те же рассуждения, в процессе которых происходит рождение более информационного названия, приводят к более детальному осмыслению кода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> EggController {
   checkEgg(eggAll) {
       <span class="hljs-keyword">const</span> isEggValid = EggValidator.qualityEggValid(eggAll);

       <span class="hljs-keyword">return</span> isEggValid;
   }
}</code></pre>
<p>Именно по этой причине правило именования распространяется и на языки с явной типизацией.</p>
<p>А тот факт, что неявная типизация позволяет реализовывать несложные алгоритмы с меньшими временными затратами, разбивается о возможность всех современных языков с явной типизацией с помощью вывода типов указывать тип неявно.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> EggController {
   <span class="hljs-keyword">public</span> checkEgg(eggAll: IEgg[]): <span class="hljs-built_in">boolean</span> {
       <span class="hljs-keyword">const</span> isEggValid: <span class="hljs-built_in">boolean</span> = EggValidator.qualityEggValid(eggAll);

       <span class="hljs-keyword">return</span> isEggValid;
   }
}</code></pre>
<p>К языкам с неявной типизацией относятся такие языки, как <em>JavaScript</em>, <em>PHP</em> и другие.</p>
</section><section id="Itog" name="Итог" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itog" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итог
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Явная типизация возлагает указания типов на разработчика, развивая у него навыки, требующиеся при проектировании программ, и делает код более читабельным.</li>
<li class="book__list__item">Языки с явной типизацией за счет вывода типов имеют возможность указывать типы неявно.</li>
<li class="book__list__item">Неявная типизация возлагает определение типа на компилятор или интерпретатор.</li>
</ul>
</section>