<section id="Tipy-Obektnye-tipy-s-indeksnymi-chlenami-obektnyi-tip-s-dinamicheskimi-kluchami" name="Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipy-Obektnye-tipy-s-indeksnymi-chlenami-obektnyi-tip-s-dinamicheskimi-kluchami" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)
            </h2>
        
<hr>
<p>Статический анализ кода, стремится взять под контроль все конструкции кода, чтобы повысить типобезопасность программы и тем самым переложить работу, связанную с выявлением  ошибок, на себя, оставляя разработчикам больше времени на более важные аспекты. И несмотря на то, что динамические операции являются причиной “головной боли” компилятора, при разработке программ, потребность в них, все таки существует. Одной из таких операций, является создание в объектном типе данных <em>индексных членов</em> (динамических ключей).</p>
<p><em>Индексная сигнатура</em> (index signature)  состоит из двух частей. В первой части расположен <em>идентификатор привязки</em> (binding identifier) имеющий собственную аннотацию типа вместе с которой заключен в квадратные скобки.  Во второй части расположена <em>аннотации типа</em> (type annotation).</p>
<pre><code class="hljs language-typescript">{ [ identifier: Type ]: Type }</code></pre>
<p>При объявлении индексной сигнатуры не должны быть использованы такие модификаторы, как модификаторы доступа и модификатор <code class="inline-code">static</code>, а идентификатор привязки должен принадлежать либо к типу <code class="inline-code">string</code>, либо к типу <code class="inline-code">number</code>. В качестве типа, указанного справа от двоеточия, может быть указан любой тип данных. Идентификатора привязки может иметь произвольное имя.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> Identifier {
   [identifier: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// or </span>
<span class="hljs-keyword">interface</span> Identifier {
   [key: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// or </span>
<span class="hljs-keyword">interface</span> Identifier {
   [name: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}</code></pre>
<p>В одном объектном типе, одновременно могут быть объявлены индексные сигнатуры чьи идентификаторы привязки принадлежат к типу <code class="inline-code">string</code> и типу <code class="inline-code">number</code>. Но с одной оговоркой. Их типы, указанные в аннотации типов, должны быть совместимы (совместимость типов подробно рассматривается в главах <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-obektov" title="Типизация - Совместимость объектов">Типизация - Совместимость объектов</a> и <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Sovmestimost-funkcii" title="Типизация - Совместимость функций">Типизация - Совместимость функций</a>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> A {
  [key:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
  [key:<span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">let</span> a: A = {
  validKeyDeclareStatic: <span class="hljs-string">'value'</span>, <span class="hljs-comment">// Ok, значениепринадлежит к string</span>
  invalidKeyDeclareStatic: <span class="hljs-number">0</span> <span class="hljs-comment">// Error, значение должно быть совместимым с типом string</span>
};
a.validKeyDefineDynamicKey = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok</span>
a.invalidKeyDefineDynamicKey = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, значение должно быть совместимым с типом string</span>
a[<span class="hljs-number">0</span>] = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok</span>



<span class="hljs-keyword">interface</span> B {
   [identifier: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>
   [identifier: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Error, дубликат</span>
}
<span class="hljs-keyword">interface</span> С {
   [identifier: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>
   [identifier: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error, должен принадлежать к типу string</span>
}



<span class="hljs-keyword">class</span> SuperClass { <span class="hljs-comment">// суперкласс</span>
   a: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">class</span> SubClass <span class="hljs-keyword">extends</span> SuperClass { <span class="hljs-comment">// подкласс</span>
   b: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> D {
   [identifier: <span class="hljs-built_in">string</span>]: SuperClass; <span class="hljs-comment">// Ok</span>
   [identifier: <span class="hljs-built_in">number</span>]: SubClass; <span class="hljs-comment">// Ok, SubClass совместим с SuperClass</span>
}

<span class="hljs-keyword">let</span> d: D = {};
d.dynamicKey = <span class="hljs-keyword">new</span> SubClass(); <span class="hljs-comment">// Ok</span>
d[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> SubClass(); <span class="hljs-comment">// Ok</span>

<span class="hljs-keyword">interface</span> E {
   [identifier: <span class="hljs-built_in">string</span>]: SubClass; <span class="hljs-comment">// Ok</span>
   [identifier: <span class="hljs-built_in">number</span>]: SuperClass; <span class="hljs-comment">// Ok, SuperClass несовместим с SubClass</span>
}</code></pre>
<p>Так как классы принадлежат к объектным типам, означает что индексные сигнатуры могут быть объявлены и в них. Все правила, касающиеся индексных сигнатур, которые были рассмотрены ранее и ещё будут рассмотрены далее в этой главе, справедливы и для классов. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Identifier {
  [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
  [key: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;

  [<span class="hljs-number">0</span>]: <span class="hljs-string">'value'</span>;
  [<span class="hljs-number">1</span>]: <span class="hljs-number">5</span>; <span class="hljs-comment">// Error, все члены должны принадлежать к совместимым со string типам</span>


  <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">string</span> = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok, поле name  с типом string</span>
  <span class="hljs-keyword">public</span> b: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, все члены должны принадлежать к совместимым со string типам</span>

  <span class="hljs-keyword">public</span> c(): <span class="hljs-built_in">void</span> { } <span class="hljs-comment">// Error, метод тоже член и на него распространяются те же правила</span>
}

<span class="hljs-keyword">let</span> identifier: Identifier = <span class="hljs-keyword">new</span> Identifier();
identifier.validDynamicKey = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok</span>
identifier.invalidDynamicKey = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error</span>

identifier[<span class="hljs-number">2</span>] = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok</span>
identifier[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error</span></code></pre>
<p>Кроме того, классы накладывают ограничение, которое делает невозможным использовать такие модификаторы, как модификаторы доступа (<code class="inline-code">private</code>, <code class="inline-code">protected</code>, <code class="inline-code">public</code>) и модификаторы указывающие на принадлежность к уровню класса (<code class="inline-code">static</code>). При попытке указать эти модификаторы при объявлении индексной сигнатуры, возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A {
   <span class="hljs-keyword">public</span> [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Error</span>
}
<span class="hljs-keyword">class</span> B {
   <span class="hljs-keyword">static</span> [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Error</span>
}</code></pre>
<p>Правда есть один нюанс. И даже не один, а несколько нюансов. И связаны они все с модификатором <code class="inline-code">readonly</code>, который подробно рассматривается в главе <a class="book__chapter__chapter-link" href="/book/contents/Klassy-Modifikator-readonly" title="Классы - Модификатор readonly">Классы - Модификатор readonly</a>.  Чтобы ничего не ускользнуло от понимания, начнем по порядку.</p>
<p>При  указании модификатора <code class="inline-code">readonly</code> искажается смысл использования индексной сигнатуры, так как это дает ровно противоположный эффект. Вместо объекта, с возможность инициировать значение указанного типа с динамическими ключами, после его создания, мы получаем объект, всем членам которого нельзя ничего присвоить. То есть, объект полностью закрыт для изменения.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаис интерфейсом</span>

<span class="hljs-keyword">interface</span> IIdentifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok, модификатор readonly</span>
}

<span class="hljs-keyword">let</span> instanceObject: IIdentifier = {};

instanceObject.a; <span class="hljs-comment">// Ok, можно объявить</span>
instanceObject.a = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error, но нельзя присвоить значение</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаи с классом</span>

<span class="hljs-keyword">class</span> Identifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> instanseClass = <span class="hljs-keyword">new</span> Identifier();
instanseClass.a; <span class="hljs-comment">// Ok, можно объявить</span>
instanseClass.a = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error, но нельзя присвоить значение</span></code></pre>
<p>Но это только в теории и именно с этим связаны оставшиеся нюансы.</p>
<p>Второй нюанс заключается в том, что когда в классе или объекте, объявлена индексная сигнатура, становится невозможным объявить в теле или добавить через точечную,а также скобочную нотацию, ключи ассоциированные с несовместимым типом данных. Это означает, что правило применимое к индексной сигнатуре распространяется на весь объект, как в момент его инициализации, так и после.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаис интерфейсом</span>

<span class="hljs-keyword">interface</span> IIdentifier {
  [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;

  a: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error, [в момент декларации] допускается объявление идентификаторов принадлежащих только к типу string</span>
}

<span class="hljs-keyword">let</span> instanceObject: IIdentifier = {
  b: <span class="hljs-number">0</span> <span class="hljs-comment">// Error, [в момент объявления] допускается объявление идентификаторов принадлежащих только типу string</span>
};
instanceObject.c = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, [после объявления] допускается объявление идентификаторов принадлежащих только типу string</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаи с классом</span>

<span class="hljs-keyword">class</span> Identifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;

  a: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error, [в момент объявления] допускается объявление идентификаторов принадлежащих только типу string</span>
}

<span class="hljs-keyword">let</span> instanseClass = <span class="hljs-keyword">new</span> Identifier();
instanseClass.b = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, [после объявления] допускается объявление идентификаторов принадлежащих только типу string</span></code></pre>
<p>Но в случаи с модификатором <code class="inline-code">readonly</code> поведение отличается. Несмотря на то, что указывать идентификаторы членов, принадлежащие к несовместимым типам, по прежнему нельзя, допускается их декларация и объявление.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаис интерфейсом</span>

<span class="hljs-keyword">interface</span> IIdentifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>

  a:<span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok, декларация</span>
}

<span class="hljs-keyword">let</span> instanceObject: IIdentifier = {
  a: <span class="hljs-string">''</span>, <span class="hljs-comment">// Ok, реализация</span>
  b: <span class="hljs-string">''</span> <span class="hljs-comment">// Ok, объявление</span>
};

instanceObject.с = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error, ассоциировать ключа со значением после создания объекта по прежнему нельзя</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаи с классом</span>

<span class="hljs-keyword">class</span> Identifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;

  a: <span class="hljs-built_in">string</span> = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok, декларация и объявление</span>
}

<span class="hljs-keyword">let</span> instanseClass = <span class="hljs-keyword">new</span> Identifier();
instanseClass.b = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error, ассоциировать ключа со значением после создания объекта по прежнему нельзя</span></code></pre>
<p>Такая особенность или даже неочевидность, существует и о ней просто нужно знать. Кроме того, из этой особенности, берет начало другая особенность.</p>
<p>Третий нюанс заключается в том, что значения ассоциированные с идентификаторами, которые были задекларированы в типе, можно перезаписать после инициализации объекта.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаис интерфейсом</span>

<span class="hljs-keyword">interface</span> IIdentifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok</span>

  a:<span class="hljs-built_in">string</span>; <span class="hljs-comment">// Ok, декларация</span>
}

<span class="hljs-keyword">let</span> instanceObject: IIdentifier = {
  a: <span class="hljs-string">'value'</span>, <span class="hljs-comment">// Ok, реализация</span>
  b: <span class="hljs-string">'value'</span> <span class="hljs-comment">// Ok, объявление</span>
};

instanceObject.a = <span class="hljs-string">'new value'</span>; <span class="hljs-comment">// Ok, можно перезаписать значение</span>
instanceObject.b = <span class="hljs-string">'new value'</span>; <span class="hljs-comment">// Error, нельзя перезаписать значение</span></code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// в случаи с классом</span>

<span class="hljs-keyword">class</span> Identifier {
  readonly [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;

  a: <span class="hljs-built_in">string</span> = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Ok, декларация и объявление</span>
}

<span class="hljs-keyword">let</span> instanseClass = <span class="hljs-keyword">new</span> Identifier();
instanseClass.a = <span class="hljs-string">'new value'</span>; <span class="hljs-comment">// Ok, можно перезаписать значение</span></code></pre>
<p>Если учесть, что модификатор <code class="inline-code">readonly</code>,  вообще не стоит применять к индексной сигнатуре, то все описанные связанные с ним особенности, вообще можно выкинуть из головы. Но так цель этой книги защитить читателя от, как можно большего количества подводных камней, я решил включить это, так как знание лучшая защита.</p>
<p>Кроме того не будет лишним знать наперед, что если идентификатор привязки принадлежит к типу <code class="inline-code">string</code>, то в качестве ключа может быть использовано значение принадлежащее к типам <code class="inline-code">string</code>, <code class="inline-code">number</code>, <code class="inline-code">symbol</code>, <code class="inline-code">Number Enum</code> и <code class="inline-code">String Enum</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> StringDynamicKey {
  [ key: <span class="hljs-built_in">string</span> ]: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">enum</span> NumberEnum {
 Prop = <span class="hljs-number">0</span>
}

<span class="hljs-keyword">enum</span> StringEnum {
 Prop = <span class="hljs-string">'prop'</span>
}


<span class="hljs-keyword">let</span> example: StringDynamicKey = {
 prop: <span class="hljs-string">''</span>,                           <span class="hljs-comment">// Ok String key</span>
 <span class="hljs-string">''</span>: <span class="hljs-string">''</span>,                             <span class="hljs-comment">// Ok String key</span>
 <span class="hljs-number">1</span>: <span class="hljs-string">''</span>,                              <span class="hljs-comment">// Ok Number key</span>
 [Symbol.for(<span class="hljs-string">'key'</span>)]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok Symbol key</span>
 [ NumberEnum.Prop ]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok Number Enum key</span>
 [ StringEnum.Prop ]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok String Enum key</span>
};</code></pre>
<p>В случае, когда идентификатор привязки принадлежит к типу <code class="inline-code">number</code>, то значение, используемое в качестве ключа, может принадлежать к таким типам, как <code class="inline-code">number</code>, <code class="inline-code">symbol</code>, <code class="inline-code">Number Enum</code> и <code class="inline-code">String Enum</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> NumberDynamicKey {
 [ key: <span class="hljs-built_in">number</span> ]: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">enum</span> NumberEnum {
 Prop = <span class="hljs-number">0</span>
}

<span class="hljs-keyword">enum</span> StringEnum {
 Prop = <span class="hljs-string">'prop'</span>
}


<span class="hljs-keyword">let</span> example: NumberDynamicKey = {
 prop: <span class="hljs-string">''</span>,                           <span class="hljs-comment">// Error String key</span>
 <span class="hljs-string">''</span>: <span class="hljs-string">''</span>,                             <span class="hljs-comment">// Error String key</span>
 <span class="hljs-number">1</span>: <span class="hljs-string">''</span>,                              <span class="hljs-comment">// Ok Number key</span>
 [Symbol.for(<span class="hljs-string">'key'</span>)]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok Symbol key</span>
 [ NumberEnum.Prop ]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok Number Enum key</span>
 [ StringEnum.Prop ]: <span class="hljs-string">''</span>,            <span class="hljs-comment">// Ok String Enum key</span>
};</code></pre>
<p>Теперь давайте рассмотрим, как такой механизм, как вывод типов, в некоторых случаях, выводит тип принадлежащий к объектному типу с индексной сигнатурой.</p>
<p>Напомню, что в <em>JavaScript</em>, помимо привычного способа, при объявлении идентификаторов, в объектных типах, можно использовать, заключая в прямоугольные скобки, строковые литералы, выражения, а также <em>вычисляемые идентификаторы</em> (computed properties).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> computedIdentifier = <span class="hljs-string">'e'</span>;

<span class="hljs-keyword">let</span> v = {
  a: <span class="hljs-string">''</span>, <span class="hljs-comment">// объявление идентификатора привычным способом,</span>
  [ <span class="hljs-string">'b'</span> ]: <span class="hljs-string">''</span>, <span class="hljs-comment">// объявление идентификатора с помощью строкового литерала.</span>
  [ <span class="hljs-string">'c'</span> + <span class="hljs-string">'d'</span> ]: <span class="hljs-string">''</span>, <span class="hljs-comment">// объявление идентификатора с помощью выражения со строковыми литералами</span>
  [ computedIdentifier ]: <span class="hljs-string">''</span> <span class="hljs-comment">// объявление идентификатора при помощи вычисляемого идентификатора</span>
}; </code></pre>
<p>Так вот,в первых двух случаях, вывод типов выводит ожидаемый тип. А в оставшихся случаях, вывод типов выводит тип содержащий индексную сигнатуру.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v1 = {  <span class="hljs-comment">// let v1: { a:  string; }</span>
  a: <span class="hljs-string">'value'</span>  <span class="hljs-comment">// Ok, привычный идентификатор</span>

};

v1.b = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error,  в типе { a:  string } не задекларировано идентификатора b</span>

<span class="hljs-comment">// ---</span>


<span class="hljs-keyword">let</span> v2 = {  <span class="hljs-comment">// let v2: { [ 'a' ]:  string; }</span>
  [ <span class="hljs-string">'a'</span> ]: <span class="hljs-string">'value'</span>  <span class="hljs-comment">// Ok, строковой литерал</span>

};

v2.b = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// Error,  в типе { [ 'a' ]:  string } не задекларировано идентификатора b</span>

<span class="hljs-comment">// ---</span>


<span class="hljs-keyword">let</span> computedIdentifier: <span class="hljs-built_in">string</span> = <span class="hljs-string">'a'</span>;

<span class="hljs-keyword">let</span> v3 = { <span class="hljs-comment">// let v3: { [ x: string ]: string }; - вывод типов выводит как тип с индексной сигнатурой...</span>
  [ computedIdentifier ]: <span class="hljs-string">'value'</span> <span class="hljs-comment">// вычисляемое свойство</span>
};

v3.b = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// ... а это, в свою очередь, позволяет добавлять новое значение</span>

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">let</span> v4 = { <span class="hljs-comment">// let v4: { [ x: string ]: string }; - вывод типов выводит как тип с индексной сигнатурой...</span>
  [ <span class="hljs-string">'a'</span> + <span class="hljs-string">'b'</span> ]: <span class="hljs-string">'value'</span> <span class="hljs-comment">// выражение со строковыми литералами</span>
};

v4.b = <span class="hljs-string">'value'</span>; <span class="hljs-comment">// ... а это, в свою очередь, позволяет добавлять новое значение</span></code></pre>
</section>