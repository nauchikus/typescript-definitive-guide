<section id="Tipy-Object-Array-Tuple" name="Типы - Object, Array, Tuple" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipy-Object-Array-Tuple" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типы - Object, Array, Tuple
            </h2>
        
<hr>
<p>Пришло время рассмотреть такие типы данных как <code class="inline-code">Object</code> и <code class="inline-code">Array</code>, с которыми разработчики <em>JavaScript</em> уже хорошо знакомы. А также неизвестный в мире <em>JavaScript</em> тип данных <code class="inline-code">Tuple</code>, который не представляет из себя ничего сложного.</p>
</section><section id="Object-object-ssylochnyi-obektnyi-tip" name="Object (object) ссылочный объектный тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Object-object-ssylochnyi-obektnyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Object (object) ссылочный объектный тип
            </h2>
        
<hr>
<p>Ссылочный тип данных <code class="inline-code">Object</code> является базовым для всех ссылочных типов в <em>TypeScript</em>.</p>
<p>Помимо того, что в <em>TypeScript</em> существует объектный тип <code class="inline-code">Object</code>, описывающий с помощью глобального интерфейса одноименный тип из <em>JavaScript</em>, также существует тип данных, который представляет любое объектное значение, и который указывается с помощью ключевого слова <code class="inline-code">object</code>. Поведение типа указанного с помощью ключевого слова и интерфейса различаются.</p>
<p>Переменным, которым указан тип с помощью ключевого слова <code class="inline-code">object</code>, не могут хранить значения примитивных типов, чьи имена начинаются со строчной буквы. В отличии от них, тип интерфейс <code class="inline-code">Object</code>, совместим с любым типом данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephant: object;
<span class="hljs-keyword">let</span> lion: <span class="hljs-built_in">Object</span>;


elephant = <span class="hljs-number">5</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-number">5</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-string">""</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-string">""</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Error</span>
lion = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Ok</span>

elephant = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>
lion = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>

elephant = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span>
lion = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Ok, strictNullChecks = false</span></code></pre>
<p>Ограничение объектов типом, указанным с помощью ключевого слова <code class="inline-code">object</code>, будет ограничивать их функционалом интерфейса <code class="inline-code">Object</code>. При попытке обратиться к членам объекта, не задекларированным в интерфейсе <code class="inline-code">Object</code>, возникнет ошибка. Напомним, что в случаях, когда тип нужно сократить до базового, сохранив при этом возможность обращения к специфичным (определенным пользователем) членам объекта, нужно использовать тип <code class="inline-code">any</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> SeaLion {
  rotate():<span class="hljs-built_in">void</span> {}
  voice(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">let</span> seaLionAsObject: object = <span class="hljs-keyword">new</span> SeaLion(); <span class="hljs-comment">// Ok</span>
seaLionAsObject.voice(); <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">let</span> seaLionAsAny: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> SeaLion(); <span class="hljs-comment">// Ok</span>
seaLionAsAny.voice(); <span class="hljs-comment">// Ok</span></code></pre>
<p>Тип интерфейс <code class="inline-code">Object</code> идентичен по своей работе с одноименным типом из <em>JavaScript</em>. Несмотря на то, что тип ,указанный с помощью ключевого слова <code class="inline-code">object</code>, имеет схожее название, его поведение отличается от типа интерфейса.</p>
</section><section id="Array-type-ssylochnyi-massivopodobnyi-tip" name="Array (type[]) ссылочный массивоподобный тип" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Array-type-ssylochnyi-massivopodobnyi-tip" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Array (type[]) ссылочный массивоподобный тип
            </h2>
        
<hr>
<p>Ссылочный тип данных <code class="inline-code">Array</code> является типизированным спископодобным объектом, содержащим логику для работы с элементами.</p>
<p>Тип данных <code class="inline-code">Array</code> указывается с помощью литерала массива, перед которым указывается тип данных <code class="inline-code">type[ ]</code>.</p>
<p>Если  при объявлении массива указать тип <code class="inline-code">string[ ]</code>, то храниться в нем могут только элементы, принадлежащие или совместимые с типом <code class="inline-code">String</code> (например <code class="inline-code">Null</code>, <code class="inline-code">Undefined</code>, <code class="inline-code">Literal Type String</code>)</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> animalAll: <span class="hljs-built_in">string</span>[] = [
 <span class="hljs-string">"Elephant"</span>,
 <span class="hljs-string">"Rhino"</span>,
 <span class="hljs-string">"Gorilla"</span>
];

animalAll.push( <span class="hljs-number">5</span> ); <span class="hljs-comment">// Error</span>
animalAll.push( <span class="hljs-built_in">boolean</span> ); <span class="hljs-comment">// Error</span>
animalAll.push( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// Ok</span>
animalAll.push( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// Ok</span></code></pre>
<p>В случае неявного указания типа, вывод типов самостоятельно укажет тип как <code class="inline-code">string[ ]</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> animalAll = [
 <span class="hljs-string">"Elephant"</span>,
 <span class="hljs-string">"Rhino"</span>,
 <span class="hljs-string">"Gorilla"</span>
]; <span class="hljs-comment">// animalAll : string[ ]</span></code></pre>
<p>Если массив должен хранить смешанные типы данных, то один из способов указать тип объединение (<code class="inline-code">Union</code>). Нужно обратить внимание, на то, как трактуется тип данных Union при указании его массиву. Может показаться, что указав в качестве типа тип объединение Union, массив может состоять только из какого-то одного перечисленного типа <code class="inline-code">Elephant</code>, <code class="inline-code">Rhino</code> или <code class="inline-code">Gorilla</code>. Но это не совсем так. Правильная трактовка гласит, что каждый элемент массива может принадлежать к типу <code class="inline-code">Elephant</code> или <code class="inline-code">Rhino</code> или <code class="inline-code">Gorilla</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Elephant {}
<span class="hljs-keyword">class</span> Rhino {}
<span class="hljs-keyword">class</span> Gorilla {}


<span class="hljs-keyword">var</span> animalAll: ( Elephant | Rhino | Gorilla )[] = [
<span class="hljs-keyword">new</span> Elephant(),
<span class="hljs-keyword">new</span> Rhino(),
<span class="hljs-keyword">new</span> Gorilla()
];</code></pre>
<p>Если для смешанного массива не указать тип явно, то вывод типов самостоятельно укажет все типы, которые хранятся в массиве. Более подробно эта тема будет рассмотрена в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Vyvod-tipov" title="Типизация - Вывод типов" target="_blank">Типизация - Вывод типов</a>.</p>
<p>В случае, если типы данных неизвестны  при создании экземпляра массива, следует указать в качестве типа тип <code class="inline-code">any</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> dataAll: <span class="hljs-built_in">any</span>[] = [];

dataAll.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// Ok -> number</span>
dataAll.push(<span class="hljs-string">'5'</span>); <span class="hljs-comment">// Ok -> string</span>
dataAll.push(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Ok -> boolean</span></code></pre>
<p>Нужно стараться использовать, как можно реже массивы со смешанными типами, а к массивам с типом <code class="inline-code">any</code> нужно прибегать только в самых крайних случаях. Кроме того, как было рассказано в главе <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-variantnosti" title="Экскурс в типизацию - Совместимость типов на основе вариантности" target="_blank">Экскурс в типизацию - Совместимость типов на основе вариантности</a>, из-за того, что нужно крайне осторожно относится к массивам, у которых входные типы являются ковариантными, не рекомендуется указывать массиву базовые типы. </p>
<p>В случаях, в которых требуется создавать массив при помощи оператора new, приходится прибегать к типу глобального обобщённого интерфейса <code class="inline-code">Array&#x3C;T></code>. Обобщения будут рассмотрены чуть позднее, а пока нужно запомнить следующее.</p>
<p>При попытке создать экземпляр массива путем вызова конструктора, операция завершится успехом в тех случаях, когда создаваемый массив будет инициализирован пустым, либо с элементами одного типа данных. В случаях смешанного массива, необходимо явно указывать типы обобщения, заключенные в угловые  скобки.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> animalData: <span class="hljs-built_in">string</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">//Ok</span>
<span class="hljs-keyword">let</span> elephantData: <span class="hljs-built_in">string</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"Dambo"</span>); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> lionData: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[];

lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"Simba"</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Error</span>
lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"Simba"</span>); <span class="hljs-comment">// Ok</span>
lionData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> deerData: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>&#x3C; <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> >(<span class="hljs-string">"Bambi"</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Ok</span></code></pre>
<p>В <em>TypeScript</em>, поведение типа <code class="inline-code">Array</code> идентично поведению одноименного типа в <em>JavaScript</em>.</p>
</section><section id="Tuple-T0-T1-Tn-tip-kortej" name="Tuple ([ T0, T1, …, Tn ]) тип кортеж" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tuple-T0-T1-Tn-tip-kortej" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Tuple ([ T0, T1, …, Tn ]) тип кортеж
            </h2>
        
<hr>
<p>Тип данных <code class="inline-code">Tuple</code> (кортеж) состоит из строго заданной последовательности типов, череда которых соответствует индексам, указанного в качестве значения массива, начиная с нуля. Тип данных Tuple указывается литералом массива, в котором заключены, перечисленные через запятую, типы данных <code class="inline-code">[ T1, T2, T3 ]</code>.</p>
<p>Массив, выступающий в качестве значения, должен хранить элементы таким образом, чтобы в индексах, соответствующих расположению типов в кортеже, обязательно находились значения совместимые с этими типами.</p>
<p>Другими словами, если переменной, аннотированной типом кортеж имеющим определенную последовательность, состоящую из типов <code class="inline-code">string</code> и <code class="inline-code">number</code>, присвоить ссылку на массив у которого первым элементом хранится строка, а вторым цифра, операция присваивания завершится успехом. Если в массиве первым элементом будет значение <code class="inline-code">null</code>, а вторым <code class="inline-code">undefined</code>, то ошибка выброшена не будет, так как эти типы считаются  совместимыми с указанными в кортеже. Но если первым элементом будет цифра, а вторым строка, будет выброшена ошибка, так как не соблюдена заданная последовательность типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>  ]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> giraffeData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span> ]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> liontData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-number">1</span>, <span class="hljs-string">'Simba'</span>  ]; <span class="hljs-comment">// Error</span></code></pre>
<p>Кроме того, длина массива выступающего в качестве значения, должны соответствовать количеству типов указанных в <code class="inline-code">Tuple</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>  ]; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> liontData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-string">'Simba'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>  ]; <span class="hljs-comment">// Error, лишний элемент</span>
<span class="hljs-keyword">let</span> fawnData: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">'Bambi'</span>]; <span class="hljs-comment">// Error, не достает одного элемент</span>
<span class="hljs-keyword">let</span> giraffeData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [  ]; <span class="hljs-comment">// Error, не достает всех элементов</span></code></pre>
<p>Но это правило не мешает добавить новые элементы после того,как массив был присвоен ссылке (ассоциирован с ссылкой). Но элементы, чьи индексы выходят за пределы установленные кортежем, обязаны иметь тип совместимый с одним из перечисленных в этом кортеже.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>  ];
elephantData.push( <span class="hljs-number">1941</span> ); <span class="hljs-comment">// Ok</span>
elephantData.push(<span class="hljs-string">'Disney'</span>); <span class="hljs-comment">// Ok</span>
elephantData.push( <span class="hljs-literal">true</span> ); <span class="hljs-comment">// Error, тип boolean, в то время, как допустимы только типы совместимые с типами string и number</span>

elephantData[ <span class="hljs-number">10</span> ] = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>
elephantData[ <span class="hljs-number">11</span> ] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Ok</span>

elephantData[ <span class="hljs-number">0</span> ] = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok, значение совместимо с типом заданном в кортеже</span>
elephantData[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error, значение не совместимо с типом заданном в кортеже</span></code></pre>
<p>Массив, который связан с типом кортежем, ничем не отличается от обычного, за исключение того, как определяются типы его элементов.</p>
<p>При попытке присвоить элемент под индексом 0 переменной с типом <code class="inline-code">string</code>, а элемент под индексом <code class="inline-code">1</code> переменной с типом <code class="inline-code">number</code>, операции присваивания завершатся успехом. Но несмотря на то, что элемент под индексом <code class="inline-code">2</code> принадлежит к литеральному типу <code class="inline-code">string</code>, при попытке присвоить его в качестве значения переменной с типом <code class="inline-code">string</code>, будет выброшена ошибка. Дело в том, что элементы, чьи индексы выходят за пределы установленные кортежем, принадлежат к типу объединению (<code class="inline-code">Union</code>). Это означает что элемент  под индексом <code class="inline-code">2</code> принадлежит к типу <code class="inline-code">string | number</code>, а это не тоже самое что тип <code class="inline-code">string</code>, который указан переменной.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData: [ <span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span> ] = [ <span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span>  ]; <span class="hljs-comment">// Ok</span>

elephantData[ <span class="hljs-number">2</span> ] = <span class="hljs-string">'nuts'</span>;

<span class="hljs-keyword">let</span> elephantName: <span class="hljs-built_in">string</span> = elephantData[ <span class="hljs-number">0</span> ]; <span class="hljs-comment">// Ok, type string</span>
<span class="hljs-keyword">let</span> elephantAge: <span class="hljs-built_in">number</span> = elephantData[ <span class="hljs-number">1</span> ]; <span class="hljs-comment">// Ok, type number</span>
<span class="hljs-keyword">let</span> elephantDiet: <span class="hljs-built_in">string</span> = elephantData[ <span class="hljs-number">2</span> ]; <span class="hljs-comment">// Error, type string | number</span></code></pre>
<p>Есть два варианта решения этой проблемы. Первый вариант, это изменить тип переменной со <code class="inline-code">string</code> на тип объединение <code class="inline-code">string | number</code>, что ненадолго избавит от проблемы совместимости типов. Второй вариант, более подходящий вариант, прибегнуть к приведению типов, который детально будет рассмотрен позднее.</p>
<p>В случае, если описание кортежа может навредить семантике кода, его можно поместить в описание псевдонима типа (<code class="inline-code">type</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Tuple = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];

<span class="hljs-keyword">let</span> v1: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]; <span class="hljs-comment">// Bad</span>
<span class="hljs-keyword">let</span> v2: Tuple; <span class="hljs-comment">// Good</span></code></pre>
<p>Кроме того, тип кортеж можно указывать в аннотации остаточных параметров (<code class="inline-code">...rest</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> ...rest: [ <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span> ,<span class="hljs-built_in">boolean</span> ] </span>): <span class="hljs-title">void</span> </span>{}

<span class="hljs-keyword">let</span> tuple: [ <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span> ] = [ <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> ];
<span class="hljs-keyword">let</span> array = [ <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> ];

f( <span class="hljs-number">5</span> ); <span class="hljs-comment">// Error</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span> ); <span class="hljs-comment">// Error</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> ); <span class="hljs-comment">// Ok</span>
f( ...tuple ); <span class="hljs-comment">// Ok</span>
f( tuple[<span class="hljs-number">0</span>], tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// Ok</span>
f(...array); <span class="hljs-comment">// Error</span>
f( array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// Error, все элементы массива принадлежат к типу string | number | boolean, в то время как первый элемент кортежа принадлежит к типу number</span></code></pre>
<p>Помимо этого, типы указанные в кортеже могут быть помечены как необязательные с помощью необязательного модификатора  <code class="inline-code">?</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> ...rest: [ <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>?, <span class="hljs-built_in">boolean</span>? ] </span>): <span class="hljs-title">void</span> </span>{}

f( ); <span class="hljs-comment">// Error</span>
f( <span class="hljs-number">5</span> ); <span class="hljs-comment">// Ok</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span> ); <span class="hljs-comment">// Ok</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> ); <span class="hljs-comment">// Ok</span></code></pre>
<p>У кортежа, который включает типы помеченные как не обязательные, свойство длины принадлежит к  типу объединению состоящего из литеральных числовых типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> ...rest: [ <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>?, <span class="hljs-built_in">boolean</span>? ] </span>): [ <span class="hljs-title">number</span>, <span class="hljs-title">string</span>?, <span class="hljs-title">boolean</span>? ] </span>{
  <span class="hljs-keyword">return</span> rest;
}

<span class="hljs-keyword">let</span> l = f( <span class="hljs-number">5</span> ).length; <span class="hljs-comment">// let l: 1 | 2 | 3</span></code></pre>
<p>Еще несколько неочевидных моментов связанным с выводом типов при работе с типом кортеж будет рассмотрено в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipizaciya-Vyvod-tipov" title="Типизация - Вывод типов" target="_blank">Типизация - Вывод типов</a>. </p>
<p>И последнее на что стоит обратить внимание, что кортеж не указывается выводом типов при не явном указании.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> elephantData = [ <span class="hljs-string">'Dambo'</span>, <span class="hljs-number">1</span> ]; <span class="hljs-comment">// type Array (string | number)[]</span></code></pre>
<p>Тип <code class="inline-code">Tuple</code> является уникальным для <code class="inline-code">TypeScript</code>, в <code class="inline-code">JavaScript</code> подобного типа не существует.</p>
</section><section id="Itogi" name="Итоги" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itogi" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итоги
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Поведение типа глобального интерфейса <code class="inline-code">Object</code> отличается от типа указанного с помощью ключевого слова <code class="inline-code">object</code>.</li>
<li class="book__list__item">Объект с типом <code class="inline-code">object</code> является базовым типом для всех ссылочных типов и ограничен <em>api</em> экземпляра класса <code class="inline-code">Object</code>.</li>
<li class="book__list__item">Ссылочный тип <code class="inline-code">Array</code> обозначается с помощью литерала массива перед которым обязательно указывается тип <code class="inline-code">type[ ]</code>.</li>
<li class="book__list__item">Очень важным моментом является понимание того, что указывается не тип данных, из которого состоит массив, а указывается тип данных к которому может принадлежать каждый элемент массива.</li>
<li class="book__list__item">Тип данных <code class="inline-code">Tuple</code> (кортеж) состоит из строго заданной последовательности типов, череда которых соответствует индексам, указанного в качестве значения массива, начиная с нуля и обозначается литералом массива в котором заключены перечисленные типы данных.</li>
<li class="book__list__item">Элементы, чьи индексы выходят за предел установленным кортежем, должны быть совместимы с одним из перечисленных в кортеже типов.</li>
<li class="book__list__item">Элементы, чьи индексы выходят за границы указанные кортежем, при присвоении имеют тип объединения (<code class="inline-code">Union</code>), а также не могут быть получены путем деструктуризации.</li>
<li class="book__list__item">Кортеж не выводится с помощью вывода типов.</li>
</ul>
</section>