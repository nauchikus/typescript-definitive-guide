<h1>Утверждение Типов (Type Assertion)</h1>
<p>Получение значения которое не соотвеветствует ожидаемому типу является обычным делом для типизироанных языков. Понимание причин лежащих в основе несоответствий, а также всевозможные способы их разрешений являются целями данной главы. </p><section id="Utverjdenie-Tipov-obshchee" name="Утверждение Типов - общее" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Utverjdenie-Tipov-obshchee" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Утверждение Типов - общее
            </h2>
        
<hr>
<p>При разработке приложений на языках со статической типизацией, время от времени возникают нестыковки из-за несоответствия типов. Простыми словами, приходится работать с объектом, принадлежащим к известному типу, но ограниченному более специализированным интерфейсом.</p>
<p>В <em>TypeScript</em> большинство операций с несоответствием типов приходится на работу с <em>dom</em> (<em>Document Object Model</em>).</p>
<p>В качестве примера можно рассмотреть работу с таким часто используемым методом, как <code class="inline-code">querySelector()</code>. Но для начала вспомним, что в основе составляющих иерархию dom-дерева объектов лежит базовый тип <code class="inline-code">Node</code> наделенный минимальными признаками необходимыми для построения коллекции. Базовый тип <code class="inline-code">Node</code> расширяет в том числе и тип <code class="inline-code">Element</code>, который является базовым для всех элементов dom-дерева и обладает знакомыми всем признаками, необходимыми для работы с элементами dom, такими как атрибуты (attributes), список классов (<code class="inline-code">classList</code>), размеры клиента (<code class="inline-code">client*</code>) и другими. Элементы dom-дерева можно разделить на те, что не отображаются (унаследованные от <code class="inline-code">Element</code>, как например <code class="inline-code">script</code>, <code class="inline-code">link</code>) и те, что отображаются (например <code class="inline-code">div</code>, <code class="inline-code">body</code>). Последние имеют в своей иерархии наследования тип <code class="inline-code">HTMLElement</code> расширяющий <code class="inline-code">Element</code> который привносит признаки присущие отображаемым объектам, как например координаты, стили, свойство <code class="inline-code">dataset</code> и т.д.</p>
<p>Возвращаясь к методу <code class="inline-code">querySelector()</code>, стоит уточнить, что результатом его вызова может стать любой элемент, находящийся в dom-дереве. Если бы в качестве типа возвращаемого значения был указан тип <code class="inline-code">HTMLElement</code>, то операция получения элемента <code class="inline-code">&#x3C;script></code> или <code class="inline-code">&#x3C;link></code> завершилась бы неудачей, так как они не принадлежат к этому типу. Именно поэтому методу <code class="inline-code">querySelector()</code> в качестве типа возвращаемого значения указан более базовый тип <code class="inline-code">Element</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;canvas id="stage" data-unactive="false">&#x3C;/canvas></span>

<span class="hljs-keyword">const</span> element: Element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);
<span class="hljs-keyword">const</span> stage: HTMLElement = element <span class="hljs-comment">// Error, Element is not assignable to type HTMLElement</span></code></pre>
<p>Но при попытке обратится к свойству <code class="inline-code">dataset</code> объекта, полученного с помощью <code class="inline-code">querySelector()</code>, возникнет ошибка, так как у типа <code class="inline-code">Element</code> отсутствует данное свойство.</p>
<p>Но поскольку разработчику известен тип к которому принадлежит объект по указанному им селектору дает основания попросить вывод типов пересмотреть свое отношение к типу конкретного объекта.</p>
<p><em>Попросить</em> - дословно означает что разработчик может лишь попросить вывод типов пересмотреть отношение к типу. Но решение разрешить операцию или нет все равно остается за последним.</p>
<p>Выражаясь человеческим языком, в <em>TypeScript</em> процесс вынуждающий вывод типов пересмотреть свое отношение к какому-либо типу называется <em>утверждением типа</em> (<code class="inline-code">Type Assertion</code>).</p>
<p>Формально утверждение типа похоже на <em>преобразование</em> (приведение) типов (<em>type conversion</em>, <em>typecasting</em>) но поскольку в скомпилированном коде от типов не остается и следа, то по факту это совершенно другой механизм. Именно поэтому они и называются утверждения. Утверждая тип, разработчик говорит компилятору — *<em>“поверь мне, я знаю, что делаю”</em> (<em>Trust me, I know what I'm doing</em>).</p>
<p>Нельзя не уточнить что хотя в <em>TypeScript</em> и существует термин утверждение типа, по ходу изложения в качестве синонимов будут употребляться слова преобразование, реже — приведение. А так же, не будет лишним напомнить, что приведение — это процесс в котором объект одного типа преобразуется в объект другого типа.</p>
</section><section id="Utverjdenie-Tipa-code-class-inline-code-x3C-Type-code-sintaksis" name="Утверждение Типа <code class="inline-code">&#x3C;Type></code> синтаксис" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Utverjdenie-Tipa-code-class-inline-code-x3C-Type-code-sintaksis" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Утверждение Типа <code class="inline-code">&#x3C;Type></code> синтаксис
            </h2>
        
<hr>
<p>Одним из способов указать компилятору на принадлежность значения к заданному типу является механизм утверждения типа при помощи угловых скообок <code class="inline-code">&#x3C;ConcreteType></code> заключающих в себе конкретный тип, к которому и будет выполняться преобразование. Утверждение типа располагается строго перед выражением результатом выполнения которого будет преобразуемый тип.</p>
<pre><code class="hljs language-typescript">&#x3C;ToType>FromType</code></pre>
<p>Перепишем предыдущий код и исправим в нем ошибку, связанную с несоответствием типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;canvas id="stage" data-unactive="false">&#x3C;/canvas></span>

<span class="hljs-keyword">const</span> element: Element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stage'</span>);

<span class="hljs-keyword">const</span> stage: HTMLElement = &#x3C;HTMLElement>element <span class="hljs-comment">// Ok</span>
stage.dataset.unactive = <span class="hljs-string">'true'</span>;</code></pre>
<p>Если тип данных, к которому разработчик просит преобразовать компилятор, не совместим с преобразуемым типом, то в процессе утверждения возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">let</span> bird: Bird = <span class="hljs-keyword">new</span> Bird();
<span class="hljs-keyword">let</span> fish: Fish = &#x3C;Fish>bird; <span class="hljs-comment">// Ошибка, 'Bird' не может быть преобразован в 'Fish'</span></code></pre>
<p>Кроме того, существуют ситуации, в которых возникает необходимость множественного последовательного преобразования. Ярким примером являются значения полученные от <em>dom</em> элементов, которые воспринимаются разработчиком как числовые или логические, но по факту принадлежат к строковому типу.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;div id="#container">&#x3C;/div></span>

<span class="hljs-keyword">let</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#container'</span>) <span class="hljs-keyword">as</span> HTMLElement;
<span class="hljs-keyword">let</span> { width, height } = element.style;
<span class="hljs-keyword">let</span> area: <span class="hljs-built_in">number</span> = width * height; <span class="hljs-comment">// ошибка -> width и height типа 'string'</span></code></pre>
<p>Дело в том, что в <em>TypeScript</em> невозможно привести тип <code class="inline-code">string</code> к типу <code class="inline-code">number</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;div id="#container">&#x3C;/div></span>

<span class="hljs-keyword">let</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#container'</span>) <span class="hljs-keyword">as</span> HTMLElement;
<span class="hljs-keyword">let</span> { width: widthString, height: heightString } = element.style;

<span class="hljs-keyword">let</span> width: <span class="hljs-built_in">number</span> = &#x3C;<span class="hljs-built_in">number</span>>widthString; <span class="hljs-comment">// Ошибка -> тип 'string' не может быть преобразован  в 'number'</span>
<span class="hljs-keyword">let</span> height: <span class="hljs-built_in">number</span> = &#x3C;<span class="hljs-built_in">number</span>>heightString; <span class="hljs-comment">// Ошибка -> тип 'string' не может быть преобразован  в 'number'</span></code></pre>
<p>Но осуществить задуманное можно преобразовав тип <code class="inline-code">string</code> сначала в тип <code class="inline-code">any</code>, а уже затем — в тип <code class="inline-code">number</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;div id="#container">&#x3C;/div></span>

<span class="hljs-keyword">let</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#container'</span>) <span class="hljs-keyword">as</span> HTMLElement;
<span class="hljs-keyword">let</span> { width: widthString, height: heightString } = element.style;

<span class="hljs-keyword">let</span> width: <span class="hljs-built_in">number</span> = &#x3C;<span class="hljs-built_in">number</span>>&#x3C;<span class="hljs-built_in">any</span>>widthString; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> height: <span class="hljs-built_in">number</span> = &#x3C;<span class="hljs-built_in">number</span>>&#x3C;<span class="hljs-built_in">any</span>>heightString; <span class="hljs-comment">// Ok</span>

<span class="hljs-keyword">let</span> area: <span class="hljs-built_in">number</span> = width * height; <span class="hljs-comment">// Ok</span></code></pre>
<p>Стоит также заметить, что данный способ утверждения типа, кроме синтаксиса, больше ничем не отличается от указания с помощью оператора <code class="inline-code">as</code>.</p>
</section><section id="Utverjdenie-Tipa-s-pomoshchu-operatora-as" name="Утверждение Типа с помощью оператора as" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Utverjdenie-Tipa-s-pomoshchu-operatora-as" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Утверждение Типа с помощью оператора as
            </h2>
        
<hr>
<p>В отличии от синтаксиса угловых скобок, которые указываются перед преобразуемым типом, оператор <code class="inline-code">as</code> указывается между преобразуемым и типом и типом к которому требуется преобразовать.</p>
<pre><code class="hljs language-typescript">FromType <span class="hljs-keyword">as</span> ToType</code></pre>
<p>Для демонстрации оператора <code class="inline-code">as</code> рассмотрим ещё один часто встречающийся случай требующий утверждения типов.</p>
<p>Обычное дело: при помощи метода <code class="inline-code">querySelector()</code> получить объект принадлежащий к типу <code class="inline-code">HTMLElement</code>, и подписать его на событие <code class="inline-code">click</code>. Задача заключается в том, что при возникновении события, нужно изменить значение поля <code class="inline-code">dataset</code>, объявленного в типе <code class="inline-code">HTMLElement</code>. Было бы нерационально снова получать ссылку на объект при помощи метода <code class="inline-code">querySelector()</code>, ведь нужный объект хранится в свойстве объекта события <code class="inline-code">target</code>. Но дело в том что свойство <code class="inline-code">target</code> имеет тип <code class="inline-code">EventTarget</code>, который не находится в иерархической зависимости с типом <code class="inline-code">HTMLElement</code> имеющим нужное свойство <code class="inline-code">dataset</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// &#x3C;span id="counter">&#x3C;/span></span>

<span class="hljs-keyword">let</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>) <span class="hljs-keyword">as</span> HTMLElement;
element.dataset.count = (<span class="hljs-number">0</span>).toString();

element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">{target}</span>) =></span> {
    <span class="hljs-keyword">let</span> count: <span class="hljs-built_in">number</span> = target.dataset.count; <span class="hljs-comment">// Error -> Property 'dataset' does not exist on type 'EventTarget'</span>
});</code></pre>
<p>Но эту проблему легко решить с помощью оператора утверждения типа <code class="inline-code">as</code>. Кроме того, с помощью этого же оператора можно привести тип <code class="inline-code">string</code>, к которому принадлежат все свойства находящиеся в <code class="inline-code">dataset</code>, к типу <code class="inline-code">any</code>, а уже затем к типу <code class="inline-code">number</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>) <span class="hljs-keyword">as</span> HTMLElement;
element.dataset.count = (<span class="hljs-number">0</span>).toString();

element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">{ target }</span>) =></span> {
    <span class="hljs-keyword">let</span> element = target <span class="hljs-keyword">as</span> HTMLElement;
    <span class="hljs-keyword">let</span> count: <span class="hljs-built_in">number</span> = element.dataset.count <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;

    element.dataset.count = (++count).toString();
});</code></pre>
<p>В случае несовместимости типов возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Bird {
    <span class="hljs-keyword">public</span> fly(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">class</span> Fish {
    <span class="hljs-keyword">public</span> swim(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">let</span> bird: Bird = <span class="hljs-keyword">new</span> Bird();
<span class="hljs-keyword">let</span> fish: Fish = bird <span class="hljs-keyword">as</span> Fish; <span class="hljs-comment">// Ошибка, 'Bird' не может быть преобразован в 'Fish'</span></code></pre>
<p>Ещё одна острая необходимость требующая утверждения типа возникает тогда, когда разработчику приходится работать с объектом ссылка на который ограничена более общим типом, как например <code class="inline-code">any</code>.</p>
<p>Тот факт, что над значением принадлежащему к типу <code class="inline-code">any</code> разрешено выполнение любых операций, говорит только о том, что компилятор эти операции не проверяет. Другими словами, разработчик указывая тип <code class="inline-code">any</code>, усложняет процесс разработки, мешая компилятору проводить статический анализ кода, а также лишает себя помощи со стороны редактора кода.</p>
<p>В случаях, когда разработчику известно к какому типу принадлежит значение, можно попросить компилятор изменить мнение о принадлежности значения к его типу с помощью механизма утверждения типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> DataProvider {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly data: <span class="hljs-built_in">any</span></span>) {}
}

<span class="hljs-keyword">let</span> provider: DataProvider = <span class="hljs-keyword">new</span> DataProvider(<span class="hljs-string">'text'</span>);

<span class="hljs-keyword">var</span> charAll: <span class="hljs-built_in">string</span>[] = provider.data.split(<span class="hljs-string">''</span>); <span class="hljs-comment">// Ок</span>
<span class="hljs-keyword">var</span> charAll: <span class="hljs-built_in">string</span>[] = provider.data.sPlIt(<span class="hljs-string">''</span>); <span class="hljs-comment">// Ошибка во время выполнения программы</span>
<span class="hljs-keyword">var</span> charAll: <span class="hljs-built_in">string</span>[] = (provider.data <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).split(<span class="hljs-string">''</span>); <span class="hljs-comment">// Ок</span>

<span class="hljs-keyword">let</span> dataString: <span class="hljs-built_in">string</span> = provider.data <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">var</span> charAll: <span class="hljs-built_in">string</span>[] = dataString.split(<span class="hljs-string">''</span>); <span class="hljs-comment">// Ок</span></code></pre>
<p>Напоследок, стоит сказать что выражения требующие указание типа при работе с <em>dom api</em> — это неизбежность. Кроме того, для работы с методом <code class="inline-code">document.querySelector()</code>, который был использован в примерах к этой главе, вместо приведения типов с помощью операторов <code class="inline-code">&#x3C;Type></code> или <code class="inline-code">as</code> предпочтительней конкретизировать тип с помощью обобщения, которые рассматриваются в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obobshcheniya-Generics" title="Типы - Обобщения (Generics)" target="_blank">Типы - Обобщения (Generics)</a>. Но в случае, если утверждение требуется для кода написанного самим разработчиком, то скорее всего, это следствие плохо продуманной архитектуры.</p>
</section><section id="Privedenie-utverjdenie-k-konstante-const-assertion" name="Приведение (утверждение) к константе (const assertion)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Privedenie-utverjdenie-k-konstante-const-assertion" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Приведение (утверждение) к константе (const assertion)
            </h2>
        
<hr>
<p>Ни для кого не секрет, что с точки зрения <em>JavaScript</em>, а следовательно и <em>TypeScript</em>, все примитивные литеральные значения являются константными значениями. С точки зрения среды исполнения два эквивалентных литерала любого литерального типа являются единым значением. То есть, среда исполнения расценивает два строковых литерала <code class="inline-code">'text'</code> и <code class="inline-code">'text'</code> как один литерал. Тоже самое справедливо и для остальных литералов, к которым помимо типа <code class="inline-code">string</code> также относятся типы <code class="inline-code">number</code>, <code class="inline-code">boolean</code> и <code class="inline-code">symbol</code>.</p>
<p>Тем не менее сложно найти разработчика <em>TypeScript</em>, который при определении конструкций, которым предстоит проверка на принадлежность к литеральному типу, не испытывал дискомфорта создаваемого выводом типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Status = <span class="hljs-number">200</span> | <span class="hljs-number">404</span>;
<span class="hljs-keyword">type</span> Request = { status: Status }

<span class="hljs-keyword">let</span> status = <span class="hljs-number">200</span>;

<span class="hljs-keyword">let</span> request: Request = { status }; <span class="hljs-comment">// Error, Type 'number' is not assignable to type 'Status'.ts(2322)</span></code></pre>
<p>В коде выше ошибка возникает по причине того, что вывод типов определяет принадлежность значения переменной <code class="inline-code">status</code> к типу <code class="inline-code">number</code>, а не литеральному числовому типу <code class="inline-code">200</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// вывод типов видит как</span>
<span class="hljs-keyword">let</span> status: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span>

<span class="hljs-comment">// в то время как требуется так</span>
<span class="hljs-keyword">let</span> port: <span class="hljs-number">200</span> = <span class="hljs-number">200</span>;</code></pre>
<p>Прежде всего не будет лишним упомянуть что данную проблему можно решить с помощью механизма утверждения при помощи таких операторов как <code class="inline-code">as</code> и угловых скобок <code class="inline-code">&#x3C;></code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Status = <span class="hljs-number">200</span> | <span class="hljs-number">404</span>;
<span class="hljs-keyword">type</span> Request = { status: Status }

<span class="hljs-keyword">let</span> status = <span class="hljs-number">200</span>;

<span class="hljs-comment">// утверждаем компилятору..</span>
<span class="hljs-keyword">let</span> request: Request = { status: status <span class="hljs-keyword">as</span> <span class="hljs-number">200</span> }; <span class="hljs-comment">// ...с помощью as оператора</span>
<span class="hljs-keyword">let</span> request: Request = { status: &#x3C;<span class="hljs-number">200</span>>status }; <span class="hljs-comment">// ...с помощью угловых скобок</span>
<span class="hljs-comment">// ...что он должен рассматривать значение, ассоциированное с as, как значение, принадлежащие к литеральному типу '200'</span></code></pre>
<p>Но лучшим решением будет специально созданный для подобных случаев механизм позволяющий производить утверждение к константе.</p>
<p>Константное утверждение производится с помощью опертора <code class="inline-code">as</code> или угловых скобок <code class="inline-code">&#x3C;></code> и говорит компилятору, что значение является константным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Status = <span class="hljs-number">200</span> | <span class="hljs-number">404</span>;
<span class="hljs-keyword">type</span> Request = { status: Status }

<span class="hljs-keyword">let</span> status = <span class="hljs-number">200</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-comment">// let status = &#x3C;const>200;</span>

<span class="hljs-keyword">let</span> request: Request = {status}; <span class="hljs-comment">// Ok</span></code></pre>
<p>Утверждение, что значение является константным, заставляет вывод типов расценивать его как принадлежащее к литеральному типу.</p>
<p>Утверждение к константе массива заставляет вывод типов определять его принадлежность к типу <code class="inline-code">readonly tuple</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">200</span>, <span class="hljs-number">404</span>]; <span class="hljs-comment">// let a: number[]</span>

<span class="hljs-keyword">let</span> b = [<span class="hljs-number">200</span>, <span class="hljs-number">404</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// let b: readonly [200, 404]</span>
<span class="hljs-keyword">let</span> c = &#x3C;<span class="hljs-keyword">const</span>>[<span class="hljs-number">200</span>, <span class="hljs-number">404</span>]; <span class="hljs-comment">// let c: readonly [200, 404]</span></code></pre>
<p>В случае с объектным типом, утверждение к константе рекурсивно помечает все его поля как <code class="inline-code">readonly</code>. Кроме того, все его поля принадлежащие к примитивным типам расцениваются как литеральные типы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> NotConstResponseType = {
    status: <span class="hljs-built_in">number</span>;
    data: {
        role: <span class="hljs-built_in">string</span>;
    };
}

<span class="hljs-keyword">type</span> ConstResponseType = {
    status: <span class="hljs-number">200</span> | <span class="hljs-number">404</span>;
    data: {
        role: <span class="hljs-string">'user'</span> | <span class="hljs-string">'admin'</span>;
    };
}

<span class="hljs-keyword">let</span> a = { status: <span class="hljs-number">200</span>, data: { role: <span class="hljs-string">'user'</span> }}; <span class="hljs-comment">// NotConstResponseType</span>

<span class="hljs-keyword">let</span> b = { status: <span class="hljs-number">200</span>, data: { role: <span class="hljs-string">'user'</span> }} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// ConstResponseType</span>
<span class="hljs-keyword">let</span> c = &#x3C;<span class="hljs-keyword">const</span>>{ status: <span class="hljs-number">200</span>, data: { role: <span class="hljs-string">'user'</span> }}; <span class="hljs-comment">// ConstResponseType</span></code></pre>
<p>Но стоит помнить, что утверждение к константе применимо исключительно к <code class="inline-code">number</code>, <code class="inline-code">string</code>, <code class="inline-code">boolean</code>, <code class="inline-code">array</code> и <code class="inline-code">object</code> литералам.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">'value'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok - 'value' является литералом, let a: "value"</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">100</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok - 100 является литералом, let b: 100</span>
<span class="hljs-keyword">let</span> c = <span class="hljs-literal">true</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok - true является литералом, let c: true</span>

<span class="hljs-keyword">let</span> d = [] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok - [] является литералом, let d: readonly []</span>
<span class="hljs-keyword">let</span> e = { f: <span class="hljs-number">100</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok - {} является литералом, let e: {readonly f: 100}</span>

<span class="hljs-keyword">let</span> value = <span class="hljs-string">'value'</span>;
<span class="hljs-keyword">let</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// let array: number[]</span>
<span class="hljs-keyword">let</span> object = { f: <span class="hljs-number">100</span> }; <span class="hljs-comment">// let object: {f: number}</span>

<span class="hljs-keyword">let</span> f = value <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ошибка - value это ссылка идентификатор хранящий литерал</span>
<span class="hljs-keyword">let</span> g = array <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ошибка - array это ссылка на идентификатор хранящий ссылку на объект массива</span>
<span class="hljs-keyword">let</span> h = object <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ошибка - object это ссылка идентификатор хранящий ссылку на объект объекта</span></code></pre>
<p>После рассмотрения всех случаев утверждения к константе (примитивных, массивов и объектных типов) может сложиться впечатление, что в <em>TypeScript</em>, наконец, появились структуры, которые справедливо было бы назвать полноценными константами неизменяемыми ни при каких условиях. И это, отчасти, действительно так. Но дело в том, что на момент версии <em>TypeScript</em> <code class="inline-code">3.4</code> принадлежность объектных и массивоподобных типов к константе зависит от значений, с которыми они ассоциированы.</p>
<p>В случае, когда литералы ссылочных типов (массивы и объекты) ассоциированны при помощи агрегационных отношений со значением, также принадлежащим к ссылочному типу, то они представляются такими, какими были на момент ассоциации. Кроме того, поведение механизма приведения к константе зависит от другого механизма — деструктуризации.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> defaultObject = { f: <span class="hljs-number">100</span> }; <span class="hljs-comment">// let defaultObject: {f: number;}</span>
<span class="hljs-keyword">let</span> constObject = { f: <span class="hljs-number">100</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// let constObject: {readonly f: 100;}</span>

<span class="hljs-keyword">let</span> defaultArray = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// let defaultArray: number[]</span>
<span class="hljs-keyword">let</span> constArray = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// let constArray: readonly [0, 1, 2]</span>

<span class="hljs-comment">// неожиданно - o0.f не имеет модификатора readonly! ожидаемо - o0.f.f иммутабельный (неизменяемый) объект</span>
<span class="hljs-keyword">let</span> o0 = {f: {f: <span class="hljs-number">100</span>}} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// {f: {readonly f: 100;};}</span>
<span class="hljs-comment">// ожидаемо - o1.f имеет модификатор readonly. возможно ожидаемо - o1.f.f мутабельный (изменяемый) объект</span>
<span class="hljs-keyword">let</span> o1 = {f: defaultObject} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// {readonly f: {f: number;};}</span>
<span class="hljs-comment">// ожидаемо - o2 иммутабельный (неизменяемый) объект</span>
<span class="hljs-keyword">let</span> o2 = {...defaultObject} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// {readonly f: number;}</span>
<span class="hljs-comment">// неожиданно - o3.f не имеет модификатора readonly. ожидаемо- o3.f.f иммутабельный (неизменяемый) объект</span>
<span class="hljs-keyword">let</span> o3 = {f: {...defaultObject}} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// {f: {readonly f: number;};}</span>

<span class="hljs-comment">// ожидаемо - o4.f и o4.f.f иммутабельные (неизменяемые) объекты</span>
<span class="hljs-keyword">let</span> o4 = {f: constObject} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// let o4: {readonly f: {readonly f: 100;};}</span>
<span class="hljs-comment">// ожидаемо - o5 иммутабельный (неизменяемый)  объект</span>
<span class="hljs-keyword">let</span> o5 = {...constObject} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// let o5: {readonly f: 100;}</span>
<span class="hljs-comment">// неожиданно - o6.f не имеет модификатора readonly. ожидаемо- o6.f.f иммутабельный (неизменяемый) объект</span>
<span class="hljs-keyword">let</span> o6 = {f: {...constObject}} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// {f: {readonly f: 100;};}</span></code></pre>
<p>По причине того, что непримитивные (объектные) типы данных, хранящиеся в массиве, подчиняются описанным выше правилам, подробное рассмотрение процесса утверждения массива к константе будет опущено.</p>
<p>И последнее, о чем стоит упомянуть — утверждение к константе применимо только к простым выражениям.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> a = (<span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span>) ? <span class="hljs-string">'yes'</span> : <span class="hljs-string">'no'</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ошибка</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1</span>) ? <span class="hljs-string">'yes'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> : <span class="hljs-string">'no'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// Ok, let b: "yes" | "no"</span></code></pre>
</section><section id="Utverjdenie-v-signature-Signature-Assertion" name="Утверждение в сигнатуре (Signature Assertion)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Utverjdenie-v-signature-Signature-Assertion" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Утверждение в сигнатуре (Signature Assertion)
            </h2>
        
<hr>
<p>Помимо функций реализущих механизм <em>утверждения типа</em> в <em>TypeScript</em> существует механизм <em>утверждения в сигнатуре</em> позволяющий определять утверждающие функции, вызов которых, в случае не выполенения условия, приводит к выбрасыванию исключения.</p>
<p>Для того чтобы объявить утверждающую функцию, в её сигнатуре (там где располагается возвращаемое значение) следует указать ключевое слово <code class="inline-code">asserts</code>, а затем параметр принимаемого на вход условия.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">condition: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">condition</span> </span>{
    <span class="hljs-keyword">if</span> (!condition) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">''</span>);
    }
}</code></pre>
<p>Ключевой особенностью утверждения в сигнатуре является то, что в качестве аргумента утверждающая функция ожидает выражение определяющие принадлежность к конкретному типу с помощью любого предназначенного для этого механизма (<code class="inline-code">typeof</code>, <code class="inline-code">instanceof</code> и даже с помощью механизма утверждения типов реализуемого самим <em>TypeScript</em>).</p>
<p>Если принадленость значения к указанному типу подтверждается, то далее по коду компилятор будет рассматривать его в роли этого типа. Иначе выбрасывается исключение.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// утверждение в сигнатуре</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringAssert</span>(<span class="hljs-params">condition: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">condition</span> </span>{
    <span class="hljs-keyword">if</span> (!condition) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">``</span>);
    }
}

<span class="hljs-comment">// утверждение типа</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>;
}

<span class="hljs-keyword">const</span> testScope = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">any</span></span>) =></span> {
    text.touppercase(); <span class="hljs-comment">// до утверждения расценивается как тип any..</span>

    isStringAssert(text <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>); <span class="hljs-comment">// выражение с оператором instanceof</span>
    isStringAssert(<span class="hljs-keyword">typeof</span> text === <span class="hljs-string">'string'</span>); <span class="hljs-comment">// выражение с оператором typeof</span>
    isStringAssert(isString(text)); <span class="hljs-comment">// механизм "утверждения типа"</span>

    text.touppercase(); <span class="hljs-comment">// ..после утверждениея как тип string</span>
}</code></pre>
<p>При использовании механизма <em>утверждения в сигнатуре</em> с механизмом <em>утверждения типа</em>, условие из вызова утверждающей функции можно перенести в её тело.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringAsserts</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">``</span>);
    }
}

<span class="hljs-keyword">const</span> testScope= <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">any</span></span>) =></span> {
    text.touppercase(); <span class="hljs-comment">// не является ошибкой, потому что тип - any</span>

    isStringAsserts(text); <span class="hljs-comment">// условие определено внутри утверждающей функции</span>

    text.touppercase(); <span class="hljs-comment">// теперь ошибка, потому что тип утвержден как string</span>
}</code></pre>
<p>Стоит обратить внимания на то, что механизм утверждения типа не будет работать в случае переноса условного выражения в тело утверждающей функции, сигнатура которой, лишена <em>утверждения типов</em> и содержит исключительно <em>утверждения в сигнатуре</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringAsserts</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">asserts</span> <span class="hljs-title">value</span> /** <span class="hljs-title">is</span> <span class="hljs-title">string</span> */ </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">``</span>);
    }
}

<span class="hljs-keyword">const</span> testScope=<span class="hljs-function">(<span class="hljs-params">text:<span class="hljs-built_in">any</span></span>)=></span>{
    text.touppercase(); <span class="hljs-comment">// не является ошибкой, потому что тип - any</span>

    isStringAsserts(text); <span class="hljs-comment">// условие определено в утверждающей функции</span>

    text.touppercase(); <span class="hljs-comment">// нет ошибки, потому что утверждение типов не работает</span>
}</code></pre>
</section><section id="Itogi" name="Итоги" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itogi" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итоги
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Процесс, который в других языках принято называть приведение или преобразование, в <em>TypeScript</em> называется утверждение типа.</li>
<li class="book__list__item">Процесс утверждения типа лишь просит компилятор пересмотреть свое отношение к типу, но конечное решение остается за ним.</li>
<li class="book__list__item">Утверждение типа может указываться двумя способами, при помощи синтаксиса угловых скобок, в которые заключен тип (<code class="inline-code">&#x3C;ToType>FromType</code>), и с помощью оператора <code class="inline-code">as</code> (<code class="inline-code">FromType as ToType</code>).</li>
<li class="book__list__item">Код, который был создан разработчиком и требует утверждения типов, скорее всего является признаком непродуманной архитектуры.</li>
</ul>
</section>