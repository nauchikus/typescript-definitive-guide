<section id="Operator-keyof-Lookup-Types-Mapped-Types-Mapped-Types-prefiksy-i" name="Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Operator-keyof-Lookup-Types-Mapped-Types-Mapped-Types-prefiksy-i" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -
            </h2>
        
<hr>
<p>Для того, чтобы повысить уровень выявления ошибок и при этом сократить время разработки программы, создатели <em>TypeScript</em> не прекращают радовать разработчиков добавлением новых возможностей для взаимодействия с типами данных. Благодаря усилиям разработчиков со всего земного шара, стало осуществимо получать объединенный тип состоящий, как ключей, так и значений описания типа данных. И кроме того, стало возможно итерировать типами данных.</p>
</section><section id="Zapros-kluchei-keyof" name="Запрос ключей keyof" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Zapros-kluchei-keyof" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Запрос ключей keyof
            </h2>
        
<hr>
<p>В <em>TypeScript</em> существует возможность выводить все публичные не статические ключи принадлежащие типу и на их основе создавать литеральный объединенный тип (<code class="inline-code">Union</code>). Для получения ключей нужно указать оператор <code class="inline-code">keyof</code> после которого указан тип данных, чьи ключи будут объединены в тип <code class="inline-code">Union - keyof Type</code>.</p>
<p>Оператор <code class="inline-code">keyof</code> может применяться к любому типу данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AliasType = { f1: <span class="hljs-built_in">number</span>, f2: <span class="hljs-built_in">string</span> };

<span class="hljs-keyword">interface</span> IInterfaceType {
  f1: <span class="hljs-built_in">number</span>;
  f2: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> ClassType {
  f1: <span class="hljs-built_in">number</span>;
  f2: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> v1: keyof AliasType; <span class="hljs-comment">// v1: "f1" | "f2"</span>
<span class="hljs-keyword">let</span> v2: keyof IInterfaceType; <span class="hljs-comment">// v2: "f1" | "f2"</span>
<span class="hljs-keyword">let</span> v3: keyof ClassType; <span class="hljs-comment">// v3: "f1" | "f2"</span>
<span class="hljs-keyword">let</span> v4: keyof <span class="hljs-built_in">number</span>; <span class="hljs-comment">// v4: "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"</span></code></pre>
<p>Как уже было замечено, оператор <code class="inline-code">keyof</code> выводит только публичные не статические ключи типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Type {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> fieldClass: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> methodClass(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-keyword">private</span> privateField: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">protected</span> protectedField: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">public</span> publicField: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> property(): <span class="hljs-built_in">number</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">NaN</span>; }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">set</span> property( value: <span class="hljs-built_in">number</span> ) {  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-keyword">public</span> instanceMethod(): <span class="hljs-built_in">void</span> {}
}

<span class="hljs-keyword">let</span> v1: keyof Type; <span class="hljs-comment">// a: "publicField" | "property" | "instanceMethod"</span></code></pre>
<p>В случае, если тип данных не содержит публичных ключей, оператор <code class="inline-code">keyof</code> определит его, как тип <code class="inline-code">never</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AliasType = { };

<span class="hljs-keyword">interface</span> IInterfaceType { }

<span class="hljs-keyword">class</span> ClassType {
  <span class="hljs-keyword">private</span> f1: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">protected</span> f2: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> v1: keyof AliasType; <span class="hljs-comment">// v1: never</span>
<span class="hljs-keyword">let</span> v2: keyof IInterfaceType; <span class="hljs-comment">// v2: never</span>
<span class="hljs-keyword">let</span> v3: keyof ClassType; <span class="hljs-comment">// v3: never</span>
<span class="hljs-keyword">let</span> v4: keyof object; <span class="hljs-comment">// v4: never</span></code></pre>
<p>Оператор <code class="inline-code">keyof</code> также может использоваться в объявлении обобщенного типа данных. Точнее, с помощью оператора <code class="inline-code">keyof</code> можно получить тип, а затем расширить его параметром типа. Важно понимать, что в качестве значения по умолчанию, может выступать только тип, совместимый с объединенным типом, полученным на основе ключей.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span> = <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{}</code></pre>
<p>Напоследок стоит упомянуть об одном не очевидном моменте. Оператор <code class="inline-code">keyof</code> можно совмещать с оператором <code class="inline-code">typeof</code> (Type Queries).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Animal {
  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal();

<span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span>: <span class="hljs-keyword">typeof</span> animal; <span class="hljs-comment">// type: { name: string; age: number; }</span>
<span class="hljs-keyword">let</span> union: keyof <span class="hljs-keyword">typeof</span> animal; <span class="hljs-comment">// union: "name" | "age"</span></code></pre>
</section><section id="Poisk-tipov-Lookup-Types" name="Поиск типов (Lookup Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Poisk-tipov-Lookup-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Поиск типов (Lookup Types)
            </h2>
        
<hr>
<p>Если оператор <code class="inline-code">keyof</code> выбирает все доступные ключи, то с помощью поиска типов, можно получить заданные типы по известным ключам. Получить связанный с ключом тип, можно с помощью скобочночной нотации, в которой, через оператор вертикальная черта <code class="inline-code">|</code>, будут перечислены от одного и более, существующего в типе, ключа. В качестве типа данных могут выступать только интерфейсы, классы и в ограниченных случаях операторы типа.</p>
<p>В случаях, когда в качестве типа данных выступает интерфейс, то получить можно все типы, без исключения. При попытке получить тип несуществующего ключа, возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IInterfaceType {
  p1: <span class="hljs-built_in">number</span>;
  p2: <span class="hljs-built_in">string</span>;
}


<span class="hljs-keyword">let</span> v1: IInterfaceType[ <span class="hljs-string">'p1'</span> ]; <span class="hljs-comment">// v1: number</span>
<span class="hljs-keyword">let</span> v2: IInterfaceType[ <span class="hljs-string">'p2'</span> ]; <span class="hljs-comment">// p2: number</span>
<span class="hljs-keyword">let</span> union: IInterfaceType[ <span class="hljs-string">'p1'</span> | <span class="hljs-string">'p2'</span> ]; <span class="hljs-comment">// union: number | string</span>
<span class="hljs-keyword">let</span> notexist: IInterfaceType[ <span class="hljs-string">'notexist'</span> ]; <span class="hljs-comment">// Error -> Property 'notexist' does not exist on type 'IAnimal'</span></code></pre>
<p>Если в качестве типа выступает класс, то получить типы можно только у членов его экземпляра. При попытке получить тип несуществующего члена, возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> ClassType {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> publicFieldClass: <span class="hljs-built_in">number</span>;
 
  <span class="hljs-keyword">public</span> publicInstanceField: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">protected</span> protectedInstanceField: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> privateInstanceField: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> propertyInstance(): <span class="hljs-built_in">number</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">NaN</span>; }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">set</span> propertyInstance(value: <span class="hljs-built_in">number</span>) {}

  <span class="hljs-keyword">public</span> methodInstance(): <span class="hljs-built_in">void</span> {}
}


<span class="hljs-keyword">let</span> publicFieldClass: ClassType[<span class="hljs-string">'publicFieldClass'</span>]; <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">let</span> publicFieldInstance: ClassType[<span class="hljs-string">'publicInstanceField'</span>]; <span class="hljs-comment">// publicFieldInstance: number</span>
<span class="hljs-keyword">let</span> protectedFieldInstance: ClassType[<span class="hljs-string">'protectedInstanceField'</span>]; <span class="hljs-comment">// protectedFieldInstance: string</span>
<span class="hljs-keyword">let</span> privateFieldInstance: ClassType[<span class="hljs-string">'privateInstanceField'</span>]; <span class="hljs-comment">// privateFieldInstance: boolean</span>
<span class="hljs-keyword">let</span> propertyInstance: ClassType[<span class="hljs-string">'propertyInstance'</span>]; <span class="hljs-comment">// propertyInstance: number</span>
<span class="hljs-keyword">let</span> methodInstance: ClassType[<span class="hljs-string">'methodInstance'</span>]; <span class="hljs-comment">// methodInstance: () => void</span>

<span class="hljs-keyword">let</span> notexist: ClassType[<span class="hljs-string">'notexist'</span>]; <span class="hljs-comment">// Error</span></code></pre>
<p>Нельзя переоценить вклад возможностей поиска типов, которые пришлись на динамическую часть типизированного мира <em>TypeScript</em>. Благодаря поиску типов в паре с оператором keyof, появилась возможность, позволяющая выводу типов, устанавливать связь между динамическими ключами и их типами. Это в свою очередь позволяет производить дополнительные проверки, которые повышают <em>“типобезопасность”</em> кода.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Model&#x3C;T> {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"> <span class="hljs-keyword">private</span> entity: T </span>) {}

  <span class="hljs-keyword">public</span> getValueByName&#x3C;U <span class="hljs-keyword">extends</span> keyof T>( key: U ): T[ U ] {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.entity[ key ];
  }
}

<span class="hljs-keyword">interface</span> IAnimalModel {
  id: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> json = <span class="hljs-string">'"{"id": "animal", "age": 0}"'</span>;
<span class="hljs-keyword">let</span> entity: IAnimalModel = <span class="hljs-built_in">JSON</span>.parse(json);

<span class="hljs-keyword">let</span> userModel: Model&#x3C;IAnimalModel> = <span class="hljs-keyword">new</span> Model(entity);

<span class="hljs-keyword">let</span> id = userModel.getValueByName( <span class="hljs-string">'id'</span> ); <span class="hljs-comment">// id: string</span>
<span class="hljs-keyword">let</span> age = userModel.getValueByName( <span class="hljs-string">'age'</span> ); <span class="hljs-comment">// age: number</span></code></pre>
</section><section id="Sopostavlenie-tipov-Mapped-Types" name="Сопоставление типов (Mapped Types)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sopostavlenie-tipov-Mapped-Types" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сопоставление типов (Mapped Types)
            </h2>
        
<hr>
<p>Сопоставленные типы, это типы данных, которые при помощи механизма итерирования, модифицируют лежащие в основе конкретные типы данных.</p>
<p>В <code class="inline-code">TypeScript</code> существует возможность определения типа данных в качестве ключей которого выступает множество элементами которого являются литеральные строковые типы данных. в том числе и составляющие тип объединение (<code class="inline-code">Union</code>). Подобные типы обозначаются как <em>сопоставленные типы</em> данных (<code class="inline-code">Mapped Types</code>) и определяются исключительно на основе предоставляемой псевдонимами типов (<code class="inline-code">Type Alias</code>), объявление которых осуществляется при помощи ключевого слова <code class="inline-code">type</code>. Тело сопоставимого типа, заключенное в фигурные скобки <code class="inline-code">{}</code>, включает в себя одно единственное выражение состоящие из двух частей разделенное двоеточием. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> СопоставимыйТип = {
  ЛеваяЧастьВыражения : ПраваяЧастьВырыжения;
}</code></pre>
<p>В левой части выражения распологается другое, обрамленное в квадратные скобки <code class="inline-code">[]</code>, выражение предназначенное для работы с множеством, а в правой части определяется произвольный тип данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> СопоставимыйТип = {
  [ВыражениеДляРаботыСМножеством] : ПроизвольныйТипДанных;
}</code></pre>
<p>Выражение для работы с множеством определяет механизм предназначенный для итерирования элементами этого множества и также состоит из двух частей разделенных опратором <code class="inline-code">in</code> (<code class="inline-code">[ЛевыйОперанд in ПравыйОпернад]</code>). В качестве левого операнда указывается произвольный идентификатор, которому в процессе итерирования элементами множества, указанного в качестве правого операнда, последовательно будет присвоено их строковое представление (<code class="inline-code">[ПроизвольныйИдентификатор in Множество]</code>). </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> СопоставимыйТип = {
  [ПроизвольныйИдентификатор <span class="hljs-keyword">in</span> Множество] : ПроизвольныйТипДанных;
}</code></pre>
<p>Как уже было сказанно в роли идентификатора может выступать любой идентификатор.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> СопоставимыйТип = {
  [Key <span class="hljs-keyword">in</span> Множество] : ПроизвольныйТипДанных;
}

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">type</span> СопоставимыйТип = {
  [K <span class="hljs-keyword">in</span> Множество] : ПроизвольныйТипДанных;
}</code></pre>
<p>Множеств может быть определенно как единственнным литеральным строковым типом (<code class="inline-code">"ElementLeteralStringType"</code>), так и его множеством составляющим тип объединение (<code class="inline-code">Union Type</code>) (<code class="inline-code">"FirstElementLeteralStringType" | "SecondElementLeteralStringType"</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// множество с одним элементом</span>
<span class="hljs-keyword">type</span> СопоставимыйТип = {
  [K <span class="hljs-keyword">in</span> <span class="hljs-string">"FirstLiteralStringType"</span>] : ПроизвольныйТипДанных;
}

<span class="hljs-comment">// or </span>

<span class="hljs-comment">// множество с несколькими элементами</span>
<span class="hljs-keyword">type</span> СопоставимыйТип = {
  [K <span class="hljs-keyword">in</span> <span class="hljs-string">"FirstLiteralStringType"</span> | <span class="hljs-string">"SecondLiteralStringType"</span>] : ПроизвольныйТипДанных;
}

<span class="hljs-comment">// or </span>


<span class="hljs-keyword">type</span> LiteralStringType = <span class="hljs-string">"FirstLiteralStringType"</span> | <span class="hljs-string">"SecondLiteralStringType"</span>;

<span class="hljs-comment">// множество с несколькими элементами вынесенных в тип Union</span>
<span class="hljs-keyword">type</span> СопоставимыйТип = {
  [K <span class="hljs-keyword">in</span> LiteralStringType] : ПроизвольныйТипДанных;
}</code></pre>
<p>Результатом определения сопоставленного типа является объектный тип состоящий из ключей (строковых представлением элементов множества) ассоциированных с произвольным типом.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ABC = <span class="hljs-string">"a"</span> | <span class="hljs-string">"b"</span> | <span class="hljs-string">"c"</span>;

<span class="hljs-keyword">type</span> ABCWithString = {
  [K <span class="hljs-keyword">in</span> ABC]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">type</span> ABCWithNumber = {
  [K <span class="hljs-keyword">in</span> ABC]: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abcWithString</span>(<span class="hljs-params">params: ABCWithString</span>): <span class="hljs-title">void</span></span>;


abcWithString({a: <span class="hljs-string">''</span>, b: <span class="hljs-string">''</span>, c: <span class="hljs-string">''</span>}); <span class="hljs-comment">// Ok</span>
abcWithString({}); <span class="hljs-comment">// Error, missing properties 'a', 'b', 'c'</span>
abcWithString({a: <span class="hljs-string">''</span>, b: <span class="hljs-string">''</span>}); <span class="hljs-comment">// Error, missing property 'c'</span>
abcWithString({a: <span class="hljs-string">''</span>, b: <span class="hljs-string">''</span>, c: <span class="hljs-number">5</span>}); <span class="hljs-comment">// Error, type number is not type string</span>


<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abcWithNumber</span>(<span class="hljs-params">params: ABCWithNumber</span>): <span class="hljs-title">void</span></span>;

abcWithNumber({a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span>, c: <span class="hljs-number">0</span>}); <span class="hljs-comment">// Ok</span>
abcWithNumber({}); <span class="hljs-comment">// Error, missing properties 'a', 'b', 'c'</span>
abcWithNumber({a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span>}); <span class="hljs-comment">// Error, missing property 'c'</span>
abcWithNumber({a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span>, c: <span class="hljs-string">''</span>}); <span class="hljs-comment">// Error, type string is not type number</span></code></pre>
<p>От статического указания итерируемого типа мало пользы, поэтому <code class="inline-code">Mapped Types</code> лучше всего расскрывают свой потенциал при совместной работе с известными к этому моменту такими механизмами, как запрос ключей (<code class="inline-code">keyof</code>) и поиск типов (<code class="inline-code">Lookup Types</code>) опирирующих параметрами типа (<code class="inline-code">Generics</code>) </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> MappedType&#x3C;T> = {
  [K <span class="hljs-keyword">in</span> keyof T]: T[ K ];
}

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">type</span> MappedType&#x3C;T, U <span class="hljs-keyword">extends</span> keyof T> = {
  [K <span class="hljs-keyword">in</span> U]: T[ K ];
}</code></pre>
<p>В первом случае в выражении <code class="inline-code">[P in keyof T]: T[ P ];</code> первым действием выполняется вычисления оператора <code class="inline-code">keyof</code> над параметром типа <code class="inline-code">T</code>. В его результате ключи произвольного типа преобразуются во множество, то есть в тип <code class="inline-code">Union</code>, элементы которого принадлежать к литеральному строковому типу данных. Простыми словами операция <code class="inline-code">keyof T</code> заменяется на только что полученный тип <code class="inline-code">Union</code> <code class="inline-code">[P in Union]: T[ P ];</code>, над которым на следующим действии выполняется итерация.</p>
<p>Во втором случае <code class="inline-code">MappedType&#x3C;T, U extends keyof T></code> оператор <code class="inline-code">keyof</code> также приобразует параметр типа <code class="inline-code">T</code> в тип <code class="inline-code">Union</code>, который затем расширяет параметр типа <code class="inline-code">U</code>, тем самым получая все его признаки необходиме для итерации в выражении <code class="inline-code">[K in U]</code>.</p>
<p>С полученным в итерации <code class="inline-code">[K in U]</code> ключом <code class="inline-code">K</code> ассоциируется тип данных, который был ассоциирован с ним в исходным типе и который вычисляется с помощью механизма поиска типов <code class="inline-code">T[ K ]</code>. </p>
<p>Совокупность описанных механизмов позволяет создавать новый тип идентичный исходному, что при включении в условие определения <code class="inline-code">Mapped Type</code> модификаторв, как например <code class="inline-code">readonly</code> или <code class="inline-code">?:</code>, позволяет определять новые модифицирующие типы данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ReadonlyMember&#x3C;T> = {
  readonly [P <span class="hljs-keyword">in</span> keyof T]: T[ P ];
}

<span class="hljs-keyword">interface</span> IAnimal {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> animal: ReadonlyMember&#x3C;IAnimal>;  <span class="hljs-comment">// animal: { readonly name: string; readonly age: number; }</span></code></pre>
<p>Как уже было замечено, в правой части выражения можно указать любой тип данных, в том числе и объединенный тип, в состав которого войдет тип, полученный при помощи поиска типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Nullable&#x3C;T> = {
  [P <span class="hljs-keyword">in</span> keyof T]: T[ P ] | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">type</span> Stringify&#x3C;T> = {
  [P <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> IAnimal {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}


<span class="hljs-keyword">let</span> nullable: Nullable&#x3C;IAnimal>; <span class="hljs-comment">// { name: string | null; age: number | null; }</span>
<span class="hljs-keyword">let</span> stringify: Stringify&#x3C;IAnimal>; <span class="hljs-comment">// { name: string; age: string; }</span></code></pre>
<p>Сопоставленные типы не могут содержать более одной итерации в типе, и кроме того не могу содержать объявление других членов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AliasType&#x3C;T, U> = {
  [P <span class="hljs-keyword">in</span> keyof T]: T[ P ]; <span class="hljs-comment">// Ok</span>
  [V <span class="hljs-keyword">in</span> keyof U]: U[ V ]; <span class="hljs-comment">// Error</span>
  f1: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// Error</span>
}</code></pre>
<p>К тому же в <em>TypeScript</em> существует несколько готовых типов, таких как <code class="inline-code">Readonly&#x3C;T></code>, <code class="inline-code">Partial&#x3C;T></code>, <code class="inline-code">Record&#x3C;K, T></code> и <code class="inline-code">Pick&#x3C;T, K></code> (глава <a class="book__chapter__chapter-link" href="/book/contents/Rasshirennye-tipy-Readonly-Partial-Required-Pick-Record" title="Расширенные типы - Readonly, Partial, Required, Pick, Record" target="_blank">Расширенные типы - Readonly, Partial, Required, Pick, Record</a>).</p>
</section><section id="Prefiksy-i-v-sopostavlennyh-tipah" name="Префиксы + и - в сопоставленных типах" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Prefiksy-i-v-sopostavlennyh-tipah" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Префиксы + и - в сопоставленных типах
            </h2>
        
<hr>
<p>Сопоставленные типы позволяют добавлять модификаторы, но не позволяют их удалять, что в свою очередь имеет большое значение в случае с гомоморфными типами, которые по умолчанию сохраняют модификаторы своего базового типа (гомоморфные типы будут рассмотрены в главе <a class="book__chapter__chapter-link" href="/book/contents/Rasshirennye-tipy-Readonly-Partial-Required-Pick-Record" title="Расширенные типы - Readonly, Partial, Required, Pick, Record" target="_blank">Расширенные типы - Readonly, Partial, Required, Pick, Record</a>). </p>
<p>Для разрешения этого, к модификаторам, в типах сопоставления, были добавлены префиксы <code class="inline-code">+</code> и <code class="inline-code">-</code>, с помощью которых указывается поведение модификатора - добавить или удалить.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> AddModifier&#x3C;T> = { +readonly [P <span class="hljs-keyword">in</span> keyof T]+?: T[P] }; <span class="hljs-comment">// добавит модификаторы readonly и ? (optional)</span>
<span class="hljs-keyword">type</span> RemoveModoifier&#x3C;T> = { -readonly [P <span class="hljs-keyword">in</span> keyof T]-?: T[P] }; <span class="hljs-comment">// удалит модификаторы readonly и ? (optional)</span>


<span class="hljs-keyword">interface</span> IWithoutModifier { field: <span class="hljs-built_in">string</span>; }
<span class="hljs-keyword">interface</span> IWithModifier { readonly field?: <span class="hljs-built_in">string</span>; }


<span class="hljs-comment">/**
 * Добавление модификаторов
 * было { field: string; }
 * стало { readonly field?: string; }
 */</span>
<span class="hljs-keyword">let</span> addingModifier: AddModifier&#x3C;IWithoutModifier> = {field: <span class="hljs-string">''</span>};
<span class="hljs-keyword">let</span> withoutModifier: IWithoutModifier = {field: <span class="hljs-string">''</span>};

addingModifier.field = <span class="hljs-string">''</span>; <span class="hljs-comment">// Error</span>
withoutModifier.field = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>

<span class="hljs-comment">/**
 * Удаление модификаторов
 * было { readonly field?: string; }
 * стало { field: string; }
 */</span>
<span class="hljs-keyword">let</span> removingModifier: RemoveModoifier&#x3C;IWithModifier> = {field: <span class="hljs-string">''</span>};
<span class="hljs-keyword">let</span> withModifier: IWithModifier = {field: <span class="hljs-string">''</span>};

removingModifier.field = <span class="hljs-string">''</span>; <span class="hljs-comment">// Ok</span>
withModifier.field = <span class="hljs-string">''</span>; <span class="hljs-comment">// Error</span></code></pre>
</section>