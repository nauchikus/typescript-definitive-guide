<h1>Аннотация Типов</h1>
<p>Чтобы избавится от страха возникающего от слова <em>типизация</em> необходимо в самом начале увидеть все преобразования которые проделал <em>TypeScript</em> над своим фундаментом коим для него является, никого не оставляющий равнодушным <em>JavaScript</em>.</p><section id="Annotaciya-Tipov-obshchee" name="Аннотация Типов - общее" class="subchapter">

            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Annotaciya-Tipov-obshchee" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Аннотация Типов - общее
            </h2>
        
<hr>
<p>Как уже было сказано ранее, <em>TypeScript</em> — это типизированная надстройка над <em>JavaScript</em>. Другими словами <em>TypeScript</em> не добавляет никаких новых языковых конструкций (за исключением <code class="inline-code">Enum</code>, которая будет рассмотрена чуть позже), а лишь расширяет синтаксис <em>JavaScript</em> за счет добавления в него типов. По этой причине в этой книге не будут затрагиваться темы относящиеся к <em>JavaScript</em>, так как она рассчитана на тех, кто уже знаком с его основами. Именно поэтому погружение в типизированный мир <em>TypeScript</em> необходимо начать с рассмотрения того как типизация преобразила <em>JavaScript</em> конструкции.</p>
</section><section id="Annotaciya-tipa" name="Аннотация типа" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Annotaciya-tipa" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Аннотация типа
            </h2>
        
<p>В <em>TypeScript</em> аннотация типа или указание типа осуществляется с помощью оператора двоеточия <code class="inline-code">:</code>, после которого следует идентификатор типа. <em>TypeScript</em> является статически типизированным языком, поэтому после того как идентификатор будет связан с типом, изменить тип будет невозможно.</p>
</section><section id="Sintaksicheskie-konstrukcii-var-let-const" name="Синтаксические конструкции var, let, const" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sintaksicheskie-konstrukcii-var-let-const" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Синтаксические конструкции var, let, const
            </h2>
        
<hr>
<p>При объявлении синтаксических конструкций объявляемых с помощью операторов <code class="inline-code">var</code>, <code class="inline-code">let</code> и <code class="inline-code">const</code>, тип данных указывается сразу после идентификатора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> identifier: Type = value;
<span class="hljs-keyword">let</span> identifier: Type = value;
<span class="hljs-keyword">const</span> IDENTIFIER: Type = value;</code></pre>
</section><section id="Funkcii-function" name="Функции (function)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Funkcii-function" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Функции (function)
            </h2>
        
<hr>
<p>При объявлении функции тип возвращаемого ею значения указывается между её параметрами и телом. При наличии параметров, тип данных указывается и для них.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1: Type, param2: Type</span>): <span class="hljs-title">ReturnedType</span> </span>{

}</code></pre>
<p>Не будет лишним напомнить, что, в отличие от <em>JavaScript</em>, в <em>TypeScript</em> в сигнатуру функции помимо её имени и параметров также входит и возвращаемое значение.</p>
<p>Помимо этого, в <em>TypeScript</em> можно объявлять параметризированные функции. Функции, имеющие параметры типа, называются обобщенными (подробнее о них речь пойдет в главе <a class="book__chapter__chapter-link" href="https://nauchikus.github.io/typescript-definitive-guide/book/contents/Tipy-Obobshcheniya-Generics" title="Типы - Обобщения (Generics)" target="_blank">Типы - Обобщения (Generics)</a>. Параметры типа заключаются в угловые скобки <code class="inline-code">&#x3C;></code> и располагаются перед круглыми скобками <code class="inline-code">()</code>, в которые заключены параметры функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span> &#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params"></span>): <span class="hljs-title">ReturnedType</span> </span>{

}</code></pre>
<p>Кроме того <em>TypeScript</em> расширяет границы типизирования функций и методов с помощью незнакомого  <em>JavaScript</em> разработчикам механизма <em>перегрузки функций</em>. С помощью перегрузки функций можно аннотировать функции с одинаковыми идентификаторами, но с различными сигнатурами.</p>
<p>Для этого перед определением функции, метода или функции-конструктора перечисляются совместимые объявления одних только сигнатур. Более подробно эта тема будет освещена позднее.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1, p2: T2</span>): <span class="hljs-title">T3</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T4, p2: T5</span>): <span class="hljs-title">T6</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T, p2: T</span>): <span class="hljs-title">T</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'value'</span>;
}

<span class="hljs-keyword">const</span> a: T1 = <span class="hljs-string">'value'</span>;
<span class="hljs-keyword">const</span> b: T2 = <span class="hljs-string">'value'</span>;
<span class="hljs-keyword">const</span> c: T4 = <span class="hljs-string">'value'</span>;
<span class="hljs-keyword">const</span> d: T5 = <span class="hljs-string">'value'</span>;

identifier(a, b); <span class="hljs-comment">// валидно</span>
identifier(c, d); <span class="hljs-comment">// валидно</span>

<span class="hljs-keyword">class</span> Identifier {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T1, p2: T2</span>);
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T3, p2: T4</span>);
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T, p2: T</span>) {
    
    }
    
    identifier(<span class="hljs-params">p1: T1, p2: T2</span>): T3;
    identifier(<span class="hljs-params">p1: T4, p2: T5</span>): T6;
    identifier(<span class="hljs-params">p1: T, p2: T</span>): T {
        return 'value';
    }
}</code></pre>
</section><section id="Strelochnye-Funkcii-arrow-function" name="Стрелочные Функции (arrow function)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Strelochnye-Funkcii-arrow-function" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Стрелочные Функции (arrow function)
            </h2>
        
<hr>
<p>К стрелочным функциям применимы те же правила указания типов данных, что и для обычных функций, за исключением того, что возвращаемый ими тип указывается между параметрами и стрелкой.</p>
<pre><code class="hljs language-typescript">&#x3C;T, U>(param: Type, param2: Type): <span class="hljs-function"><span class="hljs-params">Type</span> =></span> value;</code></pre>
</section><section id="Klassy-class" name="Классы (class)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Klassy-class" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Классы (class)
            </h2>
        
<hr>
<p>Прежде чем продолжить рассмотрение изменений которые привнёс <em>TypeScript</em> в нетипизированный мир <em>JavaScript</em>, хотелось бы предупредить о том, что относительно классов будет использоваться терминология заимствованная из таких языков, как <em>Java</em> или <em>C#</em>, так как она способствует большей ясности (тем более, что в спецификации <em>TypeScript</em> встречается аналогичная терминология). Так, <em>переменные экземпляра</em> и <em>переменные класса</em> (статические переменные) в этой книге обозначаются как <em>поля</em> (<em>field</em>). <em>Аксессоры</em> (<em>get</em>_set<em>) обозначаются как </em>свойства<em> (_property</em>). А кроме того, поля, свойства, методы, <em>вычисляемые свойства</em> (<em>computed property</em>) и <em>индексируемые сигнатуры</em> (<em>index signature</em>) обозначаются как <em>члены</em> класса (<em>member</em>). </p>
<p>При объявлении поля класса, как и в случае с переменными, тип данных указывается сразу после идентификатора (имени класса). Для методов класса действуют те же правила указания типов что и для обычных функций.</p>
<p>Для свойств, в частности для <code class="inline-code">get</code>, указывается тип данных возвращаемого значения. Для <code class="inline-code">set</code> указывается лишь тип единственного параметра, а возвращаемый им тип и вовсе запрещается указывать явно.</p>
<p>Кроме того, классы в <em>TypeScript</em> также могут быть обобщенными. В случае объявления обобщенного класса, параметры типа, заключенные в треугольные скобки, указываются сразу после идентификатора класса.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Identifier&#x3C;T> {
    <span class="hljs-keyword">static</span> staticField: Type = value; <span class="hljs-comment">// член класса</span>
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty(): Type { <span class="hljs-comment">// член класса</span>
        <span class="hljs-keyword">return</span> value;
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value: Type) { <span class="hljs-comment">// член класса</span>
     
    }
    
    <span class="hljs-keyword">static</span> staticMethod &#x3C;T, U>(param0: Type, param1: Type): Type { <span class="hljs-comment">// член класса</span>
    
    }

    [indexSignature: Type]: Type; <span class="hljs-comment">// член класса</span>
    
    [computedProp]: Type = value; <span class="hljs-comment">// член класса</span>
    
    field: Type = value; <span class="hljs-comment">// член класса</span>
    
    <span class="hljs-keyword">get</span> property(): Type { <span class="hljs-comment">// член класса</span>
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-keyword">set</span> property(value: Type) { <span class="hljs-comment">// член класса</span>
     
    }
    
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0: Type, param1: Type</span>) {
    
    }
    
    method &#x3C;T, U>(param0: Type, param1: Type): Type { <span class="hljs-comment">// член класса</span>
    
    }
}</code></pre>
</section><section id="Sravnenie-Sintaksisa-TypeScript-i-JavaScript" name="Сравнение Синтаксиса TypeScript и JavaScript" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sravnenie-Sintaksisa-TypeScript-i-JavaScript" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сравнение Синтаксиса TypeScript и JavaScript
            </h2>
        
<hr>
<p>Перед тем, как подвести итоги этой главы, не будет лишним собрать все рассмотренные <em>TypeScript</em> конструкции и наглядно сравнить их со своими нетипизированными <em>JavaScript</em> аналогами.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// .ts</span>
<span class="hljs-keyword">var</span> identifier: Type = value;
<span class="hljs-keyword">let</span> identifier: Type = value;
<span class="hljs-keyword">const</span> IDENTIFIER: Type = value;
<span class="hljs-comment">//  .js</span>
<span class="hljs-keyword">var</span> identifier = value;
<span class="hljs-keyword">let</span> identifier = value;
<span class="hljs-keyword">const</span> IDENTIFIER = value;

<span class="hljs-comment">// .ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1: Type, param2: Type</span>): <span class="hljs-title">ReturnedType</span> </span>{

}

<span class="hljs-comment">// .js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1, param2</span>) </span>{

}

<span class="hljs-comment">// .ts</span>
<span class="hljs-keyword">class</span> Identifier&#x3C;T> {
    <span class="hljs-keyword">static</span> staticField: Type = value; 
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty(): Type {
        <span class="hljs-keyword">return</span> value;
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value: Type) {
     
    }
    
    <span class="hljs-keyword">static</span> staticMethod &#x3C;T, U>(param0: Type, param1: Type): Type {
    
    }
    
    [indexSignature: Type]: Type; 
    
    [computedProp]: Type = value; 
    
    field: Type = value;
    
    <span class="hljs-keyword">get</span> property(): Type {
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-keyword">set</span> property(value: Type) {
     
    }
    
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0: Type, param1: Type</span>) {
    
    }
    
    method &#x3C;T, U>(param0: Type, param1: Type): Type {
    
    }
}

<span class="hljs-comment">// .js</span>
<span class="hljs-keyword">class</span> Identifier {
    <span class="hljs-keyword">static</span> staticField = value; 
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty() {
        <span class="hljs-keyword">return</span> value;
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value) {
     
    }
    
    <span class="hljs-keyword">static</span> staticMethod (param, param) {
    
    }
    
    [computedProp] = value; 
    
    field = value;
    
    <span class="hljs-keyword">get</span> property() {
        <span class="hljs-keyword">return</span> value;
    }
    
    <span class="hljs-keyword">set</span> property(value) {
     
    }
    
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0, param1</span>) {
    
    }
    
    method (param0, param1) {
    
    }
}</code></pre>
</section><section id="Itog" name="Итог" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itog" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итог
            </h2>
        
<ul class="book__list">
<li class="book__list__item">Аннотация типа устанавливается оператором двоеточия <code class="inline-code">:</code>, после которого следует указание типа данных.</li>
<li class="book__list__item">При объявлении переменных тип данных указывается сразу после идентификатора.</li>
<li class="book__list__item">У функций и методов класса возвращаемый тип данных указывается между параметрами и телом.</li>
<li class="book__list__item">У стрелочных функций возвращаемый тип данных указывается между параметрами и стрелкой.</li>
<li class="book__list__item">У функций, стрелочных функций и методов класса, параметрам также указывается тип данных.</li>
<li class="book__list__item">При необходимости функциям, стрелочным функциям и методам класса можно указать параметры типа, которые заключаются в угловые скобки и указываются перед круглыми скобками, в которых размещаются параметры функции.</li>
<li class="book__list__item">В <em>TypeScript</em> аннотирование типов у функций, методов и конструкторов расширено при помощи перегрузки функций.</li>
<li class="book__list__item">Для полей класса тип данных указывается сразу после идентификатора-имени.</li>
<li class="book__list__item">Для геттеров (getters) указывается возвращаемый тип данных.</li>
<li class="book__list__item">Для сеттеров (setters) указывается тип единственного параметра и вовсе не указывается возвращаемый тип.</li>
</ul>
</section>