<section id="Annotaciya-Tipov" name="Аннотация Типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Annotaciya-Tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Аннотация Типов
            </h2>
        
<hr>
<p>Как уже было сказано ранее, <em>TypeScript</em>, это типизированная надстройка над <em>JavaScript</em>. Другими словами, <em>TypeScript</em> не добавляет никаких новых языковых конструкций  (исключением можно назвать конструкцию <code class="inline-code">Enum</code>, который будет рассмотрен чуть позже), а лишь расширяет синтаксис <em>JavaScript</em> при помощи добавления в него типов. По этой причине в этой книге не будут затрагиваться темы, относящиеся к <em>JavaScript</em>, так как она рассчитана на тех, кто уже знаком с его основами. </p>
<p>И прежде чем начать погружение в систему типов <em>TypeScript</em>, нужно рассмотреть такое важное понятие, как указание типа данных, для всех существующих в <em>JavaScript</em> языковых конструкций.</p>
<p>Идеология типизированных языков, определяет правила, по которым указывать типы нужно везде, где это предусмотрено. В <em>TypeScript</em> аннотация типа или указание типа осуществляется с помощью оператора двоеточия <code class="inline-code">:</code> после которого следует идентификатор типа данных. <em>TypeScript</em> является статически типизированным языком, поэтому после того, как идентификатор будет связан с типом, изменить тип будет невозможно.</p>
</section><section id="Sintaksicheskie-konstrukcii-var-let-const" name="Синтаксические конструкции var, let, const" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sintaksicheskie-konstrukcii-var-let-const" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Синтаксические конструкции var, let, const
            </h2>
        
<hr>
<p>При объявлении синтаксических конструкций, объявляемых с помощью операторов <code class="inline-code">var</code>, <code class="inline-code">let</code> и <code class="inline-code">const</code> тип данных указывается сразу после идентификатора.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">var</span> identifier: Type = value;
<span class="hljs-keyword">let</span> identifier: Type = value;
<span class="hljs-keyword">const</span> IDENTIFIER: Type = value;</code></pre>
</section><section id="Funkcii-function" name="Функции (function)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Funkcii-function" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Функции (function)
            </h2>
        
<hr>
<p>При объявлении функции, между её параметрами и телом, указывается тип возвращаемого ею значения. При наличии параметров, тип данных указывается и для них.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1: Type, param2: Type</span>): <span class="hljs-title">ReturnedType</span> </span>{}</code></pre>
<p>Не будет лишнем напомнить, что в отличии от <em>JavaScript</em>, в <em>TypeScript</em>, в сигнатуру функции помимо её имени и параметров, также входит и возвращаемое значение.</p>
<p>Помимо этого, в <em>TypeScript</em> можно объявлять параметризированные функции. Функции имеющие параметры типа называются обобщенными (подробнее о них речь пойдет в главе <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Obobshcheniya-Generics" title="Типы - Обобщения (Generics)" target="_blank">Типы - Обобщения (Generics)</a>. Параметры типа заключаются в угловые скобки <code class="inline-code">&#x3C;></code> и располагаются перед круглыми скобками <code class="inline-code">()</code>, в которые заключены параметры функции.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span> &#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params"></span>): <span class="hljs-title">ReturnedType</span> </span>{}</code></pre>
<p><em>TypeScript</em> расширяет границы типизации функций и методов таким новым для <em>JavaScript</em> понятием, как перегрузка функций. С помощью перегрузки функций, можно аннотировать функции с одинаковыми идентификаторами, но с различными сигнатурами.</p>
<p>Для этого в первую очередь аннотироют сигнатуры функций, методов или конструкторов, которые не содержат тела.В последнюю очередь объявляют функцию, сигнатура которой совместима со всеми ранее аннотированными версиями.Более подробно эта тема будет освещена позднее.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T1, p2: T2</span>): <span class="hljs-title">T3</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T4, p2: T5</span>): <span class="hljs-title">T6</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">p1: T, p2: T</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'value'</span>;
}

<span class="hljs-keyword">class</span> Identifier {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T1, p2: T2</span>);
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T3, p2: T4</span>);
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">p1: T, p2: T</span>) {}

  identifier(<span class="hljs-params">p1: T1, p2: T2</span>): T3
  identifier(<span class="hljs-params">p1: T4, p2: T5</span>): T6;
  identifier(<span class="hljs-params">p1: T, p2: T</span>): T {
      return 'value';
  }
}</code></pre>
</section><section id="Strelochnye-Funkcii-arrow-function" name="Стрелочные Функции (arrow function)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Strelochnye-Funkcii-arrow-function" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Стрелочные Функции (arrow function)
            </h2>
        
<hr>
<p>К стрелочным функциям применимы те же правила указания типов данных, что и для обычных функций, за исключением того, что возвращаемый ими тип указывается между параметрами и стрелкой.</p>
<pre><code class="hljs language-typescript">&#x3C;T, U>( param: Type, param: Type ): <span class="hljs-function"><span class="hljs-params">Type</span> =></span> value</code></pre>
</section><section id="Klassy-class" name="Классы (class)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Klassy-class" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Классы (class)
            </h2>
        
<hr>
<p>Прежде чем продолжить рассмотрение изменений, которые привнес <em>TypeScript</em> в нетипизированный мир <em>JavaScript</em>, хочу предупредить о том, что относительно классов будет использоваться терминология заимствованная из таких языков, как <em>Java</em> или <em>C#</em>, так как она добавляет большей ясности (тем более, что в спецификации <em>TypeScript</em> встречается подобная терминология). Так, <em>переменные экземпляра</em> и <em>переменные класса</em> (статические переменные) в этой книге обозначаются как <em>поля</em> (field). <em>Аксессоры</em> (get, set), обозначаются как <em>свойства</em> (property). А кроме того, поля, свойства, методы, <em>вычисляемые свойства</em> (computed property) и <em>индексируемые сигнатуры</em> (index signature) обозначаются как <em>члены</em> класса (member). </p>
<p>При объявлении поля класса, как и в случае с переменными, тип данных указывается сразу после идентификатора (имени класса). Для методов класса действуют те же правила указания типов данных, что и для обычных функций.</p>
<p>Для свойств, в частности для <code class="inline-code">get</code> указывается тип данных возвращаемого значения. Для <code class="inline-code">set</code> указывается лишь тип единственного  параметра, а возвращаемый им тип и вовсе запрещается указывать явно.</p>
<p>Кроме того, классы в <em>TypeScript</em> также могут быть обобщенными. В случае объявления обобщенного класса, параметры типа, заключенные в треугольные скобки, указываются сразу после идентификатора класса.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Identifier&#x3C;T> {
  <span class="hljs-keyword">static</span> staticField: Type = value; <span class="hljs-comment">// member</span>
  
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty(): Type { <span class="hljs-comment">// member</span>
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value: Type) { <span class="hljs-comment">// member</span>
     
  }

  <span class="hljs-keyword">static</span> staticMethod &#x3C;T, U>(param: Type, param: Type): Type { } <span class="hljs-comment">// member</span>

  [indexSignature: Type]: Type; <span class="hljs-comment">// member</span>

  [computedProp]: Type = value; <span class="hljs-comment">// member</span>

  field: Type = value; <span class="hljs-comment">// member</span>

  <span class="hljs-keyword">get</span> property(): Type { <span class="hljs-comment">// member</span>
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">set</span> property(value: Type) { <span class="hljs-comment">// member</span>
     
  }

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0: Type, param1: Type</span>){}

  method &#x3C;T, U>(param: Type, param: Type): Type { } <span class="hljs-comment">// member</span>
}</code></pre>
</section><section id="Sravnenie-Sintaksisa-TypeScript-i-JavaScript" name="Сравнение Синтаксиса TypeScript и JavaScript" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Sravnenie-Sintaksisa-TypeScript-i-JavaScript" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Сравнение Синтаксиса TypeScript и JavaScript
            </h2>
        
<hr>
<p>Перед тем, как подвести итоги этой главы, не будет лишним собрать обсуждаемое здесь в одном <em>TypeScript</em> коде и сравнить его с аналогичным кодом написанным на <em>JavaScript</em>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// .ts</span>
<span class="hljs-keyword">var</span> identifier: Type = value;
<span class="hljs-keyword">let</span> identifier: Type = value;
<span class="hljs-keyword">const</span> IDENTIFIER: Type = value;
<span class="hljs-comment">//  .js</span>
<span class="hljs-keyword">var</span> identifier = value;
<span class="hljs-keyword">let</span> identifier= value;
<span class="hljs-keyword">const</span> IDENTIFIER = value;

<span class="hljs-comment">// .ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1: Type, param2: Type</span>): <span class="hljs-title">ReturnedType</span> </span>{}

<span class="hljs-comment">// .js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identifier</span>(<span class="hljs-params">param1, param2</span>) </span>{}

<span class="hljs-comment">// .ts</span>
<span class="hljs-keyword">class</span> Identifier&#x3C;T> {
  <span class="hljs-keyword">static</span> staticField: Type = value; 
  
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty(): Type {
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value: Type) {
     
  }

  <span class="hljs-keyword">static</span> staticMethod &#x3C;T, U>(param: Type, param: Type): Type { }

  [indexSignature: Type]: Type; 

  [computedProp]: Type = value; 

  field: Type = value;

  <span class="hljs-keyword">get</span> property(): Type {
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">set</span> property(value: Type) {
     
  }

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0: Type, param1: Type</span>){}

  method &#x3C;T, U>(param: Type, param: Type): Type { }
}

<span class="hljs-comment">// .js</span>
<span class="hljs-keyword">class</span> Identifier {
  <span class="hljs-keyword">static</span> staticField = value; 
  
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> staticProperty() {
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">set</span> staticProperty(value) {
     
  }

  <span class="hljs-keyword">static</span> staticMethod (param, param) { }

  [computedProp] = value; 

  field = value;

  <span class="hljs-keyword">get</span> property() {
      <span class="hljs-keyword">return</span> value;
  }
  <span class="hljs-keyword">set</span> property(value) {
     
  }

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">param0, param1</span>){}

  method (param, param){ }
}</code></pre>
</section><section id="Itog" name="Итог" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Itog" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Итог
            </h2>
        
<p>Подведем итоги - </p>
<ul class="book__list">
<li class="book__list__item">Аннотация типа устанавливается оператором двоеточия : после которого следует указание типа данных.</li>
<li class="book__list__item">При объявлении переменных тип данных указывается сразу после идентификатора.</li>
<li class="book__list__item">У функций и методов класса возвращаемый тип данных указывается между параметрами и телом.</li>
<li class="book__list__item">У стрелочных функций возвращаемый тип данных указывается между параметрами и стрелкой.</li>
<li class="book__list__item">У функций, стрелочных функций и методов класса, параметрам также указывается тип данных.</li>
<li class="book__list__item">При необходимости функциям, стрелочным функциям и методам класса можно указать параметры типа, которые заключаются в угловые скобки и указываются перед круглыми скобками, в которых размещаются параметры функции.</li>
<li class="book__list__item">В <em>TypeScript</em>, аннотирование типов у функций, методов и конструкторов, расширено при помощи перегрузки функций.</li>
<li class="book__list__item">Полям класса, тип данных указывается сразу после идентификатора-имени.</li>
<li class="book__list__item">Для геттеров (getters) указывается возвращаемый тип данных.</li>
<li class="book__list__item">Для сеттеров (setters) указывается тип единственного параметра и вовсе не указывается  возвращаемый тип.</li>
</ul>
</section>