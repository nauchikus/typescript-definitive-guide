<section id="Tipizaciya-Vyvod-tipov" name="Типизация - Вывод типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Tipizaciya-Vyvod-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Типизация - Вывод типов
            </h2>
        
<hr>
<p>Чтобы не повторять определения, которые были даны в главе <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Svyazyvanie-tipizaciya-vyvod-tipov" title="Экскурс в типизацию - Связывание, типизация, вывод типов">Экскурс в типизацию - Связывание, типизация, вывод типов</a>, эту главу стоит начать с неформально определения. </p>
<p><em>Вывод типов</em> - это механизм, благодаря которому, разрабатывать на статически типизированном <em>TypeScript</em> становится намного легче. Он берет на себя ту работу, которая во многих случаях может показаться рутинной. Вывод типов работает не только тогда, когда вы не указывает тип явно, он работает всегда, когда компилятор встречает код. Дело в том, что компилятор не доверяет разработчику и поэтому весь код, в штатном режиме, проходит через вывод типов,    В этом механизме нет ничего сложного, но несмотря на это, у разработчиков, которые только приступают к изучению <em>TypeScript</em>, некоторые неочевидные особенности, могут вызвать вопросы, на которые и постарается ответить данная глава. Кроме того, основная цель этой главы раскрыть те моменты, рассказ о которых, в других частях книги, мог быть не ко времени, либо излишни усложнить понимание, поэтому те части книги просто ссылались на текущую главу. Но также в этой главе,  вкратце, будет повторено то, что уже было рассмотрено по ходу изложения материала.</p>
</section><section id="Vyvod-primitivnyh-tipov" name="Вывод примитивных типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vyvod-primitivnyh-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Вывод примитивных типов
            </h2>
        
<hr>
<p>Вывод типов для значение принадлежащих, к так называемым, примитивным типам, в большинстве случаев, не таит в себе ничего необычно. Кроме того, будь это переменные, поля, параметры, возвращаемые из функции и метода значения, результат во всех случаях будет идентичным. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Enums {
  Value
};

<span class="hljs-keyword">let</span> v0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// let v0: number</span>
<span class="hljs-keyword">let</span> v1 = <span class="hljs-string">'text'</span>; <span class="hljs-comment">// let v0: string</span>
<span class="hljs-keyword">let</span> v2 = <span class="hljs-literal">true</span>; <span class="hljs-comment">// let v0: boolean</span>
<span class="hljs-keyword">let</span> v3 = Symbol(); <span class="hljs-comment">// let v3: symbol</span>
<span class="hljs-keyword">let</span> v4 = Enums.Value; <span class="hljs-comment">// let v4: Enums</span></code></pre>
</section><section id="Vyvod-primitivnyh-tipov-dlya-konstant-const-i-polei-tolko-dlya-chteniya-readonly" name="Вывод примитивных типов для констант (const) и полей только для чтения (readonly)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vyvod-primitivnyh-tipov-dlya-konstant-const-i-polei-tolko-dlya-chteniya-readonly" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Вывод примитивных типов для констант (const) и полей только для чтения (readonly)
            </h2>
        
<hr>
<p>Когда дело доходит до присваивания значений принадлежащих к примитивным типам, таким конструкциям, как константы (<code class="inline-code">const</code>) и неизменяемые поля (модификатор <code class="inline-code">readonly</code>), поведение вывода типов изменяется.</p>
<p>В случае, когда значение принадлежит к примитивным типам <code class="inline-code">number</code>, <code class="inline-code">string</code> или <code class="inline-code">boolean</code>, вывод типов указывает принадлежность к литеральным примитивным типам определяемых самим значением.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Enums {
  Value
};

<span class="hljs-keyword">const</span> v0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// let v0: 0</span>
<span class="hljs-keyword">const</span> v1 = <span class="hljs-string">'text'</span>; <span class="hljs-comment">// let v0: 'text'</span>
<span class="hljs-keyword">const</span> v2 = <span class="hljs-literal">true</span>; <span class="hljs-comment">// let v0: true</span>


<span class="hljs-keyword">class</span> Identifier {
  readonly f0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// f0: 0</span>
  readonly f1 = <span class="hljs-string">'text'</span>; <span class="hljs-comment">// f1: 'text'</span>
  readonly f2 = <span class="hljs-literal">true</span>;<span class="hljs-comment">// f2: true</span>
}</code></pre>
<p>Если значение принадлежит к типу enum, то вывод типов установит принадлежность к типу <code class="inline-code">enum</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">enum</span> Enums { Value };


<span class="hljs-keyword">const</span> v = Enums.Value; <span class="hljs-comment">// let v: Enums</span>


<span class="hljs-keyword">class</span> Identifier {
  readonly f = Enums.Value; <span class="hljs-comment">// f: Enums</span>
}</code></pre>
<p>Тогда, когда вывод типов встречает значение принадлежащие к типу <code class="inline-code">symbol</code>, то его поведение зависит от конструкции которой присваивается значение. Так, если вывод типов работает с константой, то тип определяется, как запрос типа (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Type-Queries-zaprosy-tipa-Alias-psevdonimy-tipa" title="Типы - Type Queries (запросы типа), Alias (псевдонимы типа)">Типы - Type Queries (запросы типа), Alias (псевдонимы типа)</a>) самой константы. Если же вывод типов устанавливает принадлежность к типу не изменяемому полю, то, тип будет определен, как <code class="inline-code">symbol</code>. Происходит так потому, что при создании каждого нового экземпляра в системе будет определяться и новый символ, что противоречит правилам установленным для <code class="inline-code">Unique Symbol</code> (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Primitivnye-literalnye-tipy-Number-String-Boolean-Unique-Symbol-Enum" title="Типы - Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum">Типы - Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum</a>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> v = Symbol(); <span class="hljs-comment">// let v: typeof v</span>


<span class="hljs-keyword">class</span> Identifier {
  readonly f = Symbol(); <span class="hljs-comment">// f: symbol</span>
}</code></pre>
</section><section id="Vyvod-obektnyh-tipov" name="Вывод объектных типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vyvod-obektnyh-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Вывод объектных типов
            </h2>
        
<hr>
<p>С выводом объектных типов не связанно ничего необычного.  Кроме того, поведение вывода типов одинаково для всех конструкций.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> ClassType {}
<span class="hljs-keyword">interface</span> InterfaceType {}

<span class="hljs-keyword">type</span> TypeAlias = <span class="hljs-built_in">number</span>;

<span class="hljs-keyword">let</span> typeIntreface: InterfaceType;
<span class="hljs-keyword">let</span> typeTypeAlias: TypeAlias;

<span class="hljs-keyword">let</span> v0 = {a: <span class="hljs-number">5</span>, b: <span class="hljs-string">'text'</span>, c: <span class="hljs-literal">true</span>}; <span class="hljs-comment">// let v0: {a:number, b:string, c: boolean}</span>
<span class="hljs-keyword">const</span> v1 = {a: <span class="hljs-number">5</span>, b: <span class="hljs-string">'text'</span>, c: <span class="hljs-literal">true</span>}; <span class="hljs-comment">// let v1: {a:number, b:string, c: boolean}</span>

<span class="hljs-keyword">let</span> v3 = <span class="hljs-keyword">new</span> ClassType(); <span class="hljs-comment">// let v3: ClassType</span>
<span class="hljs-keyword">let</span> v4 = typeIntreface; <span class="hljs-comment">// let v4: InterfaceType</span>
<span class="hljs-keyword">let</span> v5 = typeTypeAlias; <span class="hljs-comment">// let v5: number</span></code></pre>
</section><section id="Vyvod-obedinennyh-Union-tipov" name="Вывод объединенных (Union) типов" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vyvod-obedinennyh-Union-tipov" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Вывод объединенных (Union) типов
            </h2>
        
<hr>
<p>С выводом типов объединения (глава <a class="book__chapter__chapter-link" href="/book/contents/Tipy-Union-Intersection" title="Типы - Union, Intersection">Типы - Union, Intersection</a>) связаны, как очевидные, так и нет, случаи.</p>
<p>К очевидным случаям можно отнести массив, состоящий из разных примитивных типов. В таком случае будет выведен очевидный тип объединение, который составляют типы присутствующих в массиве примитивов.  </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v = [ <span class="hljs-number">0</span>, <span class="hljs-string">'text'</span>, <span class="hljs-literal">true</span> ]; <span class="hljs-comment">// let v: (string | number | boolean)[]</span></code></pre>
<p>В случае получения любого элемента массива, вывод типов, установит принадлежность также к объединенному типу.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v = [ <span class="hljs-number">0</span>, <span class="hljs-string">'text'</span>, <span class="hljs-literal">true</span> ]; <span class="hljs-comment">// let v: (string | number | boolean)[]</span>

<span class="hljs-keyword">let</span> item = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// let item: string | number | boolean</span></code></pre>
<p>Неочевидные особенности лучше всего начать с примера, в котором вывод типа определяет принадлежность к массиву обычных объектных типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v = [
  { a: <span class="hljs-number">5</span>, b: <span class="hljs-string">'text'</span> },
  { a: <span class="hljs-number">6</span>, b: <span class="hljs-string">'text'</span> }
]; <span class="hljs-comment">// let v: { a: number, b: string }[ ]</span></code></pre>
<p>В примере, вывод типов выводит ожидаемый и предсказуемый результат для массива объектов, чьи типы полностью идентичны. Идентичны они по той причине, что вывод типов установит тип <code class="inline-code">{a: number, b:string}</code> для всех элементов массива.</p>
<p>Но стоит изменить условие, допустим, убрать объявление одного поля и картина кардинально изменится. Вместо массива обычных объектов, тип будет выведен, как массив объединенного типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v = [
  { a: <span class="hljs-number">5</span>, b: <span class="hljs-string">'text'</span> },
  { a: <span class="hljs-number">6</span> },
  { a: <span class="hljs-number">7</span>, b: <span class="hljs-literal">true</span> }
]; <span class="hljs-comment">// let v: ( { a: number, b: number } | { a: number, b?: undefined } | { a: number, b: boolean } )[ ]</span></code></pre>
<p>Как видно из примера выше, вывод типов приводит все объектные типы, составляющие тип объединение, к единому виду. Он добавляет к типам не существующие в них, но существующие в других объектных типах, поля, декларируя их как необязательные (глава  <a class="book__chapter__chapter-link" href="/book/contents/Operatory-Optional-Not-Null-Not-Undefined-Definite-Assignment-Assertion" title="Операторы - Optional, Not-Null, Not-Undefined, Definite Assignment Assertion">Операторы - Optional, Not-Null, Not-Undefined, Definite Assignment Assertion</a>). Сделано это для того, чтобы можно было конкретизировать тип любого элемента массива. Простыми словами, чтобы не получить ошибку во время выполнения, любой элемент массива должен иметь общие, для всех элементов, признаки. Но так как в реальности в объектах некоторые члены вовсе могут отсутствовать, вывод типов, чтобы повысить типобезопасность, декларирует их, как необязательные. Таким образом, он предупреждает разработчика, о возможности возникновения ситуации, при которой эти члены будут иметь значение <code class="inline-code">undefined</code>, что и демонстрируется в примере ниже.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v = [
  { a: <span class="hljs-number">5</span>, b: <span class="hljs-string">'text'</span> },
  { a: <span class="hljs-number">6</span> },
  { a: <span class="hljs-number">7</span>, b: <span class="hljs-literal">true</span> }
]; <span class="hljs-comment">// let v: ( { a: number, b: number } | { a: number, b?: undefined } | { a: number, b: boolean } )[ ]</span>

<span class="hljs-keyword">let</span> a = v[<span class="hljs-number">0</span>].a; <span class="hljs-comment">// let a: number</span>
<span class="hljs-keyword">let</span> b = v[<span class="hljs-number">0</span>].b; <span class="hljs-comment">// let b: string | boolean | undefined</span></code></pre>
<p>Если в качестве значений элементов массива выступают экземпляры классов  не связанных отношением наследования, то объединенные типы будут составлять их типы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A {
   <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">class</span> B {
   <span class="hljs-keyword">public</span> a: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
   <span class="hljs-keyword">public</span> b: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;
}


<span class="hljs-keyword">let</span> v = [
   <span class="hljs-keyword">new</span> A(),
   <span class="hljs-keyword">new</span> B()
]; <span class="hljs-comment">// let v: ( A | B )[ ]</span></code></pre>
<p>В случае, если элементы массива являются экземплярами классов связанных отношением наследования (<em>номинативная типизация</em> <a class="book__chapter__chapter-link" href="/book/contents/Ekskurs-v-tipizaciu-Sovmestimost-tipov-na-osnove-vida-tipizacii" title="Экскурс в типизацию - Совместимость типов на основе вида типизации">Экскурс в типизацию - Совместимость типов на основе вида типизации</a>), то выводимый тип будет ограничен максимально базовым из типом участвующем в операции выводе.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A {}
<span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A { f0 = <span class="hljs-number">0</span>; }
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A { f1 = <span class="hljs-string">''</span>; }
<span class="hljs-keyword">class</span> D <span class="hljs-keyword">extends</span> A { f2 = <span class="hljs-literal">true</span>; }
<span class="hljs-keyword">class</span> E <span class="hljs-keyword">extends</span> D { f3 = {}; }

<span class="hljs-keyword">let</span> v3 = [<span class="hljs-keyword">new</span> A(), <span class="hljs-keyword">new</span> B(), <span class="hljs-keyword">new</span> C(), <span class="hljs-keyword">new</span> D(), <span class="hljs-keyword">new</span> E()];  <span class="hljs-comment">// let v3: A[ ]</span>
<span class="hljs-keyword">let</span> v4 = [<span class="hljs-keyword">new</span> B(), <span class="hljs-keyword">new</span> C(), <span class="hljs-keyword">new</span> D(), <span class="hljs-keyword">new</span> E()];  <span class="hljs-comment">// let v4: (B | C | D)[ ]</span></code></pre>
<p>Те же самые правила применяются для вывода типа возвращаемого тернарнарным оператором.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> A {}
<span class="hljs-keyword">class</span> B <span class="hljs-keyword">extends</span> A { f0 = <span class="hljs-number">0</span>; }
<span class="hljs-keyword">class</span> C <span class="hljs-keyword">extends</span> A { f1 = <span class="hljs-string">''</span>; }
<span class="hljs-keyword">class</span> D <span class="hljs-keyword">extends</span> A { f2 = <span class="hljs-literal">true</span>; }
<span class="hljs-keyword">class</span> E <span class="hljs-keyword">extends</span> D { f3 = {}; }

<span class="hljs-keyword">let</span> v0 = <span class="hljs-literal">false</span> ? <span class="hljs-keyword">new</span> A() : <span class="hljs-keyword">new</span> B();  <span class="hljs-comment">// let v0: A</span>
<span class="hljs-keyword">let</span> v1 = <span class="hljs-literal">false</span> ? <span class="hljs-keyword">new</span> B() : <span class="hljs-keyword">new</span> C();  <span class="hljs-comment">// let v1: B | C</span>
<span class="hljs-keyword">let</span> v2 = <span class="hljs-literal">false</span> ? <span class="hljs-keyword">new</span> C() : <span class="hljs-keyword">new</span> D();  <span class="hljs-comment">// let v2: C | D</span></code></pre>
<p>Так как результат выражения, расположенного в блоке тернарного опретора условие, вычисляется на этапе выполнения, вывод типов не может знать его результата на этапе компиляции. Поэтому, чтобы не нарушить типобезопасность, он вынужден указывать объединенный тип определяемый всеми блоками выражение.</p>
</section><section id="Vyvod-tipov-kortej-Tuple" name="Вывод типов кортеж (Tuple)" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Vyvod-tipov-kortej-Tuple" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Вывод типов кортеж (Tuple)
            </h2>
        
<hr>
<p>Начать стоит с напоминания о том, что значение длины кортежа содержащего элементы помеченные как не обязательные, принадлежит к типу объединению (<code class="inline-code">Union</code>), который составляют литеральные числовые типы.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"> ...rest: [ <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>?, <span class="hljs-built_in">boolean</span>? ] </span>): [ <span class="hljs-title">number</span>, <span class="hljs-title">string</span>?, <span class="hljs-title">boolean</span>? ] </span>{
  <span class="hljs-keyword">return</span> rest;
}

<span class="hljs-keyword">let</span> l = f( <span class="hljs-number">5</span> ).length; <span class="hljs-comment">// let l: 1 | 2 | 3</span></code></pre>
<p>Кроме того, остаточные параметры (<code class="inline-code">...rest</code>) аннотированные с помощью параметра типа, рассматриваются и представляются выводом типа, как принадлежащие к типу кортежу.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&#x3C;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">any</span>[]>(<span class="hljs-params"> ...rest: T</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">return</span> rest;
}

<span class="hljs-comment">// рассматриваются</span>

f( <span class="hljs-number">5</span> );  <span class="hljs-comment">// function f&#x3C;[number]>(rest_0: number): void</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span> );  <span class="hljs-comment">// function f&#x3C;[number, string]>(rest_0: number, rest_1: string): void</span>
f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> );  <span class="hljs-comment">// function f&#x3C;[number, string, boolean]>(rest_0: number, rest_1: string, rest_2: boolean): void</span>


<span class="hljs-comment">// представляются</span>

<span class="hljs-keyword">let</span> v0 = f( <span class="hljs-number">5</span> );  <span class="hljs-comment">// let v0: [number]</span>
<span class="hljs-keyword">let</span> v1 = f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span> );  <span class="hljs-comment">// let v1: [number, string]</span>
<span class="hljs-keyword">let</span> v2 = f( <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> );  <span class="hljs-comment">// let v2: [number, string, boolean]</span></code></pre>
<p>Если функция, сигнатура которой содержит объявление остаточных параметров принадлежащих к типу параметра, будет вызвана с аргументами, среди которых будет массив указанный с помощью расширяющего синтаксиса (spread syntax), то определение типа кортеж также будет включать в себя остаточный тип (<code class="inline-code">...rest</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tuple</span>&#x3C;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">any</span>[]>(<span class="hljs-params">...args: T</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">return</span> args;
}


<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[] = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">let</span> v0 = tuple( <span class="hljs-number">5</span>, <span class="hljs-string">''</span>, <span class="hljs-literal">true</span> );  <span class="hljs-comment">// let v0: [number, string, boolean]</span>
<span class="hljs-keyword">let</span> v1 = tuple( <span class="hljs-number">5</span>, ...numberAll );  <span class="hljs-comment">// let v1: [number, ...number[]]</span></code></pre>
<p>Но нужно быть внимательным, так как порядок передачи аргументов содержащих расширяющий синтаксис, может привести к неочевидным результатам. Дело в том, что остаточный тип определяется не только типами самого массива, но и типами аргументов переданных после него.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tuple</span>&#x3C;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">any</span>[]>(<span class="hljs-params">...args: T</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-keyword">return</span> args;
}


<span class="hljs-keyword">let</span> numberAll: <span class="hljs-built_in">number</span>[] = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">let</span> v0 = tuple( <span class="hljs-number">5</span>, ...numberAll );  <span class="hljs-comment">// let v0: [number, ...number[]]</span>
<span class="hljs-keyword">let</span> v1 = tuple( <span class="hljs-number">5</span>, ...numberAll, <span class="hljs-string">''</span> ); <span class="hljs-comment">// let v1: [number, ...(string | number)[]]</span></code></pre>
</section>