<section id="Rasshirennye-tipy-Readonly-Partial-Required-Pick-Record" name="Расширенные типы — Readonly, Partial, Required, Pick, Record" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Rasshirennye-tipy-Readonly-Partial-Required-Pick-Record" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Расширенные типы — Readonly, Partial, Required, Pick, Record
            </h2>
        
<hr>
<p>Как уже было сказано ранее, <em>TypeScript</em> в помощь разработчикам реализовал несколько типов сопоставлений. К таким типам относятся <code class="inline-code">Readonly&#x3C;T></code>, <code class="inline-code">Partial&#x3C;T></code>, <code class="inline-code">Required&#x3C;T></code>, <code class="inline-code">Pick&#x3C;T, K></code> и <code class="inline-code">Record&#x3C;K, T></code>. Все, кроме <code class="inline-code">Record&#x3C;K, T></code>, являются <em>гомоморфными</em> (homomorphic). Очень простыми словами, <em>гомоморфизм</em> — это возможность сохранять свойства всех операций. На самом деле это очень просто и убедится в этом можно будет немного позже.</p>
</section><section id="Readonly" name="Readonly" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Readonly" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Readonly
            </h2>
        
<hr>
<p>Тип сопоставления <code class="inline-code">Readonly</code> помечает все члены только для чтения (модификатор <code class="inline-code">readonly</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.se6/d/ts</span>

<span class="hljs-keyword">type</span> Readonly&#x3C;T> = {
  readonly [P <span class="hljs-keyword">in</span> keyof T]: T[P];
};</code></pre>
<p>Применение сопоставимого типа <code class="inline-code">Readonly</code> может сократить написание кода во всех случаях, когда нужна иммутабельность. Представьте ситуацию, когда в качестве значения выступают сериализованные из строки <em>.json</em> объекты, состоящие из одних полей, а в качестве их описания — интерфейсы (<code class="inline-code">interface</code>). Для того, чтобы добиться иммутабельности, придется каждому описанному полю указывать модификатор <code class="inline-code">readonly</code>. Этой рутины можно избежать, воспользовавшись встроенным типом сопоставлением <code class="inline-code">Readonly&#x3C;T></code>.</p>
<p>После указания в качестве типа объекта <code class="inline-code">Readonly&#x3C;T></code>, поля этого объекта изменить будет нельзя.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimalEntity {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> json = <span class="hljs-string">'{"name": "animal", "age": 0}'</span>;

<span class="hljs-keyword">let</span> animal: Readonly&#x3C;IAnimalEntity> = <span class="hljs-built_in">JSON</span>.parse(json);
animal.name = <span class="hljs-string">'newanimal'</span>; <span class="hljs-comment">// Error -> all fields is immutable</span>
animal.age = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error -> all fields is immutable</span></code></pre>
<p>Тип сопоставления <code class="inline-code">Readonly&#x3C;T></code> является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа. То, что тип, указанный в качестве аргумента типа, полностью сохранил свое поведение (в данном случае — модификаторы), делает сопоставленный тип <code class="inline-code">Readonly&#x3C;T></code> гомоморфным.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  name?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> animal: Readonly&#x3C;IAnimal> = <span class="hljs-comment">// { readonly name?: string }</span></code></pre>
</section><section id="Partial" name="Partial" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Partial" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Partial
            </h2>
        
<hr>
<p>Тип сопоставления <code class="inline-code">Partial&#x3C;T></code> помечает все члены необязательными (<code class="inline-code">:?</code>).</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.es6.d.ts</span>

<span class="hljs-keyword">type</span> Partial&#x3C;T> = {
  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];
};</code></pre>
<p>Чаще всего необходимость в сопоставимом типе <code class="inline-code">Partial&#x3C;T></code> возникает тогда, когда метод в качестве аргумента принимает только часть конкретного типа данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> Model&#x3C;T> {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> entity: T</span>) {}

  <span class="hljs-keyword">public</span> getValueByKey&#x3C;U <span class="hljs-keyword">extends</span> keyof T>( key: U ): T[ U ] {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.entity[ key ];
  }

  <span class="hljs-keyword">public</span> update( partial: Partial&#x3C;T> ): <span class="hljs-built_in">void</span> {
      <span class="hljs-built_in">Object</span>.assign( <span class="hljs-keyword">this</span>.entity, partial );
  }
}

<span class="hljs-keyword">interface</span> IAnimalEntity {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> json = <span class="hljs-string">'{"name": "animal", "age": 0}'</span>;
<span class="hljs-keyword">let</span> entity = <span class="hljs-built_in">JSON</span>.parse(json);

<span class="hljs-keyword">let</span> animalModel: Model&#x3C;IAnimalEntity> = <span class="hljs-keyword">new</span> Model(entity);

<span class="hljs-built_in">console</span>.log( animalModel.getValueByKey( <span class="hljs-string">'name'</span> ) ); <span class="hljs-comment">// animal</span>

<span class="hljs-keyword">let</span> newJSON = <span class="hljs-string">'{"name": "newanimal"}'</span>;
<span class="hljs-keyword">let</span> newEntity = <span class="hljs-built_in">JSON</span>.parse(newJSON);

animalModel.update(newEntity); <span class="hljs-comment">// Ok</span>

<span class="hljs-built_in">console</span>.log( animalModel.getValueByKey( <span class="hljs-string">'name'</span> ) ); <span class="hljs-comment">// newanimal</span></code></pre>
<p>Тип сопоставления <code class="inline-code">Partial&#x3C;T></code> является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  readonly name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">let</span> animal: Partial&#x3C;IAnimal> = <span class="hljs-comment">// { readonly name?: string }</span></code></pre>
</section><section id="Required" name="Required" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Required" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Required
            </h2>
        
<hr>
<p>Тип сопоставления <code class="inline-code">Required&#x3C;T></code> удаляет все необязательные модификаторы <code class="inline-code">:?</code> приводя члены объекта к обязательным. Простыми словами, <code class="inline-code">Required&#x3C;T></code>, с помощью префикса - (глава <a class="book__chapter__chapter-link" href="/book/contents/Operator-keyof-Lookup-Types-Mapped-Types-Mapped-Types-prefiksy-i" title="Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -" target="_blank">Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -</a>),  помечает модификатор <code class="inline-code">:?</code> на удаление.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> Required&#x3C;T> = {
  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];
};</code></pre>
<p>Тип сопоставления Required<T> является полной противоположностью типу сопоставления <code class="inline-code">Partial&#x3C;T></code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> v0: Partial&#x3C;IT>; <span class="hljs-comment">// { a?: number; b?: string; }, необязательные члены</span>
<span class="hljs-keyword">let</span> v1: Required&#x3C;IT>; <span class="hljs-comment">// { a: number; b: string; }, обязательные члены</span></code></pre>
</section><section id="Pick" name="Pick" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Pick" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Pick
            </h2>
        
<hr>
<p>В типе сопоставлении <code class="inline-code">Pick&#x3C;T, K></code> определено два обязательных параметра типа. Первый параметр в качестве значения принимает конкретный тип данных. Второй параметр ожидает объединенный тип данных (<code class="inline-code">Union</code>), который состоит только из строковых литеральных типов, эквивалентных идентификаторам ключей типа, соответствующему первому параметру типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.es6.d.ts</span>

<span class="hljs-keyword">type</span> Pick&#x3C;T, K <span class="hljs-keyword">extends</span> keyof T> = {
  [P <span class="hljs-keyword">in</span> K]: T[P];
};</code></pre>
<p>Предназначен сопоставленный тип <code class="inline-code">Pick&#x3C;T, K></code> для ограничения описания типа на основе идентификаторов его членов. Простыми словами, у разработчиков и вывода типа появилась возможность фильтровать тип по именам его членов. </p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = {f1: <span class="hljs-built_in">string</span>, f2: <span class="hljs-built_in">number</span>, f3: <span class="hljs-built_in">boolean</span>};
<span class="hljs-keyword">type</span> T2 = Pick&#x3C;T1, <span class="hljs-string">'f1'</span> | <span class="hljs-string">'f2'</span>>;

<span class="hljs-keyword">let</span> v1: T1 = {f1: <span class="hljs-string">''</span>, f2: <span class="hljs-number">0</span>, f3: <span class="hljs-literal">true</span>}; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v2: T2 = {f1: <span class="hljs-string">''</span>, f2: <span class="hljs-number">0</span>, f3: <span class="hljs-literal">true</span>}; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v3: T2 = {f1: <span class="hljs-string">''</span>, f2: <span class="hljs-number">0</span>}; <span class="hljs-comment">// Ok</span></code></pre>
<p>Подобное можно было бы реализовать с помощью только параметров обобщенного типа, но при этом требовалось бы всегда указывать входящие и выходящие типы данных.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pick</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params"> object: T, ...keys: <span class="hljs-built_in">string</span>[ ] </span>): <span class="hljs-title">U</span> </span>{
  <span class="hljs-keyword">return</span> keys.reduce( <span class="hljs-function">(<span class="hljs-params">result, key</span>) =></span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign( result, {[key]: object[key]} );
  }, {} <span class="hljs-keyword">as</span> U );
}

<span class="hljs-keyword">interface</span> IAnimal {
  <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>;
  arial: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> IAnimapPartial {
  arial: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> animal = {<span class="hljs-keyword">type</span>: <span class="hljs-string">'animal'</span>, arial: <span class="hljs-string">'default'</span>, age: <span class="hljs-number">0</span>};
<span class="hljs-keyword">let</span> partial = pick&#x3C;IAnimal, IAnimapPartial>(animal, <span class="hljs-string">'arial'</span>, <span class="hljs-string">'notexistfield'</span>); <span class="hljs-comment">// Ok -> { arial: string, notexistfield: undefined }</span>
<span class="hljs-keyword">let</span> partial = pick&#x3C;IAnimal, IAnimapPartial>( animal, <span class="hljs-string">'arial'</span>, <span class="hljs-string">'age'</span> ); <span class="hljs-comment">// Ok -> { arial: string, age: number }</span></code></pre>
<p>В случаях, когда разрабатываемая библиотека рассчитана на широкий круг разработчиков, рекомендуется сделать выбор в пользу динамического вывода типов.</p>
<pre><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pick</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>>(<span class="hljs-params">object: T, ...keys: (K &#x26; <span class="hljs-built_in">string</span>)[]</span>): <span class="hljs-title">Pick</span>&#x3C;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>> </span>{
  <span class="hljs-keyword">return</span> keys.reduce( <span class="hljs-function">(<span class="hljs-params">result, key</span>) =></span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign( result, {[key]: object[key]} )
  }, {} <span class="hljs-keyword">as</span> Pick&#x3C;T, K> );
}

<span class="hljs-keyword">let</span> animal = {<span class="hljs-keyword">type</span>: <span class="hljs-string">'animal'</span>, arial: <span class="hljs-string">'default'</span>, age: <span class="hljs-number">0</span>};
<span class="hljs-keyword">let</span> partial = pick(animal, <span class="hljs-string">'type'</span>, <span class="hljs-string">'notexistfield'</span>); <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> partial = pick(animal, <span class="hljs-string">'arial'</span>, <span class="hljs-string">'age'</span>);  <span class="hljs-comment">// Ok -> { arial: string, age: number }</span></code></pre>
<p>Тип сопоставления <code class="inline-code">Pick&#x3C;T, K></code> является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IAnimal {
  readonly name?: <span class="hljs-built_in">string</span>;
  readonly age?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> animal: Pick&#x3C;IAnimal, <span class="hljs-string">'name'</span>> <span class="hljs-comment">// { readonly name?: string }</span></code></pre>
</section><section id="Record" name="Record" class="subchapter">
            <h2 class="subchapter-title">
                <button class="subchapter-title__button__copy-to-buffer copy-to-buffer" data="Record" type="absolute-url">
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <use href="#icon_link"/>
                    </svg>
                </button>
                Record
            </h2>
        
<hr>
<p>В типе сопоставления <code class="inline-code">Record&#x3C;K, T></code> определено два обязательных параметра типа. Первый параметр обязательно должен принадлежать к типу <code class="inline-code">string</code> или к <code class="inline-code">Literal String</code>. В качестве второго параметра может выступать любой конкретный тип данных. </p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// lib.es6.d.ts</span>

<span class="hljs-keyword">type</span> Record&#x3C;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, T> = {
  [P <span class="hljs-keyword">in</span> K]: T;
};</code></pre>
<p>Стоит также уточнить, что первый параметр типа принимает тип <code class="inline-code">string</code>, а не тип интерфейса <code class="inline-code">String</code>. При попытке указать значение типа <code class="inline-code">String</code> возникнет ошибка.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> T2 = <span class="hljs-built_in">String</span>;
<span class="hljs-keyword">type</span> T3 = <span class="hljs-string">'f1'</span> | <span class="hljs-string">'f2'</span>;
<span class="hljs-keyword">type</span> T4 = keyof <span class="hljs-built_in">number</span>;

<span class="hljs-keyword">let</span> v1: Record&#x3C;T1, <span class="hljs-built_in">number</span>>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v2: Record&#x3C;T2, <span class="hljs-built_in">string</span>>; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v3: Record&#x3C;T3, <span class="hljs-built_in">boolean</span>>; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v4: Record&#x3C;T4, object | symbol>; <span class="hljs-comment">// Ok</span></code></pre>
<p>Предназначен сопоставимый тип <code class="inline-code">Record&#x3C;K, T></code> для описания типа, идентификаторы которого будут состоять из литералов, указанных в качестве значения первому параметру, и которые будут ассоциированы с типом, указанным в качестве значения второму параметру.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> T1 = Record&#x3C;<span class="hljs-string">'f1'</span> | <span class="hljs-string">'f2'</span>, <span class="hljs-built_in">number</span>>;
<span class="hljs-keyword">type</span> T2 = Record&#x3C;<span class="hljs-string">'f1'</span> | <span class="hljs-string">'f2'</span>, <span class="hljs-built_in">string</span>>;
<span class="hljs-keyword">type</span> T3 = Record&#x3C;<span class="hljs-string">'f1'</span> | <span class="hljs-string">'f2'</span>, <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">Object</span>>;

<span class="hljs-keyword">let</span> v1: T1 = {f1: <span class="hljs-number">0</span>, f2: <span class="hljs-number">0</span>}; <span class="hljs-comment">// Ok</span>
<span class="hljs-keyword">let</span> v2: T2 = {f1: <span class="hljs-string">'0'</span>, f2: <span class="hljs-number">0</span>}; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v3: T3 = {f1: <span class="hljs-literal">true</span>, f2: {}}; <span class="hljs-comment">// Ok</span></code></pre>
<p>Как было рассмотрено ранее, индексным полям объекта в качестве ключей можно задавать значения, принадлежащие только к типу <code class="inline-code">string</code> или <code class="inline-code">number</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">interface</span> IIndexed {
  [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
  [key: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">let</span> object: IIndexed = { a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span> };</code></pre>
<p>Иногда может потребоваться ограничить диапазон вводимых ключей. Это очень просто сделать с помощью типа сопоставления <code class="inline-code">Record&#x3C;K, T></code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> ValidMember = <span class="hljs-string">"a"</span> | <span class="hljs-string">"b"</span>;

<span class="hljs-keyword">let</span> v1: Record&#x3C;ValidMember, <span class="hljs-built_in">any</span>> = { a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span>, c: <span class="hljs-number">0</span> }; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">let</span> v2: Record&#x3C;ValidMember, <span class="hljs-built_in">any</span>> = { a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span> }; <span class="hljs-comment">// Ok</span></code></pre>
</section>