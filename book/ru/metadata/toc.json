[
  {
    "section": "Общее",
    "title": "Что такое и для чего нужен TypeScript",
    "subtitles": [
      "Что такое TypeScript",
      "История TypeScript",
      "Для чего нужен TypeScript",
      "Зачем разработчику TypeScript"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Вступление",
    "subtitles": [
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Система типов, тип данных, значимые и ссылочные типы",
    "subtitles": [
      "Система Типов",
      "Тип данных (тип)",
      "Тип данных, передающийся по значению (примитивный тип)",
      "Тип данных, передающийся по ссылке"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Связывание, типизация, вывод типов",
    "subtitles": [
      "Обработка кода компилятором",
      "Лексический анализ (токенизация - tokenizing)",
      "Синтаксический анализ (разбор - parsing)",
      "Семантический анализ",
      "Связывание (Binding)",
      "Типизация",
      "Вывод Типов (type inference)"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Преобразование типов",
    "subtitles": [
      "Неявные Преобразования",
      "Явные Преобразования"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Типизированные и нетипизированные языки программирования",
    "subtitles": [
      "Нетипизированные языки",
      "Типизированные языки"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Статическая и динамическая типизация",
    "subtitles": [
      "Статическая типизация (Static Typing)",
      "Динамическая Типизация (Dynamic Typing)"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Сильная и слабая типизация",
    "subtitles": [
      "Сильная типизация (strongly typed)",
      "Слабая типизация (weakly typed)"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Явная и неявная типизация",
    "subtitles": [
      "Явная типизация (explicit typing)",
      "Неявная типизация (implicit typing)"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Совместимость типов на основе вида типизации",
    "subtitles": [
      "Совместимость типов (Types Compatibility)",
      "Номинативная Типизация (nominative typing)",
      "Структурная Типизация (structural typing)",
      "Утиная Типизация (Duck typing)"
    ]
  },
  {
    "section": "Экскурс в типизацию",
    "title": "Совместимость типов на основе вариантности",
    "subtitles": [
      "Вариантность",
      "Иерархия наследования",
      "Ковариантность",
      "Контравариантность",
      "Инвариантность",
      "Бивариантность"
    ]
  },
  {
    "section": "Синтаксические конструкции",
    "title": "Аннотация Типов",
    "subtitles": [
      "Аннотация Типов - общее",
      "Аннотация типа",
      "Синтаксические конструкции var, let, const",
      "Функции (function)",
      "Стрелочные Функции (arrow function)",
      "Классы (class)",
      "Сравнение Синтаксиса TypeScript и JavaScript",
      "Итог"
    ]
  },
  {
    "section": "Типы",
    "title": "Базовый Тип Any",
    "subtitles": [
      "Any (any) произвольный тип"
    ]
  },
  {
    "section": "Типы",
    "title": "Примитивные типы Number, String, Boolean, Symbol, BigInt",
    "subtitles": [
      "Важно",
      "Number (number) примитивный числовой тип",
      "String (string) примитивный строковый тип",
      "Boolean (boolean) примитивный логический тип",
      "Symbol (symbol) примитивный символьный тип",
      "BigInt (bigint) примитивный числовой тип"
    ]
  },
  {
    "section": "Типы",
    "title": "Примитивные типы Null, Undefined, Void, Never, Unknown",
    "subtitles": [
      "Важно",
      "Null (null) примитивный null тип",
      "Undefined (undefined) примитивный неопределенный тип",
      "Void (void) отсутствие конкретного типа",
      "Never (never) примитивный тип",
      "Unknown (unknown)"
    ]
  },
  {
    "section": "Типы",
    "title": "Примитивный Тип Enum",
    "subtitles": [
      "Enum (enum) примитивный перечисляемый тип",
      "Перечисления с числовым значением",
      "Перечисления со строковым значением",
      "Смешанное перечисление (mixed enum)",
      "Перечисление в качестве типа данных",
      "Перечисление const с числовым и строковым значением",
      "Когда стоит применять enum?"
    ]
  },
  {
    "section": "Типы",
    "title": "Типы - Union, Intersection",
    "subtitles": [
      "Тип Объединение (Union Types)",
      "Тип Пересечение (Intersection Type)"
    ]
  },
  {
    "section": "Типы",
    "title": "Type Queries (запросы типа), Alias (псевдонимы типа)",
    "subtitles": [
      "Запросы Типа (Type Queries)",
      "Псевдонимы Типов (Type Aliases)"
    ]
  },
  {
    "section": "Типы",
    "title": "Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum",
    "subtitles": [
      "Литеральный тип Number (Numeric Literal Types)",
      "Литеральный тип String (String Literal Types)",
      "Шаблонный литеральный тип String (Template String Literal Types)",
      "Литеральный Тип Boolean (Boolean Literal Types)",
      "Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип",
      "Литеральный тип Enum (Enum Literal Types)"
    ]
  },
  {
    "section": "Типы",
    "title": "Object, Array, Tuple",
    "subtitles": [
      "Object (object) — ссылочный объектный тип",
      "Array (type[]) ссылочный массивоподобный тип",
      "Tuple ([T0, T1, …, Tn]) тип кортеж"
    ]
  },
  {
    "section": "Типы",
    "title": "Function, Functional Types",
    "subtitles": [
      "Function Types - тип функция",
      "Functional Types - функциональный тип",
      "this в сигнатуре функции"
    ]
  },
  {
    "section": "Типы",
    "title": "Interfaces",
    "subtitles": [
      "Общая теория",
      "Интерфейс в TypeScript",
      "Объявление (declaration)",
      "Конвенции именования интерфейсов",
      "Реализация интерфейса (implements)",
      "Декларация свойств get и set (accessors)",
      "Указание интерфейса в качестве типа (interface types)",
      "Расширение интерфейсов (extends interface)",
      "Расширение интерфейсом класса (extends class)",
      "Описание класса (функции-конструктора)",
      "Описание функционального выражения",
      "Описание индексных членов в объектных типов",
      "Инлайн интерфейсы (Inline Interface)",
      "Слияние интерфейсов"
    ]
  },
  {
    "section": "Типы",
    "title": "Объектные типы с индексными членами (объектный тип с динамическими ключами)",
    "subtitles": [
      "Индексные члены (определение динамических ключей)",
      "Строгая проверка при обращении к динамическим ключам",
      "Запрет обращения к динамическим ключам через точечную нотацию",
      "Тонкости совместимости индексной сигнатурой с необязательными полями"
    ]
  },
  {
    "section": "Классы",
    "title": "Модификаторы доступа (Access Modifiers)",
    "subtitles": [
      "Модификатор доступа public (публичный)",
      "Модификатор доступа private (закрытый или скрытый)",
      "Модификатор доступа protected (защищенный)",
      "Модификаторы доступа и конструкторы класса",
      "Быстрое объявление полей"
    ]
  },
  {
    "section": "Классы",
    "title": "Закрытые поля определенные спецификацией ECMAScript",
    "subtitles": [
      "Нативный закрытый (private) модификатор доступа"
    ]
  },
  {
    "section": "Классы",
    "title": "Абстрактные классы (abstract classes)",
    "subtitles": [
      "Общие характеристики",
      "Теория"
    ]
  },
  {
    "section": "Классы",
    "title": "Полиморфный тип this",
    "subtitles": [
      "this - как тип"
    ]
  },
  {
    "section": "Классы",
    "title": "Модификатор readonly (только для чтения)",
    "subtitles": [
      "Модификатор readonly"
    ]
  },
  {
    "section": "Классы",
    "title": "Definite Assignment Assertion Modifier",
    "subtitles": [
      "Модификатор утверждения не принадлежности значения к типу undefined"
    ]
  },
  {
    "section": "Классы",
    "title": "Классы — Тонкости",
    "subtitles": [
      "Классы - Тонкости implements",
      "Частичное слияние интерфейса с классом",
      "Переопределение свойств полями и наоборот при наследовании"
    ]
  },
  {
    "section": "Тонкости TypeScript",
    "title": "Различия var, let, const и модификатора readonly при неявном указании примитивных типов",
    "subtitles": [
      "Нюансы на практике"
    ]
  },
  {
    "section": "Работа с типами",
    "title": "Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion",
    "subtitles": [
      "Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)",
      "Оператор ! (Non-Null and Non-Undefined Operator)",
      "Оператор ! (Definite Assignment Assertion)"
    ]
  },
  {
    "section": "Типы",
    "title": "Обобщения (Generics)",
    "subtitles": [
      "Обобщения - общие понятия",
      "Обобщения в TypeScript",
      "Параметры типа - extends (generic constraints)",
      "Параметра типа - значение по умолчанию = (generic parameter defaults)",
      "Параметры типа - как тип данных"
    ]
  },
  {
    "section": "Типы",
    "title": "Дискриминантное объединение (Discriminated Union)",
    "subtitles": [
      "Дискриминантное объединение"
    ]
  },
  {
    "section": "Работа с типами",
    "title": "Импорт и экспорт только типа",
    "subtitles": [
      "Предыстория возникновения import type и export type",
      "import type и export type - форма объявления",
      "Импорт и экспорт только типа на практике",
      "Вспомогательный флаг --importsNotUsedAsValues"
    ]
  },
  {
    "section": "Типизация",
    "title": "Утверждение типов (Type Assertion)",
    "subtitles": [
      "Утверждение типов - общее",
      "Утверждение типа с помощью <Type> синтаксиса",
      "Утверждение типа с помощью оператора as",
      "Приведение (утверждение) к константе (const assertion)",
      "Утверждение в сигнатуре (Signature Assertion)"
    ]
  },
  {
    "section": "Типизация",
    "title": "Защитники типа",
    "subtitles": [
      "Защитники Типа - общее",
      "Сужение диапазона множества типов на основе типа данных",
      "Сужение диапазона множества типов на основе признаков присущих типу Tagged Union",
      "Сужение диапазона множества типов на основе доступных членов объекта",
      "Сужение диапазона множества типов на основе функции, определенной пользователем"
    ]
  },
  {
    "section": "Типизация",
    "title": "Вывод типов",
    "subtitles": [
      "Вывод типов - общие сведения",
      "Вывод примитивных типов",
      "Вывод примитивных типов для констант (const) и полей только для чтения (readonly)",
      "Вывод объектных типов",
      "Вывод типа для полей класса на основе инициализации их в конструкторе",
      "Вывод объединенных (Union) типов",
      "Вывод пересечения (Intersection) с дискриминантными полями",
      "Вывод типов кортеж (Tuple)"
    ]
  },
  {
    "section": "Типизация",
    "title": "Совместимость объектных типов (Compatible Object Types)",
    "subtitles": [
      "Важно",
      "Совместимость объектных типов в TypeScript"
    ]
  },
  {
    "section": "Типизация",
    "title": "Совместимость функциональных типов (Compatible Function Types)",
    "subtitles": [
      "Важно",
      "Совместимость параметров",
      "Совместимость возвращаемого значения"
    ]
  },
  {
    "section": "Типизация",
    "title": "Совместимость объединений (Union Types)",
    "subtitles": [
      "Совместимость"
    ]
  },
  {
    "section": "Типизация",
    "title": "Типизация в TypeScript",
    "subtitles": [
      "Общие сведения",
      "Статическая типизация (static typing)",
      "Сильная типизация (strongly typed)",
      "Явно типизированный (explicit typing) с выводом типов (type inference)",
      "Совместимость типов (Type Compatibility), структурная типизация (structural typing)",
      "Вариантность (variance)",
      "Наилучший общий тип (Best common type)",
      "Контекстный тип (Contextual Type)"
    ]
  },
  {
    "section": "Работа с типами",
    "title": "Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -",
    "subtitles": [
      "Запрос ключей keyof",
      "Поиск типов (Lookup Types)",
      "Сопоставление типов (Mapped Types)",
      "Префиксы + и - в сопоставленных типах"
    ]
  },
  {
    "section": "Работа с типами",
    "title": "Условные типы (Conditional Types)",
    "subtitles": [
      "Условные типы на практике",
      "Распределительные условные типы (Distributive Conditional Types)",
      "Вывод типов в условном типе"
    ]
  },
  {
    "section": "Расширенные типы",
    "title": "Readonly, Partial, Required, Pick, Record",
    "subtitles": [
      "Readonly<T> (сделать члены объекта только для чтения)",
      "Partial<T> (сделать все члены объекта необязательными)",
      "Required<T> (сделать все необязательные члены обязательными)",
      "Pick (отфильтровать объектный тип)",
      "Record<K, T> (динамически определить поле в объектном типе)"
    ]
  },
  {
    "section": "Расширенные типы",
    "title": "Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit",
    "subtitles": [
      "Exclude<T, U> (исключает из T признаки присущие U)",
      "Extract<T, U> (общие для двух типов признаки)",
      "NonNullable<T> (удаляет типы null и undefined)",
      "ReturnType<T> (получить тип значения возвращаемого функцией)",
      "InstanceType<T> (получить через тип класса тип его экземпляра)",
      "Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)",
      "ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)",
      "Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)"
    ]
  },
  {
    "section": "Расширенные типы",
    "title": "Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet",
    "subtitles": [
      "Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)",
      "ReadonlyArray<T> (неизменяемый массив)",
      "ReadonlyMap<K, V> (неизменяемая карта)",
      "ReadonlySet<T> (неизменяемое множество)"
    ]
  },
  {
    "section": "Синтаксические конструкции",
    "title": "Синтаксические конструкции и операторы",
    "subtitles": [
      "Операторы присваивания короткого замыкания (&&=, ||=, &&=)",
      "Операнды для delete должны быть необязательными",
      "Объявление переменных 'необязательными' при деструктуризации массивоподобных объектов",
      "Модификатор abstract для описания типа конструктора"
    ]
  },
  {
    "section": "React",
    "title": "Типизированный React",
    "subtitles": [
      "Расширение .tsx"
    ]
  },
  {
    "section": "React",
    "title": "Функциональные компоненты",
    "subtitles": [
      "Определение компонента как Function Declaration",
      "Определение компонента как Function Expression"
    ]
  },
  {
    "section": "React",
    "title": "Классовые компоненты",
    "subtitles": [
      "Производные от Component<P, S, SS>",
      "Производные от PureComponent<Props, State, Snapshot>"
    ]
  },
  {
    "section": "React",
    "title": "Универсальные компоненты",
    "subtitles": [
      "Обобщенные компоненты (Generics Component)"
    ]
  },
  {
    "section": "React",
    "title": "Типизированные хуки",
    "subtitles": [
      "Предопределенные хуки - useState<T>()",
      "Предопределенные хуки - useEffect() и useLayoutEffect()",
      "Предопределенные хуки - useContext<T>()",
      "Предопределенные хуки - useReducer<R>()",
      "Предопределенные хуки - useCallback<T>()",
      "Предопределенные хуки - useRef<T>()",
      "Предопределенные хуки - useImperativeHandle<T, R>()",
      "Предопределенные хуки - useMemo<T>()",
      "Предопределенные хуки - useDebugValue<T>()",
      "Пользовательский хук"
    ]
  },
  {
    "section": "React",
    "title": "Контекст (Context)",
    "subtitles": [
      "Определение контекста"
    ]
  },
  {
    "section": "React",
    "title": "HOC (Higher-Order Components)",
    "subtitles": [
      "Определение hoc",
      "Определение hoc на основе функционального компонента",
      "Определение hoc на основе классового компонента"
    ]
  },
  {
    "section": "Синтаксические конструкции",
    "title": "Пространства имен (namespace) и модули (module)",
    "subtitles": [
      "Namespace и module — предназначение",
      "Namespace - определение",
      "Модули (export, import) — определение",
      "Конфигурирование проекта"
    ]
  },
  {
    "section": "Сборка",
    "title": "Настройка рабочего окружения",
    "subtitles": [
      "Настройка рабочего окружения",
      "Сборка проекта с помощью tsc (TypeScript compiler)"
    ]
  },
  {
    "section": "Сборка",
    "title": "Сборка с использованием ссылок на проекты",
    "subtitles": [
      "Ссылки на проекты"
    ]
  },
  {
    "section": "Сборка",
    "title": "Декларации",
    "subtitles": [
      "Что такое декларация (Declaration)",
      "Установка деклараций с помощью @types",
      "Подготовка к созданию декларации",
      "Разновидности деклараций",
      "Декларации и область видимости",
      "Декларации для библиотек с одной точкой входа",
      "Декларации для библиотек с множеством точек входа",
      "Создание деклараций вручную",
      "Директива с тройным слешем (triple-slash directives)",
      "Импортирование декларации (import)"
    ]
  },
  {
    "section": "Сборка",
    "title": "Публикация TypeScript",
    "subtitles": [
      "Публикация"
    ]
  },
  {
    "section": "Компилятор",
    "title": "Опции компилятора",
    "subtitles": [
      "strict",
      "suppressExcessPropertyErrors",
      "suppressImplicitAnyIndexErrors",
      "noImplicitAny",
      "checkJs",
      "JSX",
      "jsxFactory",
      "target (t)",
      "extends",
      "alwaysStrict",
      "strictNullChecks",
      "stripInternal",
      "noImplicitThis",
      "noImplicitUseStrict",
      "baseUrl",
      "paths",
      "rootDir",
      "rootDirs",
      "traceResolution",
      "lib",
      "noLib",
      "noResolve",
      "noStrictGenericChecks",
      "preserveConstEnums",
      "removeComments",
      "noUnusedLocals",
      "noUnusedParameters",
      "skipLibCheck",
      "declarationDir",
      "types",
      "typeRoots",
      "allowUnusedLabels",
      "noImplicitReturns",
      "noFallthroughCasesInSwitch",
      "outFile",
      "allowSyntheticDefaultImports",
      "allowUnreachableCode",
      "allowJs",
      "reactNamespace",
      "pretty",
      "moduleResolution",
      "exclude",
      "noEmitHelpers",
      "newLine",
      "inlineSourceMap",
      "inlineSources",
      "noEmitOnError",
      "noEmit",
      "charset",
      "diagnostics",
      "declaration",
      "downlevelIteration",
      "emitBOM",
      "emitDecoratorMetadata",
      "forceConsistentCasingInFileNames",
      "help (h)",
      "importHelpers",
      "isolatedModules",
      "listEmittedFiles",
      "listFiles",
      "sourceRoot",
      "mapRoot",
      "maxNodeModuleJsDepth",
      "project (p)",
      "init",
      "version (v)",
      "watch (w)",
      "preserveSymlinks",
      "strictFunctionTypes",
      "locale",
      "strinctPropertyInitialization",
      "esModuleInterop",
      "emitDeclarationsOnly",
      "resolveJsonModule",
      "declarationMap",
      "strictBindCallApply",
      "showConfig",
      "build",
      "verbose",
      "dry",
      "clean",
      "force",
      "incremental",
      "tsBuildInfoFile",
      "allowUmdGlobalAccess",
      "disableSourceOfProjectReferenceRedirect",
      "useDefineForClassFields",
      "importsNotUsedAsValues",
      "assumeChangesOnlyAffectDirectDependencies",
      "watchFile",
      "watchDirectory",
      "fallbackPolling",
      "synchronousWatchDirectory",
      "noUncheckedIndexedAccess",
      "noPropertyAccessFromIndexSignature",
      "explainFiles"
    ]
  }
]
