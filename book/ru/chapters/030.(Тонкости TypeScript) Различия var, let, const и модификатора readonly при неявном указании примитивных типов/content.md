# Различия var, let, const и модификатора readonly при неявном указании примитивных типов

После того, как было рассмотрено понятие _литеральных типов_, и тем самым подведена черта под примитивными типами, наступило время рассмотреть особенности `var`, `let` и `const`, определение которых не содержит явную аннотацию типа.


## Нюансы на практике

Отсутствие аннотации типа у объявления переменной означает, что тип будет определен с помощью механизма вывода типов. В тот момент, когда `var` или `let` объявляется, но не инициализируется, вывод типов определяет их принадлежность к типу `any`. В случае с `const` невозможно обойтись без инициализации в момент объявления.

`````ts
var a; // a: any
let b; // b: any
const c; // Error
`````

Если при определении `var` или `let` аннотация типа была опущена, а присваемое значение принадлежит к примитивному типу, то вывод типа определит принадлежность на основе типа значения. Для цифр, это будет тип `number`, для строк `string` и т.д.

`````ts
var a = 5; // a: number
let b = 'text'; // b: string
`````

Но при аналогичной ситуации для `const`, вывод типов определит принадлежность не к типу значения, а к литеральному типу представляемого этим значением.

`````ts
const a = 5; // a: 5
const b = 'text'; b: 'text'
`````

Поведение вывода типов для поля, объявленного с модификатором `readonly`, аналогично объявлению `const`, то есть для примитивов будет выведен литеральный тип. 

`````ts
class T1 {
    readonly f1 = 'text'; // f1: text
    readonly f2 = 0; // f2: 0
    readonly f3 = true; // f3: true
}
`````

Более подробно эта тема рассматривается далее в главе [“Вывод типов”](../037.(Типизация)%20Вывод%20типов).

