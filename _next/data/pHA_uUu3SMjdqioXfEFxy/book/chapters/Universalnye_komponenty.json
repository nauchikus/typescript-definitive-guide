{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/053.(React) Универсальные компоненты/images/"},"sectionInfoAll":[{"key":"Универсальные компоненты","elementId":"Universalnye_komponenty","markdown":"# Универсальные компоненты\n\nПодобно универсальным классам, синтаксис `.tsx`, позволяет определять _React_ компоненты обобщенными. С этим связано несколько неочевидных моментов, каждый из которых будет рассмотрен в текущей главе."},{"key":"Универсальные компоненты_0","elementId":"Obobshchennye_komponenty_(Generics_Component)","markdown":"## Обобщенные компоненты (Generics Component)\n\nВ _TypeScript_ существует возможность объявлять пользовательские компоненты обобщенными, что лишь повышает их повторное использование. Чтобы избавить читателя от пересказа того, что подробно было рассмотрено в главе [“Типы - Обобщения (Generics)”](../032.(Типы)%20Обобщения%20(Generics)), опустим основную теорию и сосредоточимся конкретно на той её части, которая сопряжена непосредственно с _React_ компонентами. Но поскольку польза от универсальных компонентов может быть не совсем очевидна, прежде чем приступить к рассмотрению их синтаксиса, стоит упомянуть, что\nпараметры типа предназначены по большей степени для аннотирования членов типа представляющего пропсы компонента.\n\nВ случае компонентов, расширяющих универсальные классы `Component<P, S, SS>` или `PureComponent<P, S, SS>`, нет ничего особенного, на, что стоит обратить особое внимание.\n\n`````ts\n            /**[0] */\ninterface Props<T> {\n    data: T; /**[1] */\n}\n\n  /**[2][3]                       [4] */\nclass A<T> extends Component<Props<T>> {}\n  /**[2][3]                         [4] */\nclass B<T> extends PureComponent<Props<T>> {}\n\n\n// ...где-то в коде\n\n\n\n/**[5] */\ninterface IDataB {\n    b: string;\n}\n\n/**[6] [7]            [8] */\n   <A<IDataA> data={{a: 0}} />; // Ok\n/**[6] [7]            [9] */\n   <A<IDataA> data={{a: '0'}} />; // Error\n\n\n/**[5] */\ninterface IDataA {\n    a: number;\n}\n\n/**[6] [7]            [8] */\n   <A<IDataB> data={{b: ''}} />; // Ok\n/**[6] [7]            [9] */\n   <A<IDataB> data={{b: 0}} />; // Error\n\n/**\n * [0] определение обобщенного типа чей\n * единственный параметр предназначен для\n * указания в аннотации типа поля data [1].\n * \n * [2] определение универсальных классовых\n * компонентов чей единственный параметр типа [3]\n * будет установлен в качестве аргумента типа типа\n * представляющего пропсы компонента [4]\n * \n * \n * [5] определение двух интерфейсов представляющих\n * два различных типа данных. \n * \n * [6] создание экземпляра универсального компонента\n * и установление в качестве пропсов объекты соответствующие [8]\n * и нет [9] требованиям установленными аргументами типа [7].\n */\n`````\n\nНет ничего особенного и в определении функционального компонента как _Function Declaration_.\n\n`````ts\n            /**[0] */\ninterface Props<T> {\n    data: T; /**[1] */\n}\n\n     /**[2][3]             [4] */\nfunction A <T>(props: Props<T>) {\n    return <div></div>;\n}\n\n/**\n * [0] определение обобщенного типа чей\n * единственный параметр предназначен для\n * указания в аннотации типа поля data [1].\n * \n * [2] универсальный функциональный компонент\n * определенный как Function Declaration [2] чей\n * единственный параметр типа [3] будет установлен \n * в качестве аргумента типа типа представляющего \n * пропсы компонента [4].\n * \n */\n`````\n\nНо относительно функциональных компонентов определенных как _Function Expression_ не обошлось без курьезов. Дело в том, что в большинстве случаев лучшим способом описания сигнатуры функционального компонента является использование обобщенного типа `FC<P>`. Это делает невозможным передачу параметра типа функции в качестве аргумента типа типу представляющему пропсы, поскольку они находятся по разные стороны от оператора присваивания.\n\n`````ts\ninterface Props<T> {}\n\nconst A: FC<Props< /**[0] */ >> = function < /**[1] */ > (props) {\n    return <div></div>;\n}\n\n/**\n * [0] как получить тут, то...\n * [1] ..., что объявляется здесь?\n */\n `````\n\nЕдинственный возможный вариант создания обобщенного функционального компонента определенного как _Function Expression_ заключается в отказе от аннотирования идентификатора в пользу типизирования сигнатуры непосредственно компонента. \n\n`````ts\ninterface Props<T> {\n    data: T;\n}\n\n\n  /**[0]            [1]          [2] */\nconst A =  function <T>(props: Props<T>) {\n    return <div></div>;\n};\n\n\n<A<number> data={0}/>; // Ok\n<A<number> data={''}/>; // Error\n\n/**\n * Чтобы функциональный компонент стал\n * универсальным определение принадлежности\n * идентификатора функционального выражения [0]\n * необходимо поручить выводу типов который\n * сделает это на основе типов явно указанных\n * в сигнатуре функции [1] [2] выступающей в качестве\n * значения. \n */\n`````\n\nКроме этого, неприятный момент связан со стрелочными универсальными функциями (_arrow function_) при определении их в файлах имеющих расширение `.tsx`. Дело в том, что невозможно определить универсальную функцию если она содержит только один параметр типа который не расширяет другой тип.\n\n`````ts\n       /**[0] */\nconst f = <T>(p: T) => {}; /**[1] Error */\n\n[].forEach(/**[2] */<T>() => { }) /**[3] Error */\n\n/**\n * Не имеет значения присвоена универсальная\n * стрелочная функция [0] [2] переменной [1] или определена\n * в месте установления аргумента [3] компилятор\n * никогда не позволит скомпилировать такой код, если\n * он расположен в файлах с расширением .tsx\n */\n`````\n\nДругими словами, что бы при определении универсальной стрелочной функции в файле с расширением `.tsx` не возникало ошибки её единственный параметр типа должен расширять другой тип...\n\n`````ts\n             /**[0] */\nconst f0 = <T extends {}>(p: T) => {}; // Ok\n\n             /**[0] */\n[].forEach(<T extends {}>() => { }); // Ok\n\n\n/**\n * Если единственный параметр типа\n * расширяет другой тип [0], то ошибка\n * не возникает.\n */\n `````\n\n...либо параметров типа должно быть несколько.\n\n`````ts\n          /**[0] */\nconst f0 = <Tб, U>(p: T) => {}; // Ok\n\n          /**[0] */\n[].forEach(<T, U>() => { }); // Ok\n\n\n/**\n *[0] ошибки также не возникает\n если универсальная функция определяет\n несколько параметров типа.\n */\n `````\n\nДля закрепления информации данной главы выполним небольшой пример. Представьте задачу требующую написание компонента испускающего событие, объект которого содержит свойство `data` хранящего значение переданное вместе с пропсами. Без механизма универсальных компонентов, свойство `data`, как в пропсах, так и объекте событий, будет представлено либо одним конкретным типом, либо множеством типов составляющих тип объединение.\n\nВ первом случае, для каждого типа представляющего данные, потребуется определять новый компонент. \n\n`````ts\ninterface DataEvent<T> {\n    data: T;\n}\n\n\n/**[0] */\ninterface  CardAProps {\n    data: number; /**[1] */\n                             /**[1] */\n    handler: (event: DataEvent<number>) => void;\n}\n\n    /**[2] */\nconst CardA = ({data, handler}: CardAProps) => {\n    return (\n        <div onClick={() => handler({data})}>Card Info</div>\n    );\n}\n\nconst handlerA = (event: DataEvent<number>) => {}\n\n<CardA data={0} handler={handlerA} />\n\n/** ============== */\n\n/**[3] */\ninterface  CardBProps {\n    data: string; /**[4] */\n                             /**[4] */\n    handler: (event: DataEvent<string>) => void;\n}\n\n    /**[5] */\nconst CardB = ({data, handler}: CardBProps) => {\n    return (\n        <div onClick={() => handler({data})}>Card Info</div>\n    );\n}\n\nconst handlerB = (event: DataEvent<string>) => {}\n\n<CardB data={``} handler={handlerB} />\n\n/**\n * [2] [5] определение идентичных по логике компонентов\n * нужда в которых появляется исключительно из-за необходимости\n * в указании разных типов [1][4] в описании интерфейсов представляющих\n * их пропсы [0][3] \n */\n `````\n\nВо втором, для сужения множества типов, придется производить утомительные проверки.\n\n`````ts\ninterface DataEvent<T> {\n    data: T;\n}\n\n\ninterface  CardProps {\n    data: number | string; /**[0] */\n                                  /**[0] */\n    handler: (event: DataEvent<number | string>) => void;\n}\n\nconst Card = ({data, handler}: CardProps) => {\n    return (\n        <div onClick={() => handler({data})}>Card Info</div>\n    );\n}\n\n\nconst handler = (event: DataEvent<number | string>) => {\n    // утомительные проверки\n\n    if(typeof event.data === `number`){\n        // в этом блоке кода обращаемся как с number\n    }else if(typeof event.data === `string`){\n        // в этом блоке кода обращаемся как с string\n    }\n}\n\n<Card data={0} handler={handler} />\n\n/**\n * [0] указание типа как объединение number | string\n * избавило от необходимости определения множества компонентов,\n * но не избавила от утомительных и излишних проверок при работе\n * с данными с слушателе событий.\n */\n `````\n\nИзбежать повторяющегося или излишнего кода можно путем определения компонентов универсальными.\n\n`````ts\ninterface DataEvent<T> {\n    data: T;\n}\n\n\n/**[0] */\ninterface  CardProps<T> {\n    data: T; /**[1] */\n                           /**[1] */\n    handler: (event: DataEvent<T>) => void;\n}\n\n    /**[2]            [3]                           [4] */\nconst Card = function <T>({data, handler}: CardProps<T>) {\n    return (\n        <div onClick={() => handler({data})}>Card Info</div>\n    );\n}\n\nconst handlerWithNumberData = (event: DataEvent<number>) => {}\nconst handlerWithStringData = (event: DataEvent<string>) => {}\n\n<Card<number> data={0} handler={handlerWithNumberData} />;\n<Card<string> data={``} handler={handlerWithStringData} />;\n\n/**\n * [2] определение универсального функционального компонента\n * параметр типа которого [3] будет установлен типу представляющего\n * пропсы [0] в качестве аргумента типа [4], что сделает его описание [1]\n * универсальным.\n */\n `````\n\nВ итоге кода становиться меньше, что делает его проще для чтения. Кроме того, код написанный таким образом более соответствует лучшим канонам обусловленных типизацией."}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Классовые компоненты","path":"Klassovye_komponenty"},"nextPage":{"title":"Типизированные хуки","path":"Tipizirovannye_huki"}},"contentNavData":{"key":"Универсальные компоненты","level":0,"index":53,"contentIndex":0,"section":"React","title":"Универсальные компоненты","path":"Universalnye_komponenty","elementId":"Universalnye_komponenty","children":[{"key":"Универсальные компоненты_0","index":0,"contentIndex":1,"level":1,"section":"React","title":"Обобщенные компоненты (Generics Component)","path":"Obobshchennye_komponenty_(Generics_Component)","elementId":"Obobshchennye_komponenty_(Generics_Component)"}]},"pageDescription":"Универсальные компоненты"},"__N_SSG":true}