{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/039.(Типизация) Вывод типов/images/"},"sectionInfoAll":[{"key":"Вывод типов","elementId":"Vyvod_tipov","markdown":"# Вывод типов\n\nПонимание темы, относящейся к такому фундаментальному механизму как _вывод типов_, поможет разработчику подчинить компилятор _tsc_, а не наоборот. Невозможно писать программы на языке _TypeScript_, получая от процесса удовольствие, если нет однозначного ответа на вопрос \"указывать типы явно или нет\". Ответы на этот и другие сопряженные вопросы, как раз и содержит данная глава, посвященная подробному рассмотрению каждого момента."},{"key":"Вывод типов_0","elementId":"Vyvod_tipov_-_obshchie_svedeniya","markdown":"## Вывод типов - общие сведения\n\nЧтобы не повторять определения, которые были даны в главе [“Экскурс в типизацию - Связывание, типизация, вывод типов”](../003.(Экскурс%20в%20типизацию)%20Связывание,%20типизация,%20вывод%20типов), эту главу стоит начать с неформально определения.\n\n\n_Вывод типов_ — это механизм, позволяющий сделать процесс разработки на статически типизированном _TypeScript_ более простой, за счет перекладывания на него рутинной работы по явной аннотации типов. Может показаться, что вывод типов берется за дело только тогда, когда при разборе кода попадается отсутствующая аннотация типа. Но это не так. Компилятор не доверяет разработчику и весь код, в штатном режиме, проходит через вывод типов. Не важно, в полной мере разработчик указывает типы определяемым им конструкциям или нет, что бы их проверить на адекватность и совместимость, вывод типов обязан создать для них собственное описание (понимать как объявление типа).\n\nВ этом механизме нет ничего сложного, но, несмотря на это, у начинающих разработчиков _TypeScript_, некоторые неочевидные особенности могут вызвать вопросы, главным из которых является уже упомянутый в самом начале - \"указывать явно типы или нет\".\n\nОтвет очевиден и прост — во всех случаях, допускающих отсутствие явной аннотации типа, эту работу стоит поручать выводу типов. Другими словами, не нужно указывать типы явно, если это за вас сможет сделать вывод типов. Единственное исключение может возникнуть при необходимости повышения семантики кода, что относительно аннотаций типа бывает сравнительно редко."},{"key":"Вывод типов_1","elementId":"Vyvod_primitivnyh_tipov","markdown":"## Вывод примитивных типов\n\nВывод типов, для значений принадлежащих к так называемым примитивным типам, не таит в себе ничего необычного. Кроме того, будь это переменные, поля, параметры, возвращаемые из функций и методов, или значения — результат во всех случаях будет идентичным.\n\n`````ts\nenum Enums {\n    Value\n};\n\nlet v0 = 0; // let v0: number\nlet v1 = 'text'; // let v1: string\nlet v2 = true; // let v2: boolean\nlet v3 = Symbol(); // let v3: symbol\nlet v4 = Enums.Value; // let v4: Enums\n`````"},{"key":"Вывод типов_2","elementId":"Vyvod_primitivnyh_tipov_dlya_konstant_(const)_i_polei_tolko_dlya_chteniya_(readonly)","markdown":"## Вывод примитивных типов для констант (const) и полей только для чтения (readonly)\n\nКогда дело доходит до присваивания значений, принадлежащих к примитивным типам, таким конструкциям, как константы (`const`) и неизменяемые поля (модификатор `readonly`), поведение вывода типов изменяется.\n\nВ случае, когда значение принадлежит к примитивным типам `number`, `string` или `boolean`, вывод типов указывает принадлежность к литеральным примитивным типам, определяемым самим значением.\n\n`````ts\nconst v0 = 0; // let v0: 0\nconst v1 = 'text'; // let v1: 'text'\nconst v2 = true; // let v2: true\n\nclass Identifier {\n    readonly f0 = 0; // f0: 0\n    readonly f1 = 'text'; // f1: 'text'\n    readonly f2 = true;// f2: true\n}\n`````\n\nЕсли значение принадлежит к типу `enum`, то вывод типов установит принадлежность к указанному значению.\n\n`````ts\nenum Enums {\n    Value\n}\n\nconst v = Enums.Value; // const v: Enums.Value\n\nclass Identifier {\n    readonly f = Enums.Value; // f: Enums.Value\n}\n`````\n\nКогда вывод типов встречает значение, принадлежащее к типу `symbol`, его поведение зависит от конструкции, которой присваивается значение. Так, если вывод типов работает с константой, то тип определяется как запрос типа (глава [“Type Queries (запросы типа), Alias (псевдонимы типа)”](../017.(Типы)%20Type%20Queries%20(запросы%20типа),%20Alias%20(псевдонимы%20типа))) самой константы. Если вывод типов устанавливает принадлежность к типу неизменяемого поля, то тип будет определен как `symbol`. Происходит так потому, что вместе с созданием нового экземпляра в системе будет определяться и новый символ, что противоречит правилам установленным для `Unique Symbol` (глава [“Типы - Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum”](../018.%28Типы%29%20Примитивные%20литеральные%20типы%20Number%2C%20String%2C%20Template%20String%2C%20Boolean%2C%20Unique%20Symbol%2C%20Enum)).\n\n`````ts\nconst v = Symbol(); // const v: typeof v\n\nclass Identifier {\n    readonly f = Symbol(); // f: symbol\n}\n`````"},{"key":"Вывод типов_3","elementId":"Vyvod_obektnyh_tipov","markdown":"## Вывод объектных типов\n\nС выводом объектных типов не связанно ничего необычного. Кроме того, поведение вывода типов одинаково для всех конструкций.\n\n`````ts\nclass ClassType {}\ninterface InterfaceType {}\n\ntype TypeAlias = number;\n\nlet typeInterface: InterfaceType;\nlet typeTypeAlias: TypeAlias;\n\nlet v0 = { a: 5, b: 'text', c: true }; // let v0: {a: number, b:string, c: boolean}\nconst v1 = { a: 5, b: 'text', c: true }; // const v1: {a: number, b: string, c: boolean}\n\nlet v3 = new ClassType(); // let v3: ClassType\nlet v4 = typeInterface; // let v4: InterfaceType\nlet v5 = typeTypeAlias; // let v5: number\n`````"},{"key":"Вывод типов_4","elementId":"Vyvod_tipa_dlya_polei_klassa_na_osnove_inicializacii_ih_v_konstruktore","markdown":"## Вывод типа для полей класса на основе инициализации их в конструкторе\n\nЕсли прочитать главу, посвященную конфигурации компилятора, станет известно, что при активном флаге `--noImplicitAny`, возникает ошибка, если тело класса включает поля без аннотации типа. Дело в том, что вывод типов расценивает поля без явной аннотации типа как принадлежащие к `any`, который как раз и не допускает активированный флаг `--noImplicitAny`.\n\n`````ts\nclass Square {\n    /**\n     * Поля без явной аннотации типа.\n     * Вывод типов определяет их\n     * принадлежность к типу any.\n     *\n     * (property) Square.area: any\n     * (property) Square.sideLength: any\n     *\n     * От этого возникает ошибка ->\n     * TS7008: Member 'area' implicitly has an 'any' type.\n     * TS7008: Member 'sideLength' implicitly has an 'any' type.\n     */\n    area;\n    sideLength;\n\n    constructor() {\n    }\n}\n`````\n\nНо, к счастью, тип полей без явной аннотации может быть автоматически выведен, если инициализация таких полей происходит в конструкторе.\n\n`````ts\nclass Square {\n    /**\n     * Поля без явной аннотации типа,\n     * но ошибки не возникает, поскольку\n     * вывод типов определяет их принадлежность\n     * к типу number, так как поле sideLength\n     * инициализируется в конструкторе его параметром,\n     * принадлежащим к типу number, а поле area инициализируется\n     * там же с помощью выражения, результат которого\n     * также принадлежит к типу number.\n     *\n     * (property) Square.area: number\n     * (property) Square.sideLength: number\n     */\n    area;\n    sideLength;\n\n    constructor(sideLength: number) {\n        this.sideLength = sideLength;\n        this.area = this.sideLength ** 2;\n    }\n}\n`````\n\n\nНе будет лишним сделать акцент на словах об инициализации в конструкторе, поскольку это условие является обязательным. При попытке инициализации полей вне тела конструктора будет вызвана ошибка, даже если инициализация производится в методе, вызываемом из конструктора.\n\n`````ts\nclass Square {\n    /**\n     * Error ->\n     * TS7008: Member 'area' implicitly has an 'any' type.\n     */\n    area;\n    sideLength;\n\n    constructor(sideLength: number) {\n        this.sideLength = sideLength;\n        this.init();\n    }\n\n    init(){\n        this.area = this.sideLength ** 2;\n    }\n}\n`````\n\nЕсли инициализация полей класса без аннотации по каким-то причинам может не состоятся, то тип будет выведен как объединение, включающее так же и тип `undefined`.\n\n`````ts\nclass Square {\n    /**\n     * [1] ...вывод типов определяет принадлежность\n     * поля sideLength как ->\n     *\n     * (property) Square.sideLength: number | undefined\n     */\n    sideLength;\n\n    constructor(sideLength: number) {\n        /**\n         * [0] Поскольку инициализация зависит от\n         * условия выражения, которое выполнится\n         * только во время выполнения программы...\n         */\n        if (Math.random()) {\n            this.sideLength = sideLength;\n        }\n    }\n\n    get area() {\n        /**\n         * [2] Тем не менее, возникает ошибка,\n         * поскольку операция возведения в степень\n         * производится над значением, которое может\n         * быть undefined\n         *\n         * Error ->\n         * Object is possibly 'undefined'.\n         */\n        return this.sideLength ** 2;\n    }\n}\n`````"},{"key":"Вывод типов_5","elementId":"Vyvod_obedinennyh_(Union)_tipov","markdown":"## Вывод объединенных (Union) типов\n\nС выводом типов объединения (глава [“Типы - Union, Intersection”](../016.(Типы)%20Типы%20-%20Union,%20Intersection)) связаны как очевидные, так и нет, случаи.\n\nК очевидным случаям можно отнести массив, состоящий из разных примитивных типов. В этом случае будет выведен очевидный тип _объединение_, которое определяется типами присутствующих в массиве примитивов.\n\n`````ts\nlet v = [0, 'text', true]; // let v: (string | number | boolean)[]\n`````\n\nВ случае получения любого элемента массива, вывод типов также установит принадлежность к объединенному типу.\n\n`````ts\nlet v = [0, 'text', true]; // let v: (string | number | boolean)[]\n\nlet item = v[0]; // let item: string | number | boolean\n`````\n\nНеочевидные особенности лучше всего начать с примера, в котором вывод типа определяет принадлежность значения к массиву, состоящему из обычных объектных типов.\n\n`````ts\nlet v = [\n    { a: 5, b: 'text' },\n    { a: 6, b: 'text' }\n]; // let v: { a: number, b: string }[]\n`````\n\nВ примере, вывод типов выводит ожидаемый и предсказуемый результат для массива объектов, чьи типы полностью идентичны. Идентичны они по той причине, что вывод типов установит тип `{a: number, b: string}` для всех элементов массива.\n\nНо стоит изменить условие, допустим, убрать объявление одного поля и картина кардинально изменится. Вместо массива обычных объектов, тип будет выведен, как массив объединенного типа.\n\n`````ts\nlet v = [\n    { a: 5, b: 'text' },\n    { a: 6 },\n    { a: 7, b: true }\n]; // let v: ({ a: number, b: string } | { a: number, b?: undefined } | { a: number, b: boolean })[]\n`````\n\nКак видно из примера выше, вывод типов приводит все объектные типы, составляющие тип объединение, к единому виду. Он добавляет к типам несуществующие в них, но существующие в других объектных типах, поля, декларируя их как необязательные (глава [“Операторы - Optional, Not-Null, Not-Undefined, Definite Assignment Assertion”](../031.%28Работа%20с%20типами%29%20Операторы%20-%20Optional%2C%20Not-Null%20Not-Undefined%2C%20Definite%20Assignment%20Assertion)). Сделано это для возможности конкретизировать тип любого элемента массива. Простыми словами, что бы не получить ошибку во время выполнения, любой элемент массива должен иметь общие для всех элементов признаки. Но так как в реальности, в объектах, некоторые члены вовсе могут отсутствовать, вывод типов, что бы повысить типобезопасность, декларирует их как необязательные. Таким образом он предупреждает разработчика о возможности возникновения ситуации, при которой эти члены будут иметь значение `undefined`, что и демонстрируется в примере ниже.\n\n`````ts\nlet v = [\n    { a: 5, b: 'text' },\n    { a: 6 },\n    { a: 7, b: true }\n]; // let v: ({ a: number, b: string } | { a: number, b?: undefined } | { a: number, b: boolean })[]\n\nlet a = v[0].a; // let a: number\nlet b = v[0].b; // let b: string | boolean | undefined\n`````\n\nЕсли в качестве значений элементов массива выступают экземпляры классов, не связанных отношением наследования, то они и будут определять тип объединение.\n\n`````ts\nclass A {\n    public a: number = 0;\n}\n\nclass B {\n    public a: string = '';\n    public b: number = 5;\n}\n\nlet v = [\n    new A(),\n    new B()\n]; // let v: (A | B)[]\n`````\n\nВ случае, если элементы массива являются экземплярами классов, связанных отношением наследования (_номинативная типизация_ [“Экскурс в типизацию - Совместимость типов на основе вида типизации”](../009.(Экскурс%20в%20типизацию)%20Совместимость%20типов%20на%20основе%20вида%20типизации)), то выводимый тип будет ограничен самым базовым типом.\n\n`````ts\nclass A {}\nclass B extends A { f0 = 0; }\nclass C extends A { f1 = ''; }\nclass D extends A { f2 = true; }\nclass E extends D { f3 = {}; }\n\nlet v3 = [new A(), new B(), new C(), new D(), new E()];  // let v3: A[]\nlet v4 = [new B(), new C(), new D(), new E()];  // let v4: (B | C | D)[]\n`````\n\nТе же самые правила применяются при выводе типа значения, возвращаемого тернарным оператором.\n\n`````ts\nclass A {}\nclass B extends A { f0 = 0; }\nclass C extends A { f1 = ''; }\nclass D extends A { f2 = true; }\nclass E extends D { f3 = {}; }\n\nlet v0 = false ? new A() : new B();  // let v0: A\nlet v1 = false ? new B() : new C();  // let v1: B | C\nlet v2 = false ? new C() : new D();  // let v2: C | D\n`````\n\nТак как выражение, расположенное в блоке тернарного оператора, вычисляется на этапе выполнения программы, вывод типов не может знать результата его вычисления на этапе компиляции. Поэтому, что бы не нарушить типобезопасность, он вынужден указывать объединенный тип, определяемый всеми блоками выражения."},{"key":"Вывод типов_6","elementId":"Vyvod_peresecheniya_(Intersection)_s_diskriminantnymi_polyami","markdown":"## Вывод пересечения (Intersection) с дискриминантными полями\n\nЕсли при определении типа пересечения, определяющее его множество включает больше одного типа, определяющего одноименные дискриминантные поля, принадлежащие к разным типам, то такое пересечение определяется как тип `never`. Данная тема подробно бала рассмотрены в главе [\"Типы - Discriminated Union\"](../033.%28Типы%29%20Дискриминантное%20объединение%20%28Discriminated%20Union%29)\n\n`````ts\ntype A = {\n    type: \"a\"; // дискриминантное поле\n\n    a: number;\n};\ntype B = {\n    type: \"b\"; // дискриминантное поле\n\n    b: number;\n};\ntype C = {\n    c: number;\n};\ntype D = {\n    d: number;\n};\n\n/**\n * Как видно, типы A и B\n * определяют одноименное\n * дискриминантное поле type,\n * принадлежащее к разным типам \"a\" и \"b\",\n * поэтому тип T будет определен\n * как тип never.\n *\n * type T = never\n */\n\ntype T = A & B & C & D;\n`````\n\nНо стоит обратить внимание, что речь идет только об одноименных полях принадлежащих к разным типам. То есть, если множество, определяющее пересечение, включает несколько типов с одноименными дискриминантными полями, принадлежащих к одному типу, то такое множество будет определено ожидаемым образом.\n\n`````ts\ntype A = {\n    type: \"a\"; // дискриминантное поле с типом a\n\n    a: number;\n};\ntype B = {\n    type: \"a\"; // дискриминантное поле с типом b\n\n    b: number;\n};\ntype C = {\n    c: number;\n};\ntype D = {\n    d: number;\n};\n\n/**\n * Как видно, типы A и B\n * по-прежнему определяют одноименные\n * дискриминантные поля type, но на этот\n * раз они принадлежат к одному типу \"a\",\n * поэтому тип T будет определен ожидаемым\n * образом.\n *\n *\n *\n * type T = A & B & C & D\n */\n\ntype T = A & B & C & D;\n`````"},{"key":"Вывод типов_7","elementId":"Vyvod_tipov_kortej_(Tuple)","markdown":"## Вывод типов кортеж (Tuple)\n\nНачать стоит с напоминания, что значение длины кортежа, содержащего элементы, помеченные как необязательные, принадлежит к типу объединению (`Union`), который составляют литеральные числовые типы.\n\n`````ts\nfunction f(...rest: [number, string?, boolean?]): [number, string?, boolean?] {\n    return rest;\n}\n\nlet l = f(5).length; // let l: 1 | 2 | 3\n`````\n\nКроме того, остаточные параметры (`...rest`), аннотированные с помощью параметра типа, рассматриваются и представляются выводом типа как принадлежащие к типу-кортежу.\n\n`````ts\nfunction f<T extends any[]>(...rest: T): T {\n    return rest;\n}\n\n// рассматриваются\n\nf(5); // function f<[number]>(rest_0: number): [number]\nf(5, ''); // function f<[number, string]>(rest_0: number, rest_1: string): [number, string]\nf(5, '', true); // function f<[number, string, boolean]>(rest_0: number, rest_1: string, rest_2: boolean): [number, string, boolean]\n\n// представляются\n\nlet v0 = f(5); // let v0: [number]\nlet v1 = f(5, ''); // let v1: [number, string]\nlet v2 = f(5, '', true); // let v2: [number, string, boolean]\n`````\n\nЕсли функция, определяющая остаточные параметры, принадлежащие к параметру типа, будет вызвана с аргументами, включающих массив, указанный при помощи расширяющего синтаксиса (_spread syntax_), то тип для него будет выведен в виде остаточного типа `...rest`.\n\n`````ts\nfunction tuple<T extends any[]>(...args: T): T {\n    return args;\n}\n\nlet numberAll: number[] = [0, 1, 2];\nlet v0 = tuple(5, '', true); // let v0: [number, string, boolean]\nlet v1 = tuple(5, ...numberAll); // let v1: [number, ...number[]]\nlet v2 = tuple(5, ...numberAll, ''); // let v2: [number, ...number[], string]\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Защитники типа","path":"Zashchitniki_tipa"},"nextPage":{"title":"Совместимость объектных типов (Compatible Object Types)","path":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)"}},"contentNavData":{"key":"Вывод типов","level":0,"index":39,"contentIndex":0,"section":"Типизация","title":"Вывод типов","path":"Vyvod_tipov","elementId":"Vyvod_tipov","children":[{"key":"Вывод типов_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Вывод типов - общие сведения","path":"Vyvod_tipov_-_obshchie_svedeniya","elementId":"Vyvod_tipov_-_obshchie_svedeniya"},{"key":"Вывод типов_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Вывод примитивных типов","path":"Vyvod_primitivnyh_tipov","elementId":"Vyvod_primitivnyh_tipov"},{"key":"Вывод типов_2","index":2,"contentIndex":3,"level":1,"section":"Типизация","title":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"Vyvod_primitivnyh_tipov_dlya_konstant_(const)_i_polei_tolko_dlya_chteniya_(readonly)","elementId":"Vyvod_primitivnyh_tipov_dlya_konstant_(const)_i_polei_tolko_dlya_chteniya_(readonly)"},{"key":"Вывод типов_3","index":3,"contentIndex":4,"level":1,"section":"Типизация","title":"Вывод объектных типов","path":"Vyvod_obektnyh_tipov","elementId":"Vyvod_obektnyh_tipov"},{"key":"Вывод типов_4","index":4,"contentIndex":5,"level":1,"section":"Типизация","title":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"Vyvod_tipa_dlya_polei_klassa_na_osnove_inicializacii_ih_v_konstruktore","elementId":"Vyvod_tipa_dlya_polei_klassa_na_osnove_inicializacii_ih_v_konstruktore"},{"key":"Вывод типов_5","index":5,"contentIndex":6,"level":1,"section":"Типизация","title":"Вывод объединенных (Union) типов","path":"Vyvod_obedinennyh_(Union)_tipov","elementId":"Vyvod_obedinennyh_(Union)_tipov"},{"key":"Вывод типов_6","index":6,"contentIndex":7,"level":1,"section":"Типизация","title":"Вывод пересечения (Intersection) с дискриминантными полями","path":"Vyvod_peresecheniya_(Intersection)_s_diskriminantnymi_polyami","elementId":"Vyvod_peresecheniya_(Intersection)_s_diskriminantnymi_polyami"},{"key":"Вывод типов_7","index":7,"contentIndex":8,"level":1,"section":"Типизация","title":"Вывод типов кортеж (Tuple)","path":"Vyvod_tipov_kortej_(Tuple)","elementId":"Vyvod_tipov_kortej_(Tuple)"}]},"pageDescription":"Вывод типов"},"__N_SSG":true}