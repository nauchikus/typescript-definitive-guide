{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/033.(Работа с типами) Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion/images/"},"sectionInfoAll":[{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","elementId":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion","markdown":"# Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion\n\nОператор `Optional`, помечающий члены и параметры как необязательные, довольно часто используется при разработке приложений. И если в понимании механизма его работы нет ничего сложного, то для идеологически связанного с ним оператора `Not-Null Not-Undefined` не все так очевидно."},{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_0","elementId":"Neobyazatelnye_polya,parametry_i_metody_(Optional_Fields,Parameters_and_Methods)","markdown":"## Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)\n\nВ _TypeScript_ существует возможность декларировать поля, методы и параметры как _необязательные_. Эта возможность позволяет исключать помеченные элементы из инициализации, вызовов и проверки на совместимость.\n\nПоле, параметр или метод помечается как _необязательный_ с помощью оператора вопросительного знака `?`. При объявлении полей и параметров, оператор помещается сразу после идентификатора `identifier?: Type`. Для методов оператор помещается между идентификатором и круглыми скобками `identifier?(): Type`.\n\n`````ts\ntype VoiceEvent = { \n    type: string\n    repeat?: number // необязательное поле\n};\n\ntype VoiceHandler = (event?: VoiceEvent) => void; // необязательный параметр функции\n\nclass Animal {\n   name?: number; // необязательное поле\n\n   voice?(): void {} // необязательный метод\n}\n`````\n\nТермины _поля_, _параметры_ и _методы_ делают данный оператор чересчур именитым. Поэтому в дальнейшем он будет упрощен до _“необязательного оператора”_.\n\nИз темы посвященной типу `undefined` стало известно, что он является подтипом всех типов. Это в свою очередь означает, что его единственное значение - `undefined` - можно присвоить в качестве значения любому другому типу.\n\n`````ts\n/** strictNullChecks: false */\n\nlet a: number = undefined; // Ok\nlet b: string = undefined; // Ok\nlet c: boolean = undefined; // Ok\nlet d: object = undefined; // Ok\nlet e: any = undefined; // Ok\n`````\n\nКогда у компилятора флаг `--strictNullChecks` установлен в `true`, тип `undefined` является подтипом только типа `any`. Это означает, что связать значение `undefined` можно только с типом `any`.\n\n`````ts\n/** strictNullChecks: true */\n\nlet a: number = undefined; // Error\nlet b: string = undefined; // Error\nlet c: boolean = undefined; // Error\nlet d: object = undefined; // Error\nlet e: any = undefined; // Ok\n`````\n\nКак было сказано в начале, _необязательное_ буквально означает, что параметр функции может быть не ассоциирован со значением, а поле или метод и вовсе не существовать в объекте. А как известно, неинициализированные члены объектов и параметры функции всегда принадлежат к типу `undefined`. Поэтому каждый раз, когда компилятор видит поля или параметры, помеченные как необязательные, он расценивает это как явное указание на сценарий, допускающий значение `undefined`, способное нарушить ожидаемый ход выполнения программы. И поскольку активация рекомендуемого флага `--strictNullChecks` запрещает присваивать значение `undefined` типам отличным от `undefined` или `any`, вывод типов берет на себя инициативу и помечает все необязательные конструкции как принадлежащие к объединению, включающее тип `undefined`.\n\n`````ts\n/** strictNullChecks: true */\n\nlet a: { field?: number }; // field: number | undefined\nlet b: { field?: string }; // field: string | undefined\nlet c: { field?: boolean }; // field: boolean | undefined\nlet d: (prop?: object) => void; // prop: object | undefined\nlet e: (prop?: any) => void; // prop: any\nlet f: (prop?: number | undefined) => void; // prop: number | undefined\n`````\n\nКогда флаг `--strictNullChecks` установлен в `false` и он встречает поля или параметры, помеченные как необязательные, он точно также понимает, что по сценарию допускается значение `undefined`. Но при этом он не добавляет к уже указанному типу тип `undefined` и даже не берет его в расчет при явном указании. Такое поведение связано с тем, что при неактивном флаге `--strictNullChecks`, тип данных `undefined` совместим со всеми остальными типами. Это, в свою очередь, освобождает поля и параметры от его явного указания.\n\n`````ts\n/** strictNullChecks: false */\n\nlet a: { field?: number }; // field: number\nlet b: { field?: string }; // field: string\nlet c: { field?: boolean }; // field: boolean\nlet d: (prop?: object) => void; // prop: object\nlet e: (prop?: any) => void; // prop: any\nlet f: (prop?: number | undefined) => void; // prop: number\n`````\n\nТакже стоит упомянуть, что необязательные поля необязательно должны содержать явную аннотацию.\n\n`````ts\ninterface IT1 {\n    f1?; // Ok -> f1?: any\n}\n\nclass T1 {\n    f1?; // Ok -> f1?: any\n    f2? = 0; // Ok -> f2?: number\n}\n`````\n\nПоскольку значение `undefined` присвоенное полю объекта далеко не то же самое, что отсутствие члена вовсе, при котором также возвращается `undefined`, в _TypeScript_ существует флаг `--exactOptionalPropertyTypes`, при активации которого, в подобных случаях будут возникать ошибки.\n\n`````ts\ntype T = {\n    a: number;\n    b?: string;\n}\n\nlet o: T = {\n    a: 5,\n    b: undefined // Error -> Type 'undefined' is not assignable to type 'string'.ts(2322)\n};\n`````"},{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_1","elementId":"Operator_!_(Non-Null_and_Non-Undefined_Operator)","markdown":"## Оператор ! (Non-Null and Non-Undefined Operator)\n\nОператор `Not-Null Not-Undefined`, при активной опции `--strictNullChecks`, в случаях, допускающих обращение к несуществующим членам, позволяет приглушать сообщения об ошибках.\n\nПростыми словами, когда в режиме `--strictNullChecks` происходит обращение к значению объекта или метода, которые могут иметь значение `null` или `undefined`, компилятор, с целью предотвращения возможной ошибки, накладывает запрет на операции обращения и вызова. Разрешить подобные операции возможно с помощью оператора `Not-Null Not-Undefined`, который обозначается восклицательным знаком `!`.\n\nЧтобы понять принцип оператора `Non-Null Non-Undefined`, достаточно представить слушатель события, у которого единственный параметр `event`, принадлежность которого указана к типу `UserEvent`, помечен как необязательный. Это означает, что помимо обусловленного типа `UserEvent`, параметр может принадлежать ещё и к типу `undefined`. А это значит, что при попытке обратится к какому-либо члену объекта события `event`, может возникнуть исключение, вызванное обращением через ссылку на `null` или `undefined`. С целью предотвращения исключения во время выполнения, компилятор, во время компиляции, выведет сообщение об ошибке, вызванной обнаружением потенциально опасного кода.\n\n`````ts\n/** strictNullChecks: true */\n\ntype UserEvent = { type: string };\n\n// параметр помечен как необязательный, поэтому тип выводится как event?: UserEvent | undefined \nfunction handler(event?: UserEvent): void {\n    // потенциальная ошибка, возможно обращение к полю несуществующего объекта\n    let type = event.type; // Error -> возможная ошибка во время выполнения\n}\n`````\n\nОбычно в таких случаях стоит изменить архитектуру, но если разработчик в полной мере осознает последствия, то компилятор можно настоятельно попросить закрыть глаза на потенциально опасное место при помощи оператора `Not-Null Not-Undefined`. При обращении к полям и свойствам объекта, оператор `Not-Null Not-Undefined` указывается перед оператором точка `object!.field`.\n\n`````ts\n/** strictNullChecks: true  */\n\ntype UserEvent = { type: string };\n\nfunction handler(event?: UserEvent): void {\n    // указываем компилятору, что берем этот участок кода под собственный контроль\n    let type = event!.type; // Ok\n}\n`````\n\nОператор `Not-Null Not-Undefined` нужно повторять каждый раз, когда происходит обращение к полям и свойствам объекта, помеченного как необязательный.\n\n`````ts\n/** strictNullChecks: true  */\n\ntype Target = { name: string };\n\ntype CurrentTarget = { name };\n\ntype UserEvent = {\n    type: string,\n    target?: Target,\n    currentTarget: CurrentTarget\n};\n\nfunction handler(event?: UserEvent): void {\n    let type = event!.type; // 1 !\n    let target = event!.target!.name; // 2 !\n    let currentTarget = event!.currentTarget.name; // 1 !\n}\n`````\n\nПри обращении к необязательным методам объекта, оператор `Not-Null Not-Undefined` указывается между идентификатором (именем) и круглыми скобками. Стоит обратить внимание, что когда происходит обращение к необязательному полю или свойству объекта, оператор `Not-Null Not-Undefined` указывается лишь один раз `optionalObject!.firstLevel.secondLevel`. При обращении к необязательному методу того же объекта, оператор `Not-Null Not-Undefined` указывается дважды `optionalObject!.toString!()`.\n\n`````ts\n/** strictNullChecks: true  */\n\ntype Target = { name: string };\n\ntype CurrentTarget = { name };\n\ntype UserEvent = {\n    type: string,\n    target?: Target,\n    currentTarget: CurrentTarget,\n    toString?(): string\n};\n\nfunction handler(event?: UserEvent): void {\n    let type = event!.type; // 1 !\n    let target = event!.target!.name; // 2 !\n    let currentTarget = event!.currentTarget.name; // 1 !\n    let meta = event!.toString!(); // 2 !\n}\n`````\n\nНужно повторить ещё раз, что оператор `Not-Null Not-Undefined`, при активном флаге `--strictNullChecks`, обязателен только в случаях, когда объект принадлежит к типу отличного от `any`.\n\n`````ts\n/** strictNullChecks: true  */\n\ntype Target = { name: string };\n\ntype CurrentTarget = { name };\n\ntype UserEvent = {\n    type: string,\n    target?: Target,\n    currentTarget: CurrentTarget,\n    toString?(): string,\n    valueOf(): any\n};\n\nfunction handler(event?: any): void {\n    let type = event.type; // 0 !\n    let target = event.target.name; // 0 !\n    let currentTarget = event.currentTarget.name; // 0 !\n    let meta = event.toString(); // 0 !\n    let value = event.valueOf(); // 0 !\n}\n`````\n\nИ, как было сказано в самом начале, правило оператора `Not-Null Not-Undefined`, применённое к необязательному оператору, идентично для всех полей и параметров, принадлежащих к типам `null` или `undefined`...\n\n`````ts\n/** strictNullChecks: true  */\n\ntype Target = { name: string };\n\ntype CurrentTarget = { name };\n\ntype UserEvent = {\n    type: string,\n    target?: Target,\n    currentTarget: CurrentTarget,\n    toString?(): string,\n    valueOf(): any\n};\n\nfunction handler(event: UserEvent | undefined): void {\n    let type = event.type; // Error\n    let target = event.target.name; // Error\n    let currentTarget = event.currentTarget.name; // Error\n    let meta = event.toString(); // Error\n    let value = event.valueOf(); // Error\n}\n`````\n\n...при условии, что они не будут принадлежать к типу `any`.\n\n`````ts\n/** strictNullChecks: true  */\n\ntype Target = { name: string };\n\ntype CurrentTarget = { name };\n\ntype UserEvent = {\n    type: string,\n    target?: Target,\n    currentTarget: CurrentTarget,\n    toString?(): string,\n    valueOf(): any\n};\n\nfunction handler(event: UserEvent | undefined | any): void {\n    let type = event.type; // Ok\n    let target = event.target.name; // Ok\n    let currentTarget = event.currentTarget.name; // Ok\n    let meta = event.toString(); // Ok\n    let value = event.valueOf(); // Ok\n}\n`````"},{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_2","elementId":"Operator_!_(Definite_Assignment_Assertion)","markdown":"## Оператор ! (Definite Assignment Assertion)\n\nДля повышения типобезопасности программы, правила, накладываемые опцией `--strictNullChecks` (глава [“Опции компилятора”](../060.(Компилятор)%20Опции%20компилятора)), действуют также на переменные, инициализирующиеся в чужом контексте.\n\n`````ts\nlet value: number;\n\ninitialize();\n\nconsole.log(value + value); // Error, обращение к переменной перед присвоением ей значения\n\nfunction initialize() {\n  value = 0;\n}\n`````\n\nЧтобы избежать ошибки при обращении к переменным, которые инициализированы в чужом контексте, нужно использовать _definite assignment assertions_. _Definite assignment assertions_ также указывается с помощью символа восклицательного знака (`!`) и располагается после идентификатора переменной. Указывая данный оператор каждый раз при обращении к переменной, разработчик сообщает компилятору, что берет на себя все проблемы, которые могут быть вызваны отсутствием значения у переменной.\n\n`````ts\nlet value: number;\n\ninitialize();\n\nconsole.log(value! + value!); // Ok, указание definite assignment assertion\n\nfunction initialize() {\n  value = 0;\n}\n`````"}],"githubFileInfo":{"lastUpdate":1632219400000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Аксессоры","path":"Aksessory"},"nextPage":{"title":"Обобщения (Generics)","path":"Obobshcheniya_(Generics)"}},"contentNavData":{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","level":0,"index":33,"contentIndex":0,"section":"Работа с типами","title":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion","elementId":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion","children":[{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_0","index":0,"contentIndex":1,"level":1,"section":"Работа с типами","title":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"Neobyazatelnye_polya,parametry_i_metody_(Optional_Fields,Parameters_and_Methods)","elementId":"Neobyazatelnye_polya,parametry_i_metody_(Optional_Fields,Parameters_and_Methods)"},{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_1","index":1,"contentIndex":2,"level":1,"section":"Работа с типами","title":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"Operator_!_(Non-Null_and_Non-Undefined_Operator)","elementId":"Operator_!_(Non-Null_and_Non-Undefined_Operator)"},{"key":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion_2","index":2,"contentIndex":3,"level":1,"section":"Работа с типами","title":"Оператор ! (Definite Assignment Assertion)","path":"Operator_!_(Definite_Assignment_Assertion)","elementId":"Operator_!_(Definite_Assignment_Assertion)"}]},"pageDescription":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion"},"__N_SSG":true}