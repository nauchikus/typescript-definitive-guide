{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/015.(Типы) Примитивный Тип Enum/images/"},"sectionInfoAll":[{"key":"Примитивный Тип Enum","elementId":"Primitivnyi_Tip_Enum","markdown":"# Примитивный Тип Enum\n\nПри создании приложений тяжело обойтись без большого количества специальных конфигурационных значений. Подобные значения разработчики выносят в отдельные классы со статическими свойствами или модули с константами, избавляя таким образом свой код от _магических значений_.\n\n_TypeScript_ привносит новую синтаксическую конструкцию называемую `Enum` (перечисление). `enum` представляет собой набор логически связанных констант, в качестве значений которых могут выступать как числа, так и строки."},{"key":"Примитивный Тип Enum_0","elementId":"Enum_(enum)_primitivnyi_perechislyaemyi_tip","markdown":"## Enum (enum) примитивный перечисляемый тип\n\n`Enum` — это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая такими примитивными типами, как `number` и `string`. `Enum` объявляется с помощью ключевого слова `enum`."},{"key":"Примитивный Тип Enum_1","elementId":"Perechisleniya_s_chislovym_znacheniem","markdown":"## Перечисления с числовым значением\n\nИдентификаторы-имена для перечислений `enum` принято задавать во множественном числе. В случае, когда идентификаторам констант значение не устанавливается явно, они ассоциируются с числовым значениями, в порядке возрастания, начиная с нуля. \n\n`````ts\nenum Fruits {\n    Apple, // 0\n    Pear, // 1\n    Banana // 2\n}\n`````\n\nТакже можно установить любое значение вручную.\n\n`````ts\nenum Citrus {\n    Lemon = 2, // 2\n    Orange = 4, // 4\n    Lime = 6 // 6\n}\n`````\n\nЕсли указать значение частично, то компилятор будет стараться соблюдать последовательность.\n\n`````ts\nenum Berries {\n    Strawberry = 1,\n    Raspberry, // 2\n    \n    Blueberry = 4,\n    Cowberry // 5\n}\n`````\n\nКомпилятор рассчитывает значение автоматически только на основе значения предыдущего члена перечисления. То есть, если первой и третей константе было установленно значение `10` и `20`.\n\n`````ts\nenum Keys {\n  A = 10,\n  B, // 11\n  C = 20,\n  D // 21\n}\n`````\n\nПоскольку `enum` позволяет разработчику задавать одинаковые значения своим константам, при частично устанавливаемых значениях нужно быть предельно внимательным, что бы не допустить ещё и повторений со стороны самого `enum`.\n\n`````ts\nenum Keys {\n  A = 10,\n  B, // 11\n  C = 10,\n  D // 11\n}\n`````\n\n\nВдобавок ко всему `enum` позволяет задавать _псевдонимы_ (_alias_). Псевдонимам устанавливается значение константы, на которую они ссылаются.\n\n`````ts\nenum Languages {\n    Apple, // en, value = 0\n    Apfel = Apple, // de, value = 0\n    LaPomme = Apple // fr, value = 0\n}\n`````\n\nПри обращении к константе перечисления через точечную нотацию, будет возвращено _значение_. А при обращении к перечислению с помощью скобочной нотации и указания значения в качестве ключа, будет возвращено _строковое представление идентификатора константы_.\n\n`````ts\nlet value: number = Fruits.Apple; // 0\nlet identificator: string = Fruits[value]; // “Apple”\n`````\n\nПоскольку `enum` представляет реальные значения без которых программа будет неработоспособна, он обязан оставаться в коде после компиляции. Поэтому, что бы быстрее понять `enum`, нужно посмотреть на него в скомпилированном конечном виде. Но прежде создадим его самостоятельно.\n\n_1 шаг._ Тем, кто ранее работал с `enum` уже известно, что он позволяет получать строковое представление константы, а также значение ассоциированное с ней. Поэтому для его создания требуется ассоциативный массив, коими в _JavaScript_ являются объекты. Назовем объект `Fruits` и передадим его в качестве аргумента в функцию `initialization`, которая будет содержать код его инициализации.\n\n`````ts\nlet Fruits = {};\n\nfunction initialization(Fruits){\n\n}\n`````\n\n_2 шаг._ Создадим поле с именем `Apple` и присвоим ему в качестве значения число `0`. \n\n`````ts\nlet Fruits = {};\n\nfunction initialization(Fruits) {\n    Fruits[\"Apple\"] = 0;\n}\n`````\n\n_3 шаг._ Ассоциация константа-значение произведена, осталось создать зеркальную ассоциацию значение-константа. Для этого создадим ещё одно поле у которого в качестве ключа будет выступать значение `0`, а в качестве значения — строковое представление константы, то есть имя.\n\n`````ts\nlet Fruits = {};\n\nfunction initialization(Fruits) {\n    Fruits[ \"Apple\" ] = 0;\n    Fruits[ 0 ] = \"Apple\";\n}\n`````\n\n_4 шаг._ Теперь сократим код, но начала вспомним, что результатом операции присваивания является значение правого операнда. Поэтому сохраним результат первого выражения в переменную `value`, а затем используем её в качестве ключа во втором выражении.\n\n`````ts\nlet Fruits = {};\n\nfunction initialization(Fruits) {\n    let value = Fruits[\"Apple\"] = 0; //, то же самое, что value = 0\n    Fruits[value] = \"Apple\"; //, то же самое, что Fruits[0] = \"Apple\";\n}\n`````\n\n_5 шаг._ Продолжим сокращать и в первом выражении откажемся от переменной `value`, а во втором выражении на её место поместим первое выражение. \n\n`````ts\nlet Fruits = {};\n\nfunction initialization( Fruits ){\n    Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n}\n`````\n\n_6 шаг._ Теперь проделаем, то же самое для двух других констант.\n\n`````ts\nlet Fruits = {};\n\nfunction initialization(Fruits) {\n    Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n    Fruits[Fruits[\"Lemon\"] = 1] = \"Lemon\";\n    Fruits[Fruits[\"Orange\"] = 2] = \"Orange\";\n}\n`````\n\n_7 шаг._ Теперь превратим функции `initialization` в самовызывающееся функциональное выражение и лучше анонимное.\n\n`````ts\nlet Fruits = {};\n\n(function(Fruits) {\n    Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n    Fruits[Fruits[\"Pear\"] = 1] = \"Pear\";\n    Fruits[Fruits[\"Banana\"] = 2] = \"Banana\";\n})(Fruits);\n`````\n\n_8 шаг._ И перенесем инициализацию объекта прямо на место вызова.\n\n`````ts\nlet Fruits;\n(function(Fruits) {\n    Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n    Fruits[Fruits[\"Pear\"] = 1] = \"Pear\";\n    Fruits[Fruits[\"Banana\"] = 2] = \"Banana\";\n})(Fruits || (Fruits = {}));\n`````\n\nПеречисление готово. Осталось сравнить созданное перечисление с кодом полученным в результате компиляции.\n\n`````ts\n// enum сгенерированный typescript compiler\nlet Fruits;\n(function (Fruits) {\n  Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n  Fruits[Fruits[\"Pear\"] = 1] = \"Pear\";\n  Fruits[Fruits[\"Banana\"] = 2] = \"Banana\";\n})(Fruits || (Fruits = {}));\n`````\n\nТеперь добавим в рассматриваемое перечисление псевдоним `LaPomme` (яблоко на французском языке) для константы `Apple`.\n\n`````ts\nenum Fruits {\n    Apple, // 0\n    Pear, // 1\n    Banana, // 2\n    \n    LaPomme = Apple // 0\n}\n`````\n\nИ снова взглянем на получившийся в результате компиляции код. Можно увидеть, что псевдоним создается так же, как обычная константа, но в качестве значения ему присваивается значение идентичное константе на которую он ссылается.\n\n`````ts\n(function (Fruits) {\n  Fruits[Fruits[\"Apple\"] = 0] = \"Apple\";\n  Fruits[Fruits[\"Lemon\"] = 1] = \"Lemon\";\n  Fruits[Fruits[\"Orange\"] = 2] = \"Orange\";\n  Fruits[Fruits[\"LaPomme\"] = 0] = \"LaPomme\"; // псевдоним\n})(Fruits || (Fruits = {}));\n`````"},{"key":"Примитивный Тип Enum_2","elementId":"Perechisleniya_so_strokovym_znacheniem","markdown":"## Перечисления со строковым значением\n\nПомимо значения принадлежащего к типу `number`, _TypeScript_ позволяет указывать значения с типом `string`.\n\n`````ts\nenum FruitColors {\n    Red = \"#ff0000\",\n    Green = \"#00ff00\",\n    Blue = \"#0000ff\"\n}\n`````\n\nНо в случае, когда константам присваиваются строки, ассоциируется только ключ со значением. Обратная ассоциация (значение-ключ) — отсутствует. Простыми словами, по идентификатору (имени константы) можно получить строковое значение, но по строковому значению получить идентификатор (имя константы) невозможно.\n\n`````ts\nvar FruitColors;\n(function (FruitColors) {\n    FruitColors[\"Red\"] = \"#ff0000\";\n    FruitColors[\"Green\"] = \"#00ff00\";\n    FruitColors[\"Blue\"] = \"#0000ff\";\n})(FruitColors || (FruitColors = {}));\n`````\n\nТем не менее остается возможность создавать _псевдонимы_ (_alias_).\n\n`````ts\nenum FruitColors {\n    Red = \"#ff0000\",\n    Green = \"#00ff00\",\n    Blue = \"#0000ff\",\n    \n    Rouge = Red, // fr \"#ff0000\"\n    Vert = Green, // fr \"#00ff00\"\n    Bleu = Blue // fr \"#0000ff\"\n}\n`````\n\nИ снова изучим скомпилированный код. Можно убедится, что псевдонимы создаются так же, как и константы. А значение присваиваемое псевдонимам идентично значению констант на которые они ссылаются.\n\n`````ts\nvar FruitColors;\n(function (FruitColors) {\n    FruitColors[\"Red\"] = \"#ff0000\";\n    FruitColors[\"Green\"] = \"#00ff00\";\n    FruitColors[\"Blue\"] = \"#0000ff\";\n    FruitColors[\"Rouge\"] = \"#ff0000\";\n    FruitColors[\"Vert\"] = \"#00ff00\";\n    FruitColors[\"Bleu\"] = \"#0000ff\";\n})(FruitColors || (FruitColors = {}));\n`````"},{"key":"Примитивный Тип Enum_3","elementId":"Smeshannoe_perechislenie_(mixed_enum)","markdown":"## Смешанное перечисление (mixed enum)\n\nЕсли в одном перечислении объявлены числовые и строковые константы, то такое перечисление называется _смешанным_ (_mixed enum_).\n\nСо смешанным перечислением связаны две неочевидные особенности. \n\nПервая из них заключается в том, что константам, которым значение не задано явно, присваивается числовое значение по правилам перечисления с числовыми константами.\n\n`````ts\nenum Stones {\n    Peach, // 0\n    Apricot = \"apricot\"\n}\n`````\n\nВторая особенность заключается в том, что если константа, которой значение не было присвоено явно, следует после константы со строковым значением, то такой код не скомпилируется. Причина заключается в том, что как было рассказано в главе _“Перечисления с числовым значением”_, если константе значение не было установлено явно, то её значение будет рассчитано, как значение предшествующей ей константе `+1`, либо `0`, в случае её отсутствия. А так как у предшествующей константы значение принадлежит к строковому типу, то рассчитать число на его основе не представляется возможным.\n\n`````ts\nenum Stones {\n    Peach, // 0\n    Apricot = \"apricot\",\n    Cherry, // Error\n    Plum // Error\n}\n`````\n\nДля разрешения этой проблемы в смешанном перечислении, константе, которая была объявлена после константы со строковым значением, необходимо задавать значение явно.\n\n`````ts\nenum Stones {\n    Peach, // 0\n    Apricot = \"apricot\",\n    Cherry = 1, // 1\n    Plum // 2\n}\n`````"},{"key":"Примитивный Тип Enum_4","elementId":"Perechislenie_v_kachestve_tipa_dannyh","markdown":"## Перечисление в качестве типа данных\n\nМожет возникнуть мысль использовать перечисление в качестве типа данных переменной или параметра. Это вполне нормальное желание, но нужно быть очень осторожным: в _TypeScript_ с перечислением связан один достаточно неприятный нюанс.\nДело в том, что пока в перечислении есть хотя бы одна константа с числовым значением, он будет совместим с типом `number`. Простыми словами, любое число проходит проверку совместимости типов с любым перечислением.\n\nФункцию, тип параметра которой является смешанным перечислением, благополучно получится вызвать как с константой перечисления в качестве аргумента, так и с любым числом. Вызвать эту же функцию с идентичной константе перечисления строкой уже не получится.\n\n`````ts\nenum Fruits {\n    Apple,\n    Pear,\n    Banana = \"banana\"\n}\n\nfunction isFruitInStore(fruit: Fruits): boolean {\n    return true;\n}\n\nisFruitInStore(Fruits.Banana); // ок\nisFruitInStore(123456); // ок\nisFruitInStore(\"banana\"); // Error\n`````\n\nЕсли перечисление содержит константы только со строковыми значениями, то совместимыми считаются только константы перечисления указанного в качестве типа.\n\n`````ts\nenum Berries {\n    Strawberry = \"strawberry\",\n    Raspberry = \"raspberry\",\n    Blueberry = \"blueberry\"\n}\n\nfunction isBerryInStory(berry: Berries): boolean {\n    return true;\n}\n\nisBerryInStory(Berries.Strawberry); // ок\nisBerryInStory(123456); // Error\nisBerryInStory(\"strawberry\"); // Error\n`````\n\nПоведение не совсем очевидное, поэтому не стоит забывать об этом при использовании перечислений в которых присутствуют константы с числовым значением в качестве типа."},{"key":"Примитивный Тип Enum_5","elementId":"Perechislenie_const_s_chislovym_i_strokovym_znacheniem","markdown":"## Перечисление const с числовым и строковым значением\n\nПеречисление `enum` объявленное с помощью ключевого слова `const` после компиляции не оставляет в коде привычных конструкций. Вместо этого компилятор встраивает литералы значений в места, в которых происходит обращение к значениям перечисления. Значения констант перечисления могут быть как числовыми, так и строковыми типами данных. Так же, как и в обычных перечислениях, в перечислениях объявленных с помощью ключевого слова `const`, есть возможность создавать _псевдонимы_ (_alias_) для уже объявленных констант.\n\nЕсли создать два перечисления `Apple` и `Pear`, у каждого из которых будет объявлена константа `Sugar` с числовым значением, то на основе этих констант можно рассчитать количество сахара в яблочно-грушевом соке. Присвоив результат операции сложения количества сахара в промежуточную переменную, мы получим хорошо читаемое, задекларированное выражение.\n\n`````ts\nconst enum Apple {\n    Sugar = 10\n}\n\nconst enum Pear {\n    Sugar = 10\n}\n\nlet calciumInApplePearJuice: number = Apple.Sugar + Pear.Sugar;\n`````\n\nПосле компиляции от перечисления не остается и следа, так как константы будут заменены числовыми литералами. Такое поведение называется _inline встраивание_.\n\n`````ts\nlet calciumInApplePearJuice = 10 + 10;\n`````\n\nОбращение к значению через точечную нотацию требует большего времени, чем обращение к литеральному значению напрямую. Поэтому код с inline конструкциями выполняется быстрее по сравнению с кодом, в котором происходит обращение к членам объекта. Прибегать к подобному подходу рекомендуется только в тех частях кода, которые подвержены высоким нагрузкам. За счет перечисления, объявленного с ключевым словом `const`, исходный код будет легко читаемым, а конечный код — более производительным.\n\nТип `enum` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."},{"key":"Примитивный Тип Enum_6","elementId":"Kogda_stoit_primenyat_enum?","markdown":"## Когда стоит применять enum?\n\nМожет возникнуть вопрос - _\"Когда использовать enum и стоит ли это делать с учетом закрепившейся привычки работы со статическими классами и константами?\"_.\n\nОтвет очевиден — безусловно стоит применять тогда, когда нужна двухсторонняя ассоциация строкового ключа с его числовым или строковым значением (проще говоря, карта _строковый ключ — числовое значение_\\_числовой ключ — строковое значение_).\n\nКроме того, `enum` лучше всего подходит для определения _дискриминантных полей_ речь о которых пойдет позже.\n\nНу а тем, кто считает, что скомпилированная конструкция `enum` отягощает их код и при этом они пользовались ранее транскомпилятором `Babel`, то ответьте себе на вопрос: _\"Почему вы это делали, если он добавляет в сотню раз больше лишнего кода?\"_. Рассуждение о том, что несколько лишних строк кода испортит или опорочит программу, является пустой тратой драгоценного времени.\n\nПоэтому если есть желание использовать `enum`, то делайте это. Мне не доводилось встречать приложения, в которых не было бы `enum`, константных классов и просто модулей с константами одновременно. И это более чем нормально."}],"githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown"},"nextPage":{"title":"Типы - Union, Intersection","path":"Tipy_-_Union,Intersection"}},"contentNavData":{"key":"Примитивный Тип Enum","level":0,"index":15,"contentIndex":0,"section":"Типы","title":"Примитивный Тип Enum","path":"Primitivnyi_Tip_Enum","elementId":"Primitivnyi_Tip_Enum","children":[{"key":"Примитивный Тип Enum_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Enum (enum) примитивный перечисляемый тип","path":"Enum_(enum)_primitivnyi_perechislyaemyi_tip","elementId":"Enum_(enum)_primitivnyi_perechislyaemyi_tip"},{"key":"Примитивный Тип Enum_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Перечисления с числовым значением","path":"Perechisleniya_s_chislovym_znacheniem","elementId":"Perechisleniya_s_chislovym_znacheniem"},{"key":"Примитивный Тип Enum_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Перечисления со строковым значением","path":"Perechisleniya_so_strokovym_znacheniem","elementId":"Perechisleniya_so_strokovym_znacheniem"},{"key":"Примитивный Тип Enum_3","index":3,"contentIndex":4,"level":1,"section":"Типы","title":"Смешанное перечисление (mixed enum)","path":"Smeshannoe_perechislenie_(mixed_enum)","elementId":"Smeshannoe_perechislenie_(mixed_enum)"},{"key":"Примитивный Тип Enum_4","index":4,"contentIndex":5,"level":1,"section":"Типы","title":"Перечисление в качестве типа данных","path":"Perechislenie_v_kachestve_tipa_dannyh","elementId":"Perechislenie_v_kachestve_tipa_dannyh"},{"key":"Примитивный Тип Enum_5","index":5,"contentIndex":6,"level":1,"section":"Типы","title":"Перечисление const с числовым и строковым значением","path":"Perechislenie_const_s_chislovym_i_strokovym_znacheniem","elementId":"Perechislenie_const_s_chislovym_i_strokovym_znacheniem"},{"key":"Примитивный Тип Enum_6","index":6,"contentIndex":7,"level":1,"section":"Типы","title":"Когда стоит применять enum?","path":"Kogda_stoit_primenyat_enum?","elementId":"Kogda_stoit_primenyat_enum?"}]},"pageDescription":"Примитивный Тип Enum"},"__N_SSG":true}