{"pageProps":{"innovationPage":{"key":"3.8_9","title":"3.8","path":"3.8","coverUrl":"https://github.com/nauchikus/typescript-definitive-guide/raw/master/what-is-new/3.8/metadata/cover.png","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"},"sections":[{"key":"3.8_6","title":"Импорт и экспорт только типа и флаг --importsNotUsedAsValues","tags":[],"markdown":"## Импорт и экспорт только типа и флаг --importsNotUsedAsValues\n\nМеханизм уточнения импорта и экспорта (`import\\export`) выступает в качестве указаний компилятору, что данную конструкцию следует воспринимать исключительно как тип. Форма уточняющего импорта и экспорта включает в себя ключевое слово `type` идущее следом за ключевым словом `import` либо `export`.\n\n`````ts\nimport type {Type} from \"./type\";\nexport type {Type};\n`````\n\nУточнению могут подвергаться только конструкции расцениваемые исключительно как типы (`interface`, `type alias` и `class`). \n\n`````ts\n// @file types.ts\n\nexport class ClassType {}\nexport interface IInterfaceType{}\nexport type AliasType = {};\n`````\n\n`````ts\n// @file index.js\n\nimport type {ClassType, IInterfaceType, AliasType} from \"./types\";\nexport type {ClassType, IInterfaceType, AliasType};\n`````\n\nЗначения к которым можно отнести как экземпляры объектов, так и функции (`function expression` и `function declaration`) уточнятся, как в отдельности так и в одной форме с типами, не могут.\n\n`````ts\n// @file types.ts\n\nexport class ClassType {}\nexport interface IInterfaceType{}\nexport type AliasType = {};\n\n\nexport const o = {};\n\nexport const fe = ()=>{};\nexport function fd(){}\n`````\n\n`````ts\n// @file index.js\n\n// import type {o, fe, fd} from \"./types\"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)\n// import type {o, fe, fd, ClassType, IInterfaceType, AliasType} from \"./types\"; // Error! Type-only import must reference a type, but 'o' is a value.ts(1361)\nimport {o, fe, fd} from \"./types\"; // Ok!\n\n\n// export type {o, fe, fd}; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)\n// export type {o, fe, fd, ClassType, IInterfaceType, AliasType} from \"./types\"; // Error! Type-only export must reference a type, but 'o' is a value.ts(1361)\nexport {o, fe, fd}; // Ok!\n`````\n\nКроме того, уточнённая форма импорта и экспорта не может одновременно содержать импорт\\экспорт по умолчанию и не по умолчанию.\n\n`````ts\n// @file types.ts\n\nexport default class DefaultExportType {}\nexport class ExportType {}\n`````\n\n`````ts\n// @file index.js\n\n/**\n * Error!\n * All imports in import declaration are unused.ts(6192)\n * A type-only import can specify a default import or named bindings, but not both.ts(1363)\n */\nimport type DefaultType, {ExportType} from \"./types\";\n`````\n\nТакже не будет лишним оговорить, что классы экспортированные как уточненные само собой разумеется не могут участвовать в механизме наследования.\n\n`````ts\n// @file Base.ts\n\nexport class Base {}\n`````\n\n`````ts\n// @file index.js\n\nimport type {Base} from \"./Base\";\n\nclass Derived extends Base{}; // 'Base' only refers to a type, but is being used as a value here.ts(2693)\n\n`````\n\nВ дополнение механизму уточнения формы импорта\\экспорта был добавлен флаг `--importsNotUsedAsValues` ожидаемый одно из трех значений. Но прежде чем познакомится с каждым предлагаю поглубже погрузится в природу возникновения необходимости в данном механизме.\n\nБольшинство разработчиков используя в повседневной работе механизм импорта\\экспорта даже не подозревают, что с ним связанно немало различных трудностей, которые возникают из-за механизмов призванных оптимизировать код. Но для начала рассмотрим несколько простых вводных примеров.\n\nПредставьте ситуацию при которой один модуль импортирует необходимый ему тип представленный такой конструкцией как `interface`.\n\n`````ts\n// @file IPerson.ts\n\nexport interface IPerson {\n    name: string;\n}\n`````\n\n`````ts\n\n// @file action.ts\n\nimport {IPerson} from \"./IPerson\";\n\nfunction action(person:IPerson){\n    // ...\n}\n`````\n\nПоскольку интерфейс является конструкцией присущей исключительно _TypeScript_, то не удивительно, что после компиляции от неё не останется и следа.\n\n`````js\n// после компиляции @file action.js\n\nfunction action(person){\n    // ...\n}\n`````\n\nТеперь представьте, что один модуль импортирует конструкцию представленную классом, который задействован в логике уже знакомой нам функции `action()`.\n\n`````ts\n// @file IPerson.ts\n\nexport interface IPerson {\n    name: string;\n}\n\nexport class Person {\n    constructor(readonly name:string){}\n\n    toString(){\n        return `[person ${this.name}]`;\n    }\n}\n\n`````\n\n`````ts\n// @file action.ts\n\nimport {IPerson} from \"./IPerson\";\nimport {Person} from \"./Person\";\n\n\nfunction action(person:IPerson){\n    new Person(person);\n}\n\n`````\n\n`````js\n// после компиляции @file action.js\n\nimport {Person} from \"./Person\";\n\n\nfunction action(person){\n    new Person(person);\n}\n\n`````\n\nВ этом случае класс `Person` был включён в скомпилированный файл поскольку необходим для правильного выполнения программы.\n\nА теперь представьте ситуацию когда класс `Person` задействован в том же модуле `action.ts`, но исключительно в качестве типа. Другими словами он не задействован в логике работы модуля.\n\n`````ts\n// @file Person.ts\n\nexport class Person {\n    constructor(readonly name:string){}\n\n    toString(){\n        return `[person ${this.name}]`;\n    }\n}\n`````\n\n`````ts\n\n// @file action.ts\n\nimport {Person} from \"./Person\";\n\n\nfunction action(person:Person){\n    //...\n}\n`````\n\nПодумайте, что должна включать в себя итоговая сборка? Если вы выбрали вариант идентичный первому, то вы совершенно правы! Поскольку класс `Person` используется в качестве типа, то нет смысла включать его в результирующий файл.\n\n`````js\n// после компиляции @file action.js\n\n\nfunction action(person){\n    //...\n}\n`````\n\nПодобное поведение кажется логичным и возможно благодаря механизму называемому _import elision_. Этот механизм определяет, что конструкции которые теоретически могут быть включены в скомпилированный модуль требуются ему исключительно в качестве типа. И как уже можно было догадаться именно с этим механизмом и связанны моменты мешающие оптимизаций кода. Тут-то и вступает в дело механизм уточнения формы импорта\\экспорта.\n\nМеханизм уточнения способен разрешить возникающие перед _import-elision_ трудности при ре-экспорте модулей предотвращению которых способствует установленный в значение `true` флаг `--isolatedModules`.\n\n`````ts\n// @file module.ts\nexport interface IActionParams{}\nexport function action(params:IActionParams){}\n`````\n\n`````ts\n// @file re-export.ts\n\nimport {IActionParams, action} from \"./module\";\n\n/**\n * [Error! ts <3.8] > Cannot re-export a type when the '--isolatedModules' flag is provided.ts(1205)\n * \n * [Error! ts >=3.8] > Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.ts(1205)\n */\nexport {IActionParams, action};\n\n\n/**\n * \n * Поскольку компиляторы как TypeScript так и Babel\n * в контексте файла неспособны определить является\n * ли конструкция IActionParams допустимой для JavaScript\n * существует вероятность возникновения ошибки. Простыми\n * словами механизмы обоих компиляторов не знаю нужно ли\n * удалять следы связанные с IActionParams из скомпилированного\n * .js кода или нет. Именно поэтому был добавлен флаг \n * --isolatedModules который предупреждает о опасной ситуации.\n */\n\n \n`````\n\nРассмотренный выше случай можно разрешить с помощью явного уточнения формы импорта\\экспорта.\n\n`````ts\n// @file re-export.ts\n\nimport {IActionParams, action} from \"./module\";\n\n/**\n * Явно указываем, что IActionParams это тип.\n */\nexport type {IActionParams};\nexport {action};\n\n`````\n\n\nСпециально введенный и ранее упомянутый флаг `--importsNotUsedAsValues`, как уже было сказано, ожидает одно из трех возможных на данный момент значений - `remove`, `preserve` или `error`.\n\nЗначение `remove` активирует или другими словами оставляет поведение реализуемое до версии `3.8`.\nЗначения `preserve` способно разрешить проблему возникающую при экспорте так называемых сайд-эффектов.\n\n`````ts\n// @file module-with-side-effects.ts\n\nfunction incrementVisitCounterLocalStorage(){\n    // увеличиваем счетчик посещаемости в localStorage\n}\n\nexport interface IDataFromModuleWithSideEffects{};\n\nincrementVisitCounterLocalStorage(); // ожидается, что вызов произойдет в момент подключения модуля\n`````\n\n`````ts\n// @file index.js\n\nimport {IDataFromModuleWithSideEffects} from \"./module\";\n\nlet data:IDataFromModuleWithSideEffects = {};\n\n/**\n * Несмотря на то, что модуль module.ts\n * задействован в коде, его содержимое\n * не будет включено в скомпилированную\n * программу, поскольку компилятор исключает\n * импорты конструкций не участвующих в её логике.\n * Таким образом функция incrementVisitCounterLocalStorage()\n * никогда не будет вызвана, а значит программа не будет\n * работать корректно! \n */\n\n`````\n`````js\n// после компиляции @file index.js\n\nlet data = {};\n\n/**\n * В итоге программе ничего не\n * известно о модуле module-with-side-effects.ts\n */\n`````\n\nРешение из ситуации описанной выше заключается в повторном указании импорта всего модуля. Но не всем такое решение кажется очевидным.\n\n`````ts\nimport {IDataFromModuleWithSideEffects} from \"./module-with-side-effects\";\nimport \"./module-with-side-effects\"; // импорт всего модуля\n\nlet data:IDataFromModuleWithSideEffects = {};\n`````\n\n`````js\n// после компиляции @file index.js\n\nimport \"./module-with-side-effects.js\";\n\nlet data = {};\n\n/**\n * Теперь программа выполнится так как и ожидалось.\n * То есть модуль module-with-side-effects.ts включен\n * в её состав.\n */\n`````\n\nПоэтому прежде всего начиная с версии `3.8` сама `ide` укажет на возможность уточнения импорта исключительно типов, что в свою очередь должно подтолкнуть на размышление об удалении импорта при компиляции.\n\n`````ts\nimport {IDataFromModuleWithSideEffects} from \"./module-with-side-effects\"; //This import may be converted to a type-only import.ts(1372)\n`````\n\nКроме того, флаг `preserve` в отсутствие уточнения поможет избавиться от повторного указания импорта. Простыми словами значение `preserve` указывает компилятору импортировать все модули полностью.\n\n\n`````ts\n// @file module-with-side-effects.ts\n\nfunction incrementVisitCounterLocalStorage(){\n    // увеличиваем счетчик посещаемости в localStorage\n}\n\nexport interface IDataFromModuleWithSideEffects{};\n\nincrementVisitCounterLocalStorage(); \n`````\n`````ts\n// @file module-without-side-effects.ts\n\nexport interface IDataFromModuleWithoutSideEffects{};\n`````\n`````ts\n// @file index.js\n\n\n// Без уточнения\nimport {IDataFromModuleWithSideEffects} from \"./module-with-side-effects\";\nimport {IDataFromModuleWithoutSideEffects} from \"./module-without-side-effects\";\n\n\nlet dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};\nlet dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};\n`````\n\n`````js\n// после компиляции @file index.js\n\nimport \"./module-with-side-effects\";\nimport \"./module-without-side-effects\";\n\nlet dataFromModuleWithSideEffects = {};\nlet dataFromModuleWithoutSideEffects = {};\n\n/**\n * \n * Несмотря на то, что импортировались\n * исключительно конструкции-типы, модули\n * были импортированы полностью.\n */\n`````\n\nВ случае уточнения поведение при компиляции останется прежним. То есть в импорты в скомпилированный файл включены не будут.\n \n`````ts\n// @file index.js\n\n\n// С уточнением\nimport type {IDataFromModuleWithSideEffects} from \"./module-with-side-effects\";\nimport type {IDataFromModuleWithoutSideEffects} from \"./module-without-side-effects\";\n\n\nlet dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};\nlet dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};\n`````\n\n`````js\n// после компиляции @file index.js\n\nlet dataFromModuleWithSideEffects = {};\nlet dataFromModuleWithoutSideEffects = {};\n\n/**\n * \n * Импорты отсутствуют.\n */\n`````\n\nЕсли же флагу `--importsNotUsedAsValues` задано значение `error`, то при импортировании типов без явного уточнения будет считаться ошибочным поведением.\n\n`````ts\n// @file index.js\n\n/**\n * \n * [0][1] Error > This import is never used as a value and must use 'import type' because the 'importsNotUsedAsValues' is set to 'error'.ts(1371)\n */\n\nimport {IDataFromModuleWithSideEffects} from \"./module-with-side-effects\";\nimport {IDataFromModuleWithoutSideEffects} from \"./module-without-side-effects\";\n\n\nlet dataFromModuleWithSideEffects:IDataFromModuleWithSideEffects = {};\nlet dataFromModuleWithoutSideEffects:IDataFromModuleWithoutSideEffects = {};\n`````\n\nСкомпилированный код выше после устранения ошибок, то есть после уточнения, включать в себя импорты не будет.\n\nВ заключение стоит заметить, что в теории уточнение такой конструкции, как класс, способно ускорить компиляцию, поскольку избавляет компилятор от ненужных проверок на вовлечении его в логику работы модуля. Ну и, кроме того, уточнения формы импорта\\экспорта, это ещё один способ сделать код более информативным.\n","githubFileInfo":{"lastUpdate":1633879471000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"}]},"path":"Import_i_eksport_tolko_tipa_i_flag_--importsNotUsedAsValues","elementId":"Import_i_eksport_tolko_tipa_i_flag_--importsNotUsedAsValues","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_2","title":"Закрытые поля ECMAScript","tags":[],"markdown":"## Закрытые поля ECMAScript\n\nПомимо сокрытия полей класса от внешней среды с помощью модификатора доступа `private`, присущего исключительно _TypeScript_, начиная с версии `3.8` появилась возможность прибегнуть к механизму предусмотренного спецификацией _ECMAScript_. Для того, что бы воспользоваться данным механизмом идентификаторы скрываемых полей должны начинаться с символа решетка `#`.\nДоступ к защищённому полю класса ограничивается областью видимости класса в котором оно объявлено, а при обращении к нему необходимо также указывать символ решетка.\n\n`````ts\nclass Animal {\n    #isLife:boolean = true; // защищенное поле класса\n\n    get isLife(){\n        return this.#isLife;\n    }\n}\n\nlet animal = new Animal();\nconsole.log(animal.isLife); // обращение к аксессору, а не защищенному полю\n`````\n\nПоскольку доступ ограничивается областью видимости класса, потомки не могут обращаться к защищенным полям своих предков.\n\n`````ts\nclass Animal {\n    #isLife:boolean = true; // защищенное поле класса\n}\nclass Bird extends Animal {\n    constructor(){\n        super();\n        this.#isLife; // Error! > Property '#isLife' is not accessible outside class 'Animal' because it has a private identifier.ts(18013)\n    }\n}\n`````\n\nВ отличии от модификатора доступа `private` данный механизм не может быть применен к методам класса, но так как за его появлением стоит спецификация _ECMAScript_, он продолжает действовать в скомпилированной программе. Именно поэтому, в отличии от сценария с модификатором доступа `private`, _потомки_ могут без страха нарушить ожидаемый ход выполнения программы объявлять защищенные поля чьи идентификаторы идентичны объявлениям в их _супер-классах_. \n\n`````ts\n// сценарий с модификатором доступа private\n\nclass Animal {\n    private _isLife:boolean = true;\n    \n}\n/**\n * Error!\n * \n * Class 'Bird' incorrectly extends base class 'Animal'.\n  Types have separate declarations of a private property '_isLife'.ts(2415)\n */\nclass Bird extends Animal {\n    private _isLife: boolean = false;\n\n}\n`````\n\n`````ts\n// сценарий с защищенными полями предусмотренными спецификацией ECMAScript\n\nclass Animal {\n    #isLife:boolean = true;\n    \n}\n/**\n * Ok!\n */\nclass Bird extends Animal {\n    #isLife: boolean = false;\n\n}\n`````\n\nИ в заключение стоит упомянуть, что существует несколько нюансов. Один из них заключается в том, что закрытые поля нельзя объявлять непосредственно в конструкторе.\n\n`````ts\nclass Animal {\n    // Parameter declaration expected.ts(1138)\n    constructor(#isLife = true){}\n    \n}\n`````\n\n\nДругой нюанс связан с тем, что код содержащий закрытые поля класса может быть скомпилирован исключительно в версии `es6` и выше.\n","githubFileInfo":{"lastUpdate":1616326333000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"Zakrytye_polya_ECMAScript","elementId":"Zakrytye_polya_ECMAScript","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_7","title":"await высшего уровня","tags":[],"markdown":"## await высшего уровня\n\nПоскольку современную разработку на языке _JavaScript_ сложно представить без таких конструкций как `Promise`, которые выглядят намного привлекательней при использовании совместно с таким механизмом активирующимся при помощи ключевого слова `await`. Но правилами установлено, что ключевое слово `await` должно указываться исключительно в функциях объявленных с использованием ключевого слова `async`. Это в свою очередь, в некоторых случаях вынуждало разработчиков объявлять не требующиеся им функции.\n\n`````ts\n/**\n * Применение ключевого слова await\n * требует объявления функции в которой\n * появляется потребность исключительно\n * из-за необходимости в ключевом слове async\n */\n\nconst run = async () => {\n    let hello = await Promise.resolve(`Hello`);\n    let world = await Promise.resolve(`World`);\n    \n    \n    return `${hello} ${world}!`\n};\n\nrun().then(greeting=> console.log(greeting));\n`````\n\nСоздатели спецификации _ECMScript_ обратили на это внимание и добавили в неё такой механизм, как `await` высшего уровня (_top-level await_). `await` высшего уровня позволяет избавиться от не требующейся функции.\n\n`````ts\n// @file index.js\n\n/**\n * Внимание, псевдо код!\n * Данный код находящийся\n * в файле index.js не считается\n * модулем. Объяснение дается далее\n * по содержанию. \n */\n\nlet hello = await Promise.resolve(`Hello`);\nlet world = await Promise.resolve(`World`);\n\nlet greeting = `${hello} ${world}!`;\n\nconsole.log(greeting);\n`````\n\nЕдинственное стоит всегда помнить, что высшим уровнем считается модуль, а файл в _TypeScript_ считается модулем тогда, когда включает в себя хотя бы одно упоминания импорта или экспорта. Поэтому не исключено, что в особых случаях появится необходимость приведения к модулю.\n\n`````ts\n// @file greeting-utils.ts\n\nexport const toMessage = (hello:string,world:string) => \n    `${hello} ${world}!`;\n`````\n\n`````ts\n// пример с import\n\nimport * as GreetingUtils from \"./greeting-utils\";\n\nlet hello = await Promise.resolve(`Hello`);\nlet world = await Promise.resolve(`World`);\n\nlet greeting = GreetingUtils.toMessage(hello, world);\n\nconsole.log(greeting);\n`````\n\n`````ts\n// пример с пустым экспортом\n\nlet hello = await Promise.resolve(`Hello`);\nlet world = await Promise.resolve(`World`);\n\nlet greeting = `${hello} ${world}!`;\n\nconsole.log(greeting);\n\nexport {};\n`````\n\nКроме того, поддержка `await` высшего уровня становится доступной при компиляции в версию начиная с `es2017`, а в качестве модулей выбрано `esnext` или `system`.\n","githubFileInfo":{"lastUpdate":1633879471000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"}]},"path":"await_vysshego_urovnya","elementId":"await_vysshego_urovnya","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_1","title":"Реализация новой формы ре-экспорта","tags":[],"markdown":"## Реализация новой формы ре-экспорта\n\nЗачастую появляется необходимость ре-экспорта содержимого модуля, как единую точку входа.\n\n`````ts\n// @file utils.ts\n\nexport const sum = (a:number, b:number) => a + b;\nexport const mul = (a:number, b:number) => a * b;\n`````\n\n`````ts\n// MathUtils.ts\n\nimport * as MathUtils from \"./utils\";\nexport {MathUtils};\n`````\n\nПодобное встречается столь часто, что в спецификацию _ECMAScript 2020_ была включена новая форма ре-экспорта всего содержимого.\n\n`````ts\nexport * as Identificator from \"path\";\n`````\n\nБлагодаря разработчикам языка _TypeScript_ такой вид ре-экспорта стал доступен начиная с версии `3.8`. Предыдущий пример с применением нового синтаксиса мог бы сократится до одной строчки.\n\n`````ts\n// MathUtils.ts\n\nexport * as MathUtils from \"./utils\";\n`````\n\n\n","githubFileInfo":{"lastUpdate":1599566033000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"Realizaciya_novoi_formy_re-eksporta","elementId":"Realizaciya_novoi_formy_re-eksporta","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_4","title":"Новая конфигурационная группа параметров watchOptions","tags":[],"markdown":"## Новая конфигурационная группа параметров watchOptions\n\nОптимально организовать наблюдение за файловой системой дело довольно не простое поскольку ресурсоемкость и энергозатратность сильно зависит как от _api_ платформы, так и от предоставляемых различными библиотеками деклараций. И это не удивительно, ведь ОС по-разному реализуют процесс наблюдения и тем самым затрудняют поддержание актуальности при интенсивном изменении отслеживаемых файлов. И, кроме того, только задумайтесь, сколько пакетов в директории _node_modules_ и каково суммарное количество строк предоставляемых ими деклараций _.d.ts_?\n\nПоэтому перед разработчиками _TypeScript_ всегда остро стояла задача максимально оптимизировать этот процесс. Как следствие в конфигурационном файле _tsconfig.json_ появилась новая группа для конфигурирования `watchOptions` позволяющая выбрать оптимальную стратегию в зависимости от самого проекта.\n\n`````json\n// tsconfig.json\n\n{\n    \"compilerOptions\": {},\n    // новое поле\n    \"watchOptions\": {\n\n    }\n}\n`````\n\nТак новая группа реализует четыре параметра - `watchFile`, `watchDirectory`, `fallbackPolling` и `synchronousWatchDirectory`.\n\n`````json\n// tsconfig.json\n\n{\n    \"compilerOptions\": {},\n    // новое поле\n    \"watchOptions\": {\n        \"watchFile\": \"...\",\n        \"watchDirectory\": \"...\",\n        \"fallbackPolling\": \"...\",\n        \"synchronousWatchDirectory\": \"...\"\n    }\n}\n`````\n\n- `watchFile`: стратегия наблюдения за отдельными файлами\n  - `fixedPollingInterval`: Проверять каждый файл на наличие изменений несколько раз в секунду с фиксированным интервалом.\n  - `priorityPollingInterval`: Проверять каждый файл на наличие изменений несколько раз в секунду, но использовать эвристику для проверки файлов определенных типов реже, чем других.\n  - `dynamicPriorityPolling`: Использовать динамическую очередь, в которой менее часто изменяемые файлы будут проверяться реже.\n  - `useFsEvents` [ПО УМОЛЧАНИЮ]: Пытаться использовать собственные события операционной системы / файловой системы для изменения файлов.\n  - `useFsEventsOnParentDirectory`: Пытаться использовать собственные события операционной системы/файловой системы для прослушивания изменений в каталогах, содержащих файл. Это может использовать меньше файловых наблюдателей, но также быть менее точным.\n- `watchDirectory`: стратегия наблюдения за целыми деревьями каталогов в системах, в которых отсутствует рекурсивная функция наблюдения за файлами.\n  - `fixedPollingInterval`: Проверять каждый каталог на наличие изменений несколько раз в секунду с фиксированным интервалом.\n  - `dynamicPriorityPolling`: Использовать динамическую очередь, в которой менее часто изменяемые каталоги будут проверяться реже.\n  - `useFsEvents`[ПО УМОЛЧАНИЮ]: Пытаться использовать собственные события операционной системы / файловой системы для изменений каталога.\n- `fallbackPolling`: при использовании событий файловой системы этот параметр определяет стратегию опроса, которая используется, когда в системе заканчиваются собственные наблюдатели файлов и / или не поддерживаются собственные средства просмотра файлов.\n  - `fixedPollingInterval`: см выше.\n  - `priorityPollingInterval`[ПО УМОЛЧАНИЮ]: см выше.\n  - `dynamicPriorityPolling`: см выше.\n- `synchronousWatchDirectory`: Отключить отложенное наблюдение за каталогами.\n  - `true`\n  - `false`[ПО УМОЛЧАНИЮ]\n\n\n\n","githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"Novaya_konfiguracionnaya_gruppa_parametrov_watchOptions","elementId":"Novaya_konfiguracionnaya_gruppa_parametrov_watchOptions","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_3","title":"Новый флаг --assumeChangesOnlyAffectDirectDependencies","tags":[],"markdown":"## Новый флаг --assumeChangesOnlyAffectDirectDependencies\n\nС помощью таких опций компилятора как `--watch` и `--incremental` можно значительно сократить время сборки проекта. Напомню, что первый активирует наблюдение за файлами, а второй устанавливает связи между ними при помощи генерации файла с метаинформацией .tsbuildinfo.\n\nНо на очень больших проектах этих мер по сокращению время сборки довольно недостаточно. Поэтому многие разработчики высказываются за сокращение время сборки в угоду точности проверок изменений. Итогом подобных рассуждений стал новый флаг компилятора `--assumeChangesOnlyAffectDirectDependencies` при активации которой компилятор не будет перепроверять\\перестраивать файлы, которые на основе метаинформации считаются затронутыми. Вместо этого будут пepeпpoвepятьcя\\перестраиваться только непосредственно изменённые файлы и файлы их импортирующие.\n\nПредставьте, что `fileA.ts` импортирует `fileB.ts`, который импортирует `fileC.ts`, который импортирует `fileD.td`.\n\nПри активном режиме `--watch` изменения в файле `fileD.ts` означает, что как минимум будут проверены `fileC.ts`, `fileB.ts` и `fileA.ts`. При активной опцией `--assumeChangesOnlyAffectDirectDependencies` проверке подвергнется лишь `fileA.ts` и `fileB.ts`.\n\nКак отмечают первые испытатели, данное нововведение в некоторых случаях сократило время сборки в 14 раз, что можно назвать очень значительным, когда компиляция длится четверть минуты.\n","githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"Novyi_flag_--assumeChangesOnlyAffectDirectDependencies","elementId":"Novyi_flag_--assumeChangesOnlyAffectDirectDependencies","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_0","title":"Модификаторы JSDocs","tags":[],"markdown":"## Модификаторы JSDocs\n\nКомпиляция _.js_ файлов доступная за флагом `allowJs` была бы не эффективной если бы отсутствовало аннотирование _JavaScript_ кода при помощи _JSDoc комментариев_ активируемых флагом `checkJs` или _комментарной директивой_ `// @ts-check`. Чтобы повысить эффективность данного механизма были добавлены новые _JSDoc_ директивы. Так компилятор _TypeScript_ получил поддержку модифицирующих директив как `@public`, `@private` и `@protected`, чье поведение полностью соответствует поведению одноименных модификаторов из _TypeScript_. Кроме того, без изменений остался список _членов класса_ к которым эти модификаторы могут быть применены (_поля_, _свойства_, _методы_ как экземпляра, так и самого класса).\n\n`````js\nclass Base {\n    constructor(){\n        /**@public */\n        this.public = 0;\n\n        /**@private */\n        this.private = 0;\n\n        /**@protected */\n        this.protected = 0;\n    }\n\n    /**@private */\n    method(){}\n}\n`````\n\nПомимо этого также был добавлен модификатор `/** @readonly */`, чьё поведение также полностью идентичное одноименному модификатору из _TypeScript_, который к тому же можно совмещать с другими модификаторами.\n\n`````js\nclass Base {\n    /**@readonly */\n    static READONLY = true;\n\n    /**@protected @readonly */\n    static PROTECTED_READONLY = true;\n}\n`````\n","githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"Modifikatory_JSDocs","elementId":"Modifikatory_JSDocs","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_5","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Более строгие проверки объединений имеющих с индексной сигнатурой","tags":[],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] Более строгие проверки объединений имеющих с индексной сигнатурой\n\nДо текущей версии типу объединения включающего тип с индексной сигнатурой было возможно присвоить значение имеющее поля неудовлетворяющие этой индексной сигнатуре. Начиная с версии `3.8` это поведение стало строже и описанный выше сценарий считается ошибочным.\n\n\n`````ts\nlet o0: { [key: string]: number } | { field: number };\n/**\n * [< v3.8] Ok\n * [>= v3.8] Error\n * Type 'string' is not assignable to type 'number'.ts(2322)\n */\no0 = { field: 5, dynamicKey: '' };\n\n\nlet o1: { [key: string]: number } | { [key: number]: number };\n/**\n * [< v3.8] Ok\n * [>= v3.8] Error\n * Type 'string' is not assignable to type 'number'.ts(2322)\n */\no1 = { dynamicKey: '' };\n`````\n","githubFileInfo":{"lastUpdate":1601113647000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"[KRITIChESKOE_IZMENENIE]_Bolee_strogie_proverki_obedinenii_imeushchih_s_indeksnoi_signaturoi","elementId":"[KRITIChESKOE_IZMENENIE]_Bolee_strogie_proverki_obedinenii_imeushchih_s_indeksnoi_signaturoi","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}},{"key":"3.8_8","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Тип object в JSDoc при активном флаге --noImplicitAny больше не расценивается как any","tags":[],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] Тип object в JSDoc при активном флаге --noImplicitAny больше не расценивается как any\n\nДо текущей версии тип `object` указанный в _JSDoc_ при активном флаге `--noImplicitAny` расценивался _TypeScript_ как тип `any`. Начиная с текущей версии поведение типа `object` синхронизировано с поведением реализуемым _TypeScript_.\n\n`````js\n/**\n * @param p0 {Object}\n * @param p1 {object}\n */\nexport function f(p0, p1){}\n`````\n\n`````ts\n// --noImplicitAny: true\n\nimport {f} from \"./jsdocs\";\n\n/**\n * [<  3.8] f(p0: Object, p1: any): void\n * [>= 3.8] f(p0: Object, p1: object): void\n */\n`````\n","githubFileInfo":{"lastUpdate":1616326333000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"path":"[KRITIChESKOE_IZMENENIE]_Tip_object_v_JSDoc_pri_aktivnom_flage_--noImplicitAny_bolshe_ne_rascenivaetsya_kak_any","elementId":"[KRITIChESKOE_IZMENENIE]_Tip_object_v_JSDoc_pri_aktivnom_flage_--noImplicitAny_bolshe_ne_rascenivaetsya_kak_any","version":{"version":"3.8","dateRelease":"February 20, 2020","datePublication":"February 20, 2020"}}]},"contentNavData":{"key":"3.8","level":0,"index":0,"contentIndex":0,"title":"3.8","path":"3.8","elementId":"3.8","children":[{"key":"Импорт и экспорт только типа и флаг --importsNotUsedAsValues_0","level":1,"index":1,"contentIndex":1,"title":"Импорт и экспорт только типа и флаг --importsNotUsedAsValues","path":"Import_i_eksport_tolko_tipa_i_flag_--importsNotUsedAsValues","elementId":"Import_i_eksport_tolko_tipa_i_flag_--importsNotUsedAsValues"},{"key":"Закрытые поля ECMAScript_1","level":1,"index":2,"contentIndex":2,"title":"Закрытые поля ECMAScript","path":"Zakrytye_polya_ECMAScript","elementId":"Zakrytye_polya_ECMAScript"},{"key":"await высшего уровня_2","level":1,"index":3,"contentIndex":3,"title":"await высшего уровня","path":"await_vysshego_urovnya","elementId":"await_vysshego_urovnya"},{"key":"Реализация новой формы ре-экспорта_3","level":1,"index":4,"contentIndex":4,"title":"Реализация новой формы ре-экспорта","path":"Realizaciya_novoi_formy_re-eksporta","elementId":"Realizaciya_novoi_formy_re-eksporta"},{"key":"Новая конфигурационная группа параметров watchOptions_4","level":1,"index":5,"contentIndex":5,"title":"Новая конфигурационная группа параметров watchOptions","path":"Novaya_konfiguracionnaya_gruppa_parametrov_watchOptions","elementId":"Novaya_konfiguracionnaya_gruppa_parametrov_watchOptions"},{"key":"Новый флаг --assumeChangesOnlyAffectDirectDependencies_5","level":1,"index":6,"contentIndex":6,"title":"Новый флаг --assumeChangesOnlyAffectDirectDependencies","path":"Novyi_flag_--assumeChangesOnlyAffectDirectDependencies","elementId":"Novyi_flag_--assumeChangesOnlyAffectDirectDependencies"},{"key":"Модификаторы JSDocs_6","level":1,"index":7,"contentIndex":7,"title":"Модификаторы JSDocs","path":"Modifikatory_JSDocs","elementId":"Modifikatory_JSDocs"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Более строгие проверки объединений имеющих с индексной сигнатурой_7","level":1,"index":8,"contentIndex":8,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Более строгие проверки объединений имеющих с индексной сигнатурой","path":"[KRITIChESKOE_IZMENENIE]_Bolee_strogie_proverki_obedinenii_imeushchih_s_indeksnoi_signaturoi","elementId":"[KRITIChESKOE_IZMENENIE]_Bolee_strogie_proverki_obedinenii_imeushchih_s_indeksnoi_signaturoi"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Тип object в JSDoc при активном флаге --noImplicitAny больше не расценивается как any_8","level":1,"index":9,"contentIndex":9,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Тип object в JSDoc при активном флаге --noImplicitAny больше не расценивается как any","path":"[KRITIChESKOE_IZMENENIE]_Tip_object_v_JSDoc_pri_aktivnom_flage_--noImplicitAny_bolshe_ne_rascenivaetsya_kak_any","elementId":"[KRITIChESKOE_IZMENENIE]_Tip_object_v_JSDoc_pri_aktivnom_flage_--noImplicitAny_bolshe_ne_rascenivaetsya_kak_any"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"3.7","path":"3.7"},"nextPage":{"title":"3.9","path":"3.9"}},"pageDescription":"Обзор нововведений и изменений для версии 3.8"},"__N_SSG":true}