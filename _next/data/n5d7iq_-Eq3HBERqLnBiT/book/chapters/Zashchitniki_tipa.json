{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/038.(Типизация) Защитники типа/images/"},"sectionInfoAll":[{"key":"Защитники типа","elementId":"Zashchitniki_tipa","markdown":"# Защитники типа\n\nПонимание механизмов, рассматриваемых в этой главе, научит определять конструкции, которые часто применяются на практике и способны сделать код более понятным и выразительным."},{"key":"Защитники типа_0","elementId":"Zashchitniki_Tipa_-_obshchee","markdown":"## Защитники Типа - общее\n\nПомимо того, что _TypeScript_ имеет достаточно мощную систему выявления ошибок на этапе компиляции, разработчики языка, не останавливаясь на достигнутом, безостановочно работают над сведением их к нулю. Существенным шагом к достижению цели было добавление компилятору возможности активируемой при помощи флага `--strictNullChecks`, запрещающей неявные операции в которых участвует значение `null` и `undefined`. Простыми словами, компилятор научили во время анализа кода выявлять ошибки, способные возникнуть при выполнении операций, в которых фигурируют значения `null` или `undefined`.\n\nПростейшим примером является операция получения элемента из dom-дерева при помощи метода `querySelector()`, который в обычном _нерекомендуемом_ режиме (с неактивной опцией `--strictNullChecks`) возвращает значение, совместимое с типом `Element`.\n\n`````ts\nconst stage: Element = document.querySelector('#stage');\n`````\n\nНо в строгом _рекомендуемом_ режиме (с активной опцией `--strictNullChecks`) метод `querySelector()` возвращает объединенный тип `Element | null`, поскольку искомое значение может попросту не существовать.\n\n`````ts\nconst stage: Element | null = document.querySelector('#stage');\n`````\n\nНе будет лишним напомнить, что на самом деле метод `querySelector` возвращает тип `Element | null` независимо от режима. Дело в том, что в обычном режиме тип `null` совместим с любыми типами. То есть, в случае отсутствия элемента в dom-дереве операция присваивания значения `null` переменной с типом `Element` не приведет к возникновению ошибки.\n\n`````ts\n// lib.es6.d.ts\ninterface NodeSelector {\n    querySelector(selectors: string): Element | null;\n}\n`````\n\nВозвращаясь к примеру с получением элемента из dom-дерева стоит сказать, что в строке кода, в которой происходит подписка элемента на событие, на этапе компиляции все равно возникнет ошибка, даже в случае, если элемент существует. Дело в том, что компилятор _TypeScript_ не позволит вызвать метод `addEventListener`, поскольку для него объект, на который ссылается переменная, принадлежит к типу `Element` ровно настолько же, насколько он принадлежит к типу `null`.\n\n`````ts\nconst stage: Element | null = document.querySelector('#stage');\nstage.addEventListener('click', stage_clickHandler); // тип переменной stage Element или Null?\n\nfunction stage_clickHandler(event: MouseEvent): void {}\n`````\n\nИменно из-за этой особенности или другими словами, неоднозначности, которую вызывает тип `Union`, в _TypeScript_, появился механизм называемый _защитниками типа_ (`Type Guards`).\n\n_Защитники типа_ — это правила, которые помогают выводу типов определить суженый диапазон типов для значения, принадлежащего к типу `Union`. Другими словами, разработчику предоставлен механизм, позволяющий с помощью выражений составить логические условия, проанализировав которые, вывод типов сможет сузить диапазон типов до указанного и выполнить над ним требуемые операции.\n\nПонятно, что ничего не понятно. Поэтому, прежде чем продолжить разбирать определение по шагам, нужно рассмотреть простой пример, способный зафиксировать картинку в сознании.\n\nПредставим два класса, `Bird` и `Fish`, в обоих из которых реализован метод `voice`. Кроме этого, в классе `Bird` реализован метод `fly`, а в классе `Fish` — метод `swim`. Далее представим функцию с единственным параметром, принадлежащему к объединению типов `Bird` и `Fish`. В теле этой функции без труда получится выполнить операцию вызова метода `voice` у её параметра, так как этот метод объявлен и в типе `Bird`, и в типе `Fish`. Но при попытке вызвать метод `fly` или `swim` возникает ошибка, так как эти методы не являются общими для обоих типов. Компилятор попросту находится в подвешенном состоянии и не способен самостоятельно определится.\n\n`````ts\nclass Bird {\n    public fly(): void {}\n    public voice(): void {}\n}\n\nclass Fish {\n    public swim(): void {}\n    public voice(): void {}\n}\n\nfunction move(animal: Bird | Fish): void {\n    animal.voice(); // Ok\n\n    animal.fly(); // Error\n    animal.swim(); // Error\n}\n`````\n\nДля того, что бы облегчить работу компилятору, _TypeScript_ предлагает процесс сужения множества типов, составляющих тип `Union`, до заданного диапазона, а затем закрепляет его за конкретной областью видимости в коде. Но, прежде чем диапазон типов будет вычислен и ассоциирован с областью, разработчику необходимо составить условия, включающие в себя признаки, недвусмысленно указывающие на принадлежность к нужным типам.\n\nИз-за того, что анализ происходит на основе логических выражений, область, за которой закрепляется суженый диапазон типов, ограничивается областью выполняемой при истинности условия.\n\nСтоит заметить, что от признаков, участвующих в условии, зависит место, в котором может находится выражение, а от типов, составляющих множество типа `Union`, зависит способ составления логического условия."},{"key":"Защитники типа_1","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_tipa_dannyh","markdown":"## Сужение диапазона множества типов на основе типа данных\n\nПри необходимости составления условия, в основе которого лежат допустимые с точки зрения _JavaScript_ типы, прибегают к помощи уже знакомых операторов как `typeof` и `instanceof`.\n \nК помощи оператора `typeof` прибегают тогда, когда хотят установить принадлежность к типам `number`, `string`, `boolean`, `object`, `function`, `symbol` или `undefined`. Если значение принадлежит к производному от объекта типу, то установить его принадлежность к типу определяемого классом и находящегося в иерархии наследования, можно при помощи оператора `instanceof`.\n\nКак уже было сказано, с помощью операторов `typeof` и `instanceof` составляется условие по которому компилятор может вычислить к какому конкретно типу или диапазону будет относиться значение в определяемой условием области.\n\n\n`````ts\n// Пример для оператора typeof\n\n\ntype ParamType = number | string | boolean | object | Function | symbol | undefined;\n\nfunction identifier(param: ParamType): void {\n    param; // param: number | string | boolean | object | Function | symbol | undefined\n\n    if (typeof param === 'number') {\n      param; // param: number\n    } else if (typeof param === 'string') {\n      param; // param: string\n    } else if (typeof param === 'boolean') {\n      param; // param: boolean\n    } else if (typeof param === 'object') {\n      param; // param: object\n    } else if (typeof param === 'function') {\n      param; // param: Function\n    } else if (typeof param === 'symbol') {\n      param; // param: symbol\n    } else if (typeof param === 'undefined') {\n      param; // param: undefined\n    }\n\n    param; // param: number | string | boolean | object | Function | symbol | undefined\n}\n`````\n\n\n`````ts\n// Пример для оператора instanceof\n\n\nclass Animal {\n    constructor(public type: string) {}\n}\n\nclass Bird extends Animal {}\nclass Fish extends Animal {}\nclass Insect extends Animal {}\n\n\nfunction f(param: Animal | Bird | Fish | Insect): void {\n    param; // param: Animal | Bird | Fish | Insect\n\n    if (param instanceof Bird) {\n        param; // param: Bird\n    } else if (param instanceof Fish) {\n        param; // param: Fish\n    } else if (param instanceof Insect) {\n        param; // param: Insect\n    }\n\n    param; // param: Animal | Bird | Fish | Insect\n}\n`````\n\nЕсли значение принадлежит к типу `Union`, а выражение состоит из двух операторов, `if` и `else`, значение находящиеся в операторе `else` будет принадлежать к диапазону типов не участвующих в условии `if`.\n\n\n`````ts\n// Пример для оператора typeof\n\n\nfunction f0(param: number | string | boolean): void {\n    param; // param: number | string | boolean\n\n    if (typeof param === 'number' || typeof param === 'string') {\n        param; // param: number | string\n    } else {\n        param; // param: boolean\n    }\n\n    param; // param: number | string | boolean\n}\n\nfunction f1(param: number | string | boolean): void {\n    param; // param: number | string | boolean\n\n    if (typeof param === 'number') {\n        param; // param: number\n    } else {\n        param; // param: string | boolean\n    }\n\n    param; // param: number | string | boolean\n}\n`````\n\n`````ts\n// Пример для оператора instanceof\n\n\nclass Animal {\n    constructor(public type: string) {}\n}\n\nclass Bird extends Animal {}\nclass Fish extends Animal {}\nclass Insect extends Animal {}\nclass Bug extends Insect {}\n\nfunction f0(param: Bird | Fish | Insect): void {\n    param; // param: Bird | Fish | Insect\n\n    if (param instanceof Bird) {\n        param; // param: Bird\n    } else if (param instanceof Fish) {\n        param; // param: Fish\n    } else {\n        param; // param: Insect\n    }\n\n    param; // param: Bird | Fish | Insect\n}\n\nfunction f1(param: Animal | Bird | Fish | Insect | Bug): void {\n    param; // param: Animal | Bird | Fish | Insect | Bug\n    if (param instanceof Bird) {\n        param; // param: Bird\n    } else if (param instanceof Fish) {\n        param; // param: Fish\n    } else {\n        param; // param: Animal | Insect | Bug\n    }\n\n    param; // param: Animal | Bird | Fish | Insect | Bug\n}\n`````\n\nКроме того, условия можно поместить в тернарный оператор. В этом случае область на которую распространяется сужение диапазона типов, ограничивается областью содержащей условное выражение.\n\nПредставьте функцию, которой в качестве единственного аргумента можно передать как значение, принадлежащее к типу `T`, так и функциональное выражение, возвращающее значение принадлежащие к типу `T`. Для того, что бы было проще работать со значением параметра, его нужно сохранить в локальную переменную, принадлежащую к типу `T`. Но прежде компилятору нужно помочь конкретизировать тип данных, к которому принадлежит значение.\n\nУсловие, как и раньше, можно было бы поместить в конструкцию `if`/`else`, но в таких случаях больше подходит тернарный условный оператор. Создав условие, в котором значение проверяется на принадлежность к типу, отличному от типа `T`, разработчик укажет компилятору, что при выполнении условия тип параметра будет ограничен типом `Function`, тем самым создав возможность вызвать параметр как функцию. Иначе значение, хранимое в параметре, принадлежит к типу `T`.\n\n\n`````ts\n// Пример для оператора typeof\n\n\nfunction f(param: string | (() => string)): void {\n  param; // param: string | (() => string)\n\n  let value: string = typeof param !== 'string' ? param() : param;\n\n  param; // param: string | (() => string)\n}\n`````\n\n`````ts\n// Пример для оператора instanceof\n\n\nclass Animal {\n    constructor(public type: string = 'type') {}\n}\n\nfunction identifier(param: Animal | (() => Animal)): void {\n    param; // param: Animal | (() => Animal)\n\n    let value: Animal = !(param instanceof Animal) ? param() : param;\n\n    param; // param: Animal | (() => Animal)\n}\n`````\n\nТак как оператор `switch` логически похож на оператор `if`/`else`, то может показаться, что механизм, рассмотренный в этой главе, будет применим и к нему. Но это не так. Вывод типов не умеет различать условия составленные при помощи операторов `typeof` и `instanceof` в конструкции `switch`."},{"key":"Защитники типа_2","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_priznakov_prisushchih_tipu_Tagged_Union","markdown":"## Сужение диапазона множества типов на основе признаков присущих типу Tagged Union\n\nПомимо определения принадлежности к единичному типу, диапазон типов, составляющих тип `Union`, можно сузить по признакам, характерным для типа `Tagged Union`.\n\nУсловия, составленные на основе идентификаторов варианта, можно использовать во всех условных операторах включая `switch`.\n\n`````ts\n// Пример для оператора if/else\n\n\nenum AnimalTypes {\n    Animal = \"animal\",\n    Bird = \"bird\",\n    Fish = \"fish\"\n}\n\nclass Animal {\n    readonly type: AnimalTypes = AnimalTypes.Animal;\n}\n\nclass Bird extends Animal {\n    readonly type: AnimalTypes.Bird = AnimalTypes.Bird;\n\n    public fly(): void {}\n}\n\nclass Fish extends Animal {\n    readonly type: AnimalTypes.Fish = AnimalTypes.Fish;\n\n    public swim(): void {}\n}\n\nfunction move(param: Bird | Fish): void {\n    param; // param: Bird | Fish\n\n    if (param.type === AnimalTypes.Bird) {\n        param.fly();\n    } else {\n        param.swim();\n    }\n\n    param; // param: Bird | Fish\n}\n`````\n\n`````ts\n// Пример для тернарного оператора (?:)\n\n\nfunction move(param: Bird | Fish): void {\n    param; // param: Bird | Fish\n\n    param.type === AnimalTypes.Bird ? param.fly() : param.swim();\n\n    param; // param: Bird | Fish\n}\n`````\n\n`````ts\n// Пример для оператора switch\n\n\nenum AnimalTypes {\n    Animal = \"animal\",\n    Bird = \"bird\",\n    Fish = \"fish\"\n}\n\nclass Animal {\n    readonly type: AnimalTypes = AnimalTypes.Animal;\n}\n\nclass Bird extends Animal {\n    readonly type: AnimalTypes.Bird = AnimalTypes.Bird;\n\n    public fly(): void {}\n}\n\nclass Fish extends Animal {\n    readonly type: AnimalTypes.Fish = AnimalTypes.Fish;\n\n    public swim(): void {}\n}\n\nfunction move(param: Bird | Fish): void {\n    param; // param: Bird | Fish\n\n    switch (param.type) {\n        case AnimalTypes.Bird:\n            param.fly(); // Ok\n            break;\n\n        case AnimalTypes.Fish:\n            param.swim(); // Ok\n            break;\n    }\n\n    param; // param: Bird | Fish\n}\n`````\n\nВ случаях, когда множество типа `Union` составляют тип `null` и/или `undefined`, а также только один конкретный тип, выводу типов будет достаточно условия подтверждающего существование значения отличного от `null` и/или `undefined`. Это очень распространенный случай при активной опции `--strictNullChecks`. Условие, с помощью которого вывод типов сможет установить принадлежность значения к типам, отличными от `null` и/или `undefined`, может использоваться совместно с любыми условными операторами.\n\n\n`````ts\n// Пример с оператором if/else\n\n\nfunction f(param: number | null | undefined): void {\n    param; // param: number | null | undefined\n\n    if (param !== null && param !== undefined) {\n        param; // param: number\n    }\n\n    // or\n\n    if (param) {\n        param; // Param: number\n    }\n\n    param; // param: number | null | undefined\n}\n`````\n\n`````ts\n// Пример с тернарным оператором (?:), оператором нулевого слияния (??, nullish coalescing) и логическим \"или\" (||)\n\n\nfunction f(param: number | null | undefined): void {\n    param; // param: number | null | undefined\n\n    var value: number = param ? param : 0;\n    var value: number = param ?? 0;\n    var value: number = param || 0;\n\n    param; // param: number | null | undefined\n}\n`````\n\n`````ts\n// Пример с оператором switch\n\n\nfunction identifier(param: number | null | undefined): void {\n    param; // param: number | null | undefined\n\n    switch(param) {\n        case null:\n            param; // param: null\n            break;\n\n        case undefined:\n            param; // param: undefined\n            break;\n\n        default: {\n            param; // param: number\n        }\n    }\n\n    param; // param: number | null | undefined\n}\n`````\n\nКроме этого, при активной опции `--strictNullChecks`, в случаях со значением, принадлежащем к объектному типу, вывод типов может заменить оператор `Not-Null Not-Undefined`. Для этого нужно составить условие, содержащее проверку обращения к членам, в случае отсутствия которых может возникнуть ошибка.\n\n`````ts\n// Пример с Not-Null Not-Undefined (с учетом активной опции --strictNullChecks)\n\n\nclass Ability {\n    public fly(): void {}\n}\n\nclass Bird {\n    public ability: Ability | null = new Ability();\n}\n\nfunction move(animal: Bird | null | undefined): void {\n    animal.ability // Error, Object is possibly 'null' or 'undefined'\n    animal!.ability // Ok\n    animal!.ability.fly(); // Error, Object is possibly 'null' or 'undefined'\n    animal!.ability!.fly(); // Ok\n}\n`````\n\n`````ts\n// Пример с защитником типа (с учетом активной опции --strictNullChecks)\n\n\nclass Ability {\n    public fly(): void {}\n}\n\nclass Bird {\n    public ability: Ability | null = new Ability();\n}\n\nfunction move(animal: Bird | null | undefined): void {\n    if (animal && animal.ability) {\n        animal.ability.fly(); // Ok\n    }\n\n    // или с помощью оператора optional chaining\n    if (animal?.ability) {\n        animal.ability.fly(); // Ok\n    }\n}\n`````"},{"key":"Защитники типа_3","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_dostupnyh_chlenov_obekta","markdown":"## Сужение диапазона множества типов на основе доступных членов объекта\n\nСужение диапазона типов также возможно на основе доступных (`public`) членов, присущих типам, составляющим диапазон (`Union`). Сделать это можно с помощью оператора `in`.\n\n`````ts\nclass A { public a: number = 10; }\nclass B { public b: string = 'text'; }\nclass C extends A {}\n\n\nfunction f0(p: A | B) {\n    if ('a' in p) {\n        return p.a;  // p: A\n    }\n\n    return p.b;  // p: B\n}\n\nfunction f1(p: B | C) {\n    if ('a' in p) {\n        return p.a;  // p: C\n    }\n\n    return p.b;  // p: B\n}\n`````"},{"key":"Защитники типа_4","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_funkcii,opredelennoi_polzovatelem","markdown":"## Сужение диапазона множества типов на основе функции, определенной пользователем\n\nВсе перечисленные ранее способы работают только в том случае, если проверка происходит в месте отведенном под условие. Другими словами, с помощью перечисленных до этого момента способов, условие проверки нельзя вынести в отдельный блок кода (функцию). Это могло бы сильно ударить по семантической составляющей кода, а также нарушить принцип разработки программного обеспечения, который призван бороться с повторением кода (_Don’t repeat yourself, DRY_ (не повторяйся)). Но, к счастью для разработчиков, создатели _TypeScript_ реализовали возможность определять пользовательские защитники типа.\n\nВ роли пользовательского защитника может выступать функция, функциональное выражение или метод, которые обязательно должны возвращать значения, принадлежащие к типу `boolean`. Для того, что бы вывод типов понял, что вызываемая функция не является обычной функцией, у функции вместо типа возвращаемого значения указывают предикат (предикат — это логическое выражение, значение которого может быть либо истинным `true`, либо ложным `false`).\n\nВыражение предиката состоит из трех частей и имеет следующий вид `identifier is Type`.\n\nПервым членом выражения является идентификатор, который обязан совпадать с идентификатором одного из параметров объявленных в сигнатуре функции. В случае, когда предикат указан методу экземпляра класса, в качестве идентификатора может быть указано ключевое слово `this`.\n\nСтоит отдельно упомянуть, что ключевое слово `this` можно указать только в сигнатуре метода, определенного в классе или описанного в интерфейсе. При попытке указать ключевое слово `this` в предикате функционального выражения, не получится избежать ошибки, если это выражение определяется непосредственно в `prototype`, функции конструкторе, либо методе объекта, созданного с помощью литерала.\n\n\n`````ts\n// Пример с функцией конструктором\n\n\nfunction Constructor() {}\n\nConstructor.prototype.validator = function(): this is Object { // Error\n    return true;\n};\n`````\n\n`````ts\n// Пример с литералом объекта\n\n\ninterface IPredicat {\n    validator(): this is Object; // Ok\n}\n\nvar object: IPredicat = { // Ok\n    validator(): this is Object { // Error\n        return this;\n    }\n};\n\nvar object: {validator(): this is Object} = { // Error\n    validator(): this is Object { // Error\n        return this;\n    }\n};\n`````\n\nКо второму члену выражения относится ключевое слово `is`, которое служит в качестве утверждения. В качестве третьего члена выражения может выступать любой тип данных.\n\n\n`````ts\n// Пример предиката функции (function)\n\n\nfunction isT1(p1: T1 | T2 | T3): p1 is T1 {\n    return p1 instanceof T1;\n}\n\nfunction identifier(p1: T1 | T2 | T3): void {\n    if (isT1(p1)) {\n        p1; // p1: T1\n    }\n}\n`````\n\n`````ts\n// Пример предиката функционального выражения (functional expression)\n\n\nconst isT2 = (p1: T1 | T2 | T3): p1 is T2 => p1 instanceof T2;\n\nfunction identifier(p1: T1 | T2 | T3): void {\n    if (isT2(p1)) {\n        p1; // p1: T2\n    }\n}\n`````\n\n`````ts\n// Пример предиката метода класса (static method)\n\n\nclass Validator {\n    public static isT3(p1: T1 | T2 | T3): p1 is T3 {\n        return p1 instanceof T3;\n    }\n}\n\nfunction identifier(p1: T1 | T2 | T3): void {\n    if (Validator.isT3(p1)) {\n        p1; // p1: T3\n    }\n}\n`````\n\nУсловие, на основании которого разработчик определяет принадлежность одного из параметров к конкретному типу данных, не ограничено никакими конкретными правилами. Исходя из результата выполнения условия `true` или `false`, вывод типов сможет установить принадлежность указанного параметра к указанному типу данных.\n\n`````ts\nclass Animal {}\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nclass Fish extends Animal {\n    public swim(): void {}\n}\n\nclass Insect extends Animal {\n    public crawl(): void {}\n}\n\nclass AnimalValidator {\n    public static isBird(animal: Animal): animal is Bird {\n        return animal instanceof Bird;\n    }\n\n    public static isFish(animal: Animal): animal is Fish {\n        return (animal as Fish).swim !== undefined;\n    }\n\n    public static isInsect(animal: Animal): animal is Insect {\n        let isAnimalIsNotUndefinedValid: boolean = animal !== undefined;\n        let isInsectValid: boolean = animal instanceof Insect;\n\n        return isAnimalIsNotUndefinedValid && isInsectValid;\n    }\n}\n\nfunction move(animal: Animal): void {\n    if (AnimalValidator.isBird(animal)) {\n        animal.fly();\n    } else if (AnimalValidator.isFish(animal)) {\n        animal.swim();\n    } else if (AnimalValidator.isInsect(animal)) {\n        animal.crawl();\n    }\n}\n`````\n\nПоследнее, о чем осталось упомянуть, что в случае, когда по условию значение не подходит ни по одному из признаков, вывод типов установит его принадлежность к типу `never`.\n\n`````ts\nclass Animal {\n    constructor(public type: string) {}\n}\n\nclass Bird extends Animal {}\nclass Fish extends Animal {}\n\nfunction move(animal: Bird | Fish): void {\n    if (animal instanceof Bird) {\n        animal; // animal: Bird\n    } else if (animal instanceof Fish) {\n        animal; // animal: Fish\n    } else {\n        animal; // animal: never\n    }\n}\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Утверждение типов (Type Assertion)","path":"Utverjdenie_tipov_(Type_Assertion)"},"nextPage":{"title":"Вывод типов","path":"Vyvod_tipov"}},"contentNavData":{"key":"Защитники типа","level":0,"index":38,"contentIndex":0,"section":"Типизация","title":"Защитники типа","path":"Zashchitniki_tipa","elementId":"Zashchitniki_tipa","children":[{"key":"Защитники типа_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Защитники Типа - общее","path":"Zashchitniki_Tipa_-_obshchee","elementId":"Zashchitniki_Tipa_-_obshchee"},{"key":"Защитники типа_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Сужение диапазона множества типов на основе типа данных","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_tipa_dannyh","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_tipa_dannyh"},{"key":"Защитники типа_2","index":2,"contentIndex":3,"level":1,"section":"Типизация","title":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_priznakov_prisushchih_tipu_Tagged_Union","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_priznakov_prisushchih_tipu_Tagged_Union"},{"key":"Защитники типа_3","index":3,"contentIndex":4,"level":1,"section":"Типизация","title":"Сужение диапазона множества типов на основе доступных членов объекта","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_dostupnyh_chlenov_obekta","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_dostupnyh_chlenov_obekta"},{"key":"Защитники типа_4","index":4,"contentIndex":5,"level":1,"section":"Типизация","title":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_funkcii,opredelennoi_polzovatelem","elementId":"Sujenie_diapazona_mnojestva_tipov_na_osnove_funkcii,opredelennoi_polzovatelem"}]},"pageDescription":"Защитники типа"},"__N_SSG":true}