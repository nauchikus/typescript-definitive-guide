{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/025.(Классы) Абстрактные классы (abstract classes)/images/"},"sectionInfoAll":[{"key":"Абстрактные классы (abstract classes)","elementId":"Abstraktnye_klassy_(abstract_classes)","markdown":"# Абстрактные классы (abstract classes)\n\nЕсли у всех начинающих разработчиков при размышлениях об интерфейсах возникают вопросы _\"когда и зачем их использовать\"_, то при размышлении об абстрактных классах к ним добавляются _\"чем они отличаются от интерфейсов и когда та или иная конструкция предпочтительней\"_. Ответы на эти вопросы вы найдете в данной главе, но для начала стоит рассмотреть общие характеристики."},{"key":"Абстрактные классы (abstract classes)_0","elementId":"Obshchie_harakteristiki","markdown":"## Общие характеристики\n\nВ _TypeScript_ объявление абстрактного класса отличается от объявления обычного только добавлением ключевого слова `abstract` перед ключевым словом `class`.\n\n`````ts\nabstract class Identifier {}\n`````\n\nАбстрактные классы также, как и обычные классы, могут расширять другие обычные и абстрактные классы и реализовывать интерфейсы.\n\n`````ts\ninterface IInterface {}\n\nclass StandardClass {}\n\n // абстрактный класс расширяет обычный класс и реализует интерфейс\nabstract class SuperAbstractClass extends StandardClass implements IInterface {}\n\n// абстрактный класс расширяет другой абстрактный класс\nabstract class SubAbstractClass extends SuperAbstractClass {} \n`````\n\nНесмотря на то, что абстрактный класс — все же класс, главное его отличие от обычного класса заключается в отсутствии возможности создания его экземпляров. Другими словами, нельзя создать экземпляр абстрактного класса.\n\n`````ts\nabstract class SuperAbstractClass {}\nclass SubStandardClass extends SuperAbstractClass {}\n\nlet v0: SuperAbstractClass = new SuperAbstractClass(); // Error, нельзя создавать экземпляры абстрактного класса\nlet v1: SuperAbstractClass = new SubStandardClass(); // Ok\nlet v2: SubStandardClass = new SubStandardClass(); // Ok\n`````\n\nАбстрактные классы могут содержать абстрактные члены, принадлежность к которым указывается с помощью ключевого слова `abstract`. Ключевое слово `abstract` можно применить к полям, свойствам (аксессоры) и методам абстрактного класса. При этом свойства и методы не должны иметь реализацию. В отличие от них, полям, помеченным как абстрактные, может быть присвоено значение по умолчанию.\n\n`````ts\nabstract class Identifier {\n    public abstract field: string = 'default value'; // реализация допустима\n    public abstract get prop(): string; // реализация не допустима\n    public abstract set prop(value: string); // реализация не допустима\n    \n    public abstract method(): void; // реализация не допустима\n}\n`````\n\nАбстрактный класс, расширяющий другой абстрактный класс, не обязан переопределять все абстрактные члены своего суперкласса. В отличие от абстрактных классов, обычные классы расширяющие абстрактные классы, обязанные переопределить все поля, свойства и методы, находящиеся в иерархической цепочке и помеченные ключевым словом `abstract`, если они не были реализованы предками ранее.\n\n`````ts\nabstract class SuperAbstractClass {\n    public abstract field: string; // объявление абстрактного поля\n}\n\nabstract class SubAbstractClass extends SuperAbstractClass {} // в абстрактных потомках допускается не переопределять абстрактные члены предков \n\nclass SubConcreteClass extends SubAbstractClass { // конкретный подкласс обязан переопределять абстрактные члены, если они...\n    public field: string;\n}\n\nclass SubSubConcreteClass extends SubConcreteClass {} // ... если они не были переопределены в классах-предках\n`````\n\nКак было сказано ранее, абстрактным полям может быть задано значение по умолчанию, но в этом случае обратится к нему могут только абстрактные классы в иерархии наследования. \n\n`````ts\nabstract class SuperAbstractClass {\n    public abstract field0: string = 'default value'; // объявление абстрактного поля со значением по-умолчанию\n    public abstract field1: string;\n    public abstract field2: string;\n}\n\nabstract class SubAbstractClass extends SuperAbstractClass {\n    public field1: string = this.field0; // переопределение абстрактного поля и инициализация его значением абстрактного поля, которому было присвоено значение по умолчанию в абстрактном предке\n} \n\nclass SubOnCreteClass extends SubAbstractClass {\n    public field0: string; // конкретному классу необходимо переопределить два абстрактных поля, так как в предках был переопределен только один член\n    public field2: string;\n}\n`````\n\nАбстрактные члены в полной мере удовлетворяют всем условиям реализации интерфейса. Другими словами, абстрактный класс, декларирующий реализацию интерфейса, может не реализовывать его члены, а лишь пометить их как абстрактные, тем самым переложить реализацию на своих потомков.\n\n`````ts\ninterface IInterface {\n    field: string;\n    method(): void;\n}\n\nabstract class AbstractSuperClass implements IInterface { // абстрактный класс декларирует реализацию интерфейса\n    public abstract field: string; // поле без реализации...\n    public abstract method(): void; // ...метод без реализации. Тем не менее ошибки не возникает\n}\n`````\n\nКроме абстрактных членов, абстрактные классы могут содержать обычные члены, обращение к которым ничем не отличается от членов, объявленных в обычных классах.\n\nКак правило, абстрактные классы реализуют только ту логику, которая не будет ни при каких обстоятельствах противоречить логике своих подклассов.\n\n`````ts\nabstract class AbstractSuperClass {\n    abstract name: string = \"AbstractSuperClass\";\n    \n    public toString(): string {\n        // реализация общего не абстрактного метода\n        return `[object ${this.name}]`;\n    }\n}\n\nclass FirstConcreteSubClass extends AbstractSuperClass {\n    public name: string = \"FirstConcreteSubClass\"; // реализуем абстрактное поле\n}\n\nclass SecondConcreteSubClass extends AbstractSuperClass {\n    public name: string = \"SecondConcreteSubClass\"; // реализуем абстрактное поле\n}\n\nlet first: FirstConcreteSubClass = new FirstConcreteSubClass();\nlet second: SecondConcreteSubClass = new SecondConcreteSubClass();\n\nfirst.toString(); // [object FirstConcreteSubClass] реализация в абстрактном предке\nsecond.toString(); // [object SecondConcreteSubClass] реализация в абстрактном предке\n`````"},{"key":"Абстрактные классы (abstract classes)_1","elementId":"Teoriya","markdown":"## Теория\n\nПришло время разобраться в теории абстрактных классов, а именно ответить на вопросы, которые могут возникнуть при разработке программ.\n\nИнтерфейс или абстрактный класс — частый вопрос, ответ на который не всегда очевиден. В действительности это абсолютно разные конструкции, как с точки зрения реализации, так и идеологии. Интерфейсы предназначены для описания публичного _api_, которое служит для сопряжения с программой. Кроме того, они не должны, а в _TypeScript_ и не могут, реализовывать бизнес логику той части, которую представляют. Они — идеальные кандидаты для реализации _слабой связанности_ (low coupling). При проектировании программ упор должен делаться именно на интерфейсы.\n\nАбстрактные классы, при необходимости, должны реализовывать интерфейсы в той же степени и для тех же целей, что и обычные классы. Их однозначно нужно использовать в качестве базового типа тогда, когда множество логически связанных классов имеет общую для всех логику, использование которой в чистом виде не имеет смысла. Другими словами, если логика размещенная в классе не может или не должна выполнятся отдельно от потомков, то необходимо запретить создание экземпляров подобных классов.\n\nК примеру, абстрактный класс `Animal`, реализующий интерфейс `IAnimal` с двумя членами: свойством `isAlive` и методом `voice`, может и должен реализовать свойство `isAlive`, так как это свойство имеет заранее известное количество состояний (жив или мертв) и не может отличаться в зависимости от потомка. В, то время как метод `voice` (подать голос) как раз таки будет иметь разную реализацию, в зависимости от потомков, ведь коты мяукают, а вороны каркают.\n\nТем не менее, резонно может возникнуть вопрос, а почему бы не вынести этот функционал в обычный, базовый класс?\n\nАбстрактный класс способен не только подсказать архитектору, что данная сущность является абстрактной для предметной области, то есть не является самостоятельной частью, но также не позволит создать экземпляр класса, работа которого может сломать приложение.\n\nЕще раз тоже самое, но другими словами. Поскольку базовый класс будет реализовывать логику, предполагаемую интерфейсами, разбитыми по принципу разделения интерфейсов, с помощью которых и будет происходить сопряжение с остальными частями программы, то существует возможность попадания его экземпляра в места, предполагающие логику отсутствующую в нем. То есть высокоуровневая логика, присущая только потомкам, может быть сокрыта за менее специфичным интерфейсом, реализуемым самим базовым классом. Чтобы избежать подобных сценариев допускающих возникновение ошибок во время выполнения, необходимо запретить создание экземпляров подобных классов. (Принцип разделения интерфейсов рассматривается в главе [“Типы - Interface”](../021.(Типы)%20Interfaces))\n\nКроме того, абстрактный класс с помощью абстрактных членов не даст разработчику забыть реализовать необходимую логику в потомках.\n\nНо и это ещё не все. Интерфейс `IAnimal` в реальности будет составным типом. То есть, он будет принадлежать к типу `ILiveable`, описывающему свойство `isAlive` и типу `IVoiceable`, описывающему метод `voice`. Реализовать подобное с помощью абстрактного класса не получится, так как класс может расширять только один другой класс, в, то время как интерфейсы могут расширять множество других интерфейсов, и следовательно, принадлежит ко множеству типов данных одновременно. Как раз это и демонстрирует интерфейс `IAnimal` расширяя интерфейсы `ILiveable` и `IVoiceable`.\n\nЕщё часто можно встретить вопрос о замене интерфейсов абстрактными классами. Технически абстрактный класс состоящий только из абстрактных членов, может исполнять роль идеологически отведенную интерфейсу. Но об этом лучше забыть, поскольку для описания открытой части объекта предназначен интерфейс."}],"githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Закрытые поля определенные спецификацией ECMAScript","path":"Zakrytye_polya_opredelennye_specifikaciei_ECMAScript"},"nextPage":{"title":"Полиморфный тип this","path":"Polimorfnyi_tip_this"}},"contentNavData":{"key":"Абстрактные классы (abstract classes)","level":0,"index":25,"contentIndex":0,"section":"Классы","title":"Абстрактные классы (abstract classes)","path":"Abstraktnye_klassy_(abstract_classes)","elementId":"Abstraktnye_klassy_(abstract_classes)","children":[{"key":"Абстрактные классы (abstract classes)_0","index":0,"contentIndex":1,"level":1,"section":"Классы","title":"Общие характеристики","path":"Obshchie_harakteristiki","elementId":"Obshchie_harakteristiki"},{"key":"Абстрактные классы (abstract classes)_1","index":1,"contentIndex":2,"level":1,"section":"Классы","title":"Теория","path":"Teoriya","elementId":"Teoriya"}]},"pageDescription":"Абстрактные классы (abstract classes)"},"__N_SSG":true}