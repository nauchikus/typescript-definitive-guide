{"pageProps":{"innovationPage":{"key":"4.5@beta_14","title":"4.5@beta","path":"4.5@beta","coverUrl":"https://github.com/nauchikus/typescript-definitive-guide/raw/master/what-is-new/4.5@beta/metadata/cover.png","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"},"sections":[{"key":"4.5@beta_6","title":"Поддержка ECMAScript модулей в NodeJs","tags":["Улучшение"],"markdown":"## Поддержка ECMAScript модулей в NodeJs\n\nНачиная с текущей версии _TypeScript_ реализует поддержку _ECMAScript_ (ESM) модулей в среде _nodejs_. Для активации данного функционала, в `tsconfig.json` необходимо задать свойству `module` значение `nodenext`.\n\n\n`````json\n{\n    \"compilerOptions\": {\n        \"module\": \"nodenext\",\n    }\n}\n`````\n\nОсновные правила придерживаются спецификации _ECMAScript_, но существует один момент, о котором стоит упомянуть.\n\nВ случае активации _esm_ в `package.json` и выборе модулей `nodenext` относительные пути в импортах требуют уточнение расширения, как `.js`. Другими словами импорт файла `file.(ts|tsx|js|jsx)` должен выглядить, как `import \"./file.js\"`, а не `import \"./file\"`.\n\n\n`````ts\n// file f.ts\n\nexport const f = () => {};\n\n\n// file index.ts\n\nimport {f} from \"./f\"; // Error\nimport {f} from \"./f.js\"; // Ok\n`````\n\nКак известно, при реализации `esm` в _nodejs_ появилась поддержка двух новых форматов файлов - `.mjs` для _ECMAScript_ модулей и `.cjs` для _CommonJs_ модулей. Следуя этому, в _TypeScript_ также появилась поддержка двух новых расширений `.mts` и `.cts`, и кроме того `.d.mts` и `.d.cts`.\n\n\n_ECMAScript_ позволяют импортировать _CommonJs_ модули таким образом, как если бы они имели экспор по умолчанию.\n\n`````ts\n// file f.сts\n\nexport const f = () => {};\n\n\n// file index.ьts\n\nimport f from \"./f\";\n`````\n\nКроме этого, после реализации `esm` _nodejs_, в `package.json` было добавлено новое свойство `exports` позволяющее конкретизировать точки входа.\n\n`````json\n// package.json\n\n// package.json\n{\n    \"type\": \"module\",\n    \"exports\": {\n        \".\": {\n            \"import\": \"./esm/index.js\",\n            \"require\": \"./commonjs/index.cjs\",\n        },\n    },\n\n    // для поддержки старых версий\n    \"main\": \"./commonjs/index.cjs\",\n}\n`````\n\nТаким образом, _TypeScript_ также добавляет новую возможность указания деклараций типов.\n\n`````json\n// package.json\n{\n    \"type\": \"module\",\n    \"exports\": {\n        \".\": {\n            \"import\": \"./esm/index.js\",\n            \"require\": \"./commonjs/index.cjs\",\n\n\n            \"types\": \"./types/index.d.ts\"\n        },\n    },\n\n    // для поддержки старых версий\n    \"main\": \"./commonjs/index.cjs\",\n    \"types\": \"./types/index.d.ts\"\n}\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Podderjka_ECMAScript_modulei_v_NodeJs","elementId":"Podderjka_ECMAScript_modulei_v_NodeJs","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_9","title":"Поддержка lib из node_modules","tags":["Нововведение"],"markdown":"## Поддержка lib из node_modules\n\nВместе с изменениями самого языка_TypeScript_ изменяеются и его библиотеки описывающие api _JavaScript_. Это является основной проблемой при переходе на новую версию, что чаще всего особенно заметно в контексте _DOM API_. Поэтому, неачиная с текущей версии _TypeScript_ позволяет устанавливать конкретные версии библиотек входящих в групперовку `lib`.\nТочно также, как компилятор начинает поиск обычных декларации с директории `node_modules/@types`, поиск библиотечных деклараций будет осуществлятся с директории `node_modules/#typescript/lib-*`.\n\nТаким образом разработчики самостоятельно смогут устанавливать конкретные версии библиотек при помощи _@types_ менеджера. \n\n`````bash\n> npm i -D @types/web \n`````\n`````json\n// package.json\n{\n \"devDependencies\": {\n    \"@typescript/lib-dom\": \"npm:@types/web\"\n  }\n}\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Podderjka_lib_iz_node_modules","elementId":"Podderjka_lib_iz_node_modules","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_5","title":"Тип Awaited","tags":["Нововведение"],"markdown":"## Тип Awaited\n\nНовый расширенный тип `Awaited<T>` предназначен для рекурсивного развертывания промисов, поможет без труда указывать тип, к которому принадлежит результат асинхронных операций.\n\n`````ts\n// A = string\ntype A = Awaited<Promise<string>>;\n\n// B = string\ntype B = Awaited<Promise<Promise<string>>>;\n\n// C = string | number\ntype C = Awaited<string | Promise<number>>;\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Tip_Awaited","elementId":"Tip_Awaited","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_2","title":"Указание шаблонного литерального строкового типа в качестве дискриминанта","tags":["Нововведение"],"markdown":"## Указание шаблонного литерального строкового типа в качестве дискриминанта\n\nНачиная с текущей версии, в качестве дескременантного типа можно указывать шаблонный строковой литеральный тип.\n\n`````ts\ninterface Success {\n    type: `${string}Success`;\n    body: string;\n}\n\ninterface Error {\n    type: `${string}Error`;\n    message: string;\n}\n\nfunction handler(result: Success | Error) {\n    if (result.type === \"HttpSuccess\") {\n        let token = result.body;\n    }\n}\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Ukazanie_shablonnogo_literalnogo_strokovogo_tipa_v_kachestve_diskriminanta","elementId":"Ukazanie_shablonnogo_literalnogo_strokovogo_tipa_v_kachestve_diskriminanta","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_0","title":"Стабильная поддержка --module es2022","tags":["Улучшение"],"markdown":"## Стабильная поддержка --module es2022\n\nНачиная с текущей версии _TypeScript_ реализует стабильную поддержку модулей `es2022`, основная цель которых указания ключевого слова `await` вне тела функции помеченной, как `async`. Данное поведение активируется при указании свойсту `module` значений `esnext` или `nodenext` для _nodejs_.","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Stabilnaya_podderjka_--module_es2022","elementId":"Stabilnaya_podderjka_--module_es2022","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_11","title":"Исключение хвостовой рекурсии на условных типа","tags":["Улучшение"],"markdown":"## Исключение хвостовой рекурсии на условных типа\n\nБезусловно, рекурсивные типы значительно упращают написание кода, но из-за ограничений связанных с бесконечным циклом не могут показать себя полность.\nПредставьте, что необходимо создать тип, который будет удалять крайние пробелы у литерального строкогого типа.\n\n`````ts\ntype TrimLeft<T extends string> =\n    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;\n\ntype Test = TrimLeft<\"  text\">; // type Test = \"text\"\n`````\n\nЭто очень простая задача, но реализуема только при условии ограниченной последовательности повторения пробелов. Простыми словами, если рекурсивная операция определение пробелов привысит установленный компилятором лимит, то возникнет ошибка.\n\n`````ts\ntype TrimLeft<T extends string> =\n    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;\n\n/**\n * До текущей версии [*] ошибка ->\n * Type instantiation is excessively deep and possibly infinite.ts(2589)\n */\ntype Test = TrimLeft<\"                                                text\">; // [*]\n`````\n\nСтоит заметить, что данный пример реализует так называемую _хвостовую рекурсию_, которая только возвращает результат и ничего с ним не делает. Поскольку в подобных случаях не требуется создание промежуточных результатов, нчиная с текущей версии, _TypeScript_ вводит оптимизацию позволяющую нашему примру быть работоспособным.\n\n`````ts\ntype TrimLeft<T extends string> =\n    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;\n\n/**\n * Начиная с текущей версии [*] Ok!\n */\ntype Test = TrimLeft<\"                                                text\">; // [*]\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Iskluchenie_hvostovoi_rekursii_na_uslovnyh_tipa","elementId":"Iskluchenie_hvostovoi_rekursii_na_uslovnyh_tipa","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_8","title":"Отключение исключения неиспользуемого импорта","tags":["Улучшение"],"markdown":"## Отключение исключения неиспользуемого импорта\n\nНе так давно, в _TypeScript_ был реализован механизм предназначеный для исключения импортов для неиспользуемых констркций, но затем выяснилось, что в некоторых случаях, это поведение является нежелатильным. К примеру, известный фраймворк `vuejs` выполняет импорт rjycnherwbq в теле тегов `<script></script>`, а использует их в шаблоне описывающем структуру компонентов.\n\n`````ts\n<script setup>\nimport { handler } from \"./handlers.ts\";\n</script>\n\n<button @click=\"handler\">Нажми меня!</button>\n`````\n\nПоскольку _TypeScript_ проверяет исключительно блок в котором расположен код, импорт функции-слушателя будет исключон из сборке, что неизбежно приведет в ошибке во время выполнения.\n\nВо избежания подобных ситуаций был введен новый флаг `--preserveValueImports`, который отключает удаление неиспользуемого импорта. Единственный важный момент заключается в том, что его необходимо использовать вместе с флагом `--isolatedModules`, которому задано значение `true`.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Otkluchenie_isklucheniya_neispolzuemogo_importa","elementId":"Otkluchenie_isklucheniya_neispolzuemogo_importa","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_12","title":"Совмещение import type с обычным import","tags":["Улучшение"],"markdown":"## Совмещение import type с обычным import\n\nДо недавнего времени импорт конструкций и импорт только типов, независимо от того, что они определены в одном файле, приходилось разбивать на несколько этапов.\n\n`````ts\n// constructions.ts\n\nexport class A {\n    a = ``;\n}\nexport class B {\n    b = 5;\n}\n\n\n// index.ts\n\nimport {A} from \"./components.ts\"; // импорт класса CustomComponet из файла components.ts\n// импорт только типа Componet из того же файла\nimport type {B} from \"./components.ts\";\n`````\n\nНачиная с текущей версии импорт конструкции и импорт только типов можно осуществлять в одной операции.\n\n\n`````ts\nimport {type A, B} from \"./constructions.ts\";\n`````\n\nК тому же, подобный импорт можно совмещать с импортом по умолчанию, но при условии, что будет импортированна конструкция, а не тип.\n\n\n`````ts\n// constructions.ts\n\nexport class A {\n    a = ``;\n}\nexport class B {\n    b = 5;\n}\nexport default class C {\n    c = true;\n}\n\n\n// index.ts\n\nimport C, {type A, B} from \"./constructions.ts\"; // Ok\n// import type C, {type A, B} from \"./constructions.ts\"; // Error\n\n`````\n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Sovmeshchenie_import_type_s_obychnym_import","elementId":"Sovmeshchenie_import_type_s_obychnym_import","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_13","title":"Проверка наличия ECMAScript приватного поля","tags":["Адаптация"],"markdown":"## Проверка наличия ECMAScript приватного поля\n\n_TYpeScript_ реализовал предложенный _ECMAScript_ механизм проверки наличия приватного поля. Теперь, в теле класса при помощи оператора `in` можно производить проверки на присутствие одноименных приватных полей в других экземплярах. Но стоит сделать акцент, что идентификаторы проверяемых полей должны быть идентичны идентификаторам приватных полей объявленых в самом классе.\n\n\n`````ts\nclass Person {\n    #name: string;\n    constructor(name: string) {\n        this.#name = name;\n    }\n\n    /**\n     * [*] Допустимы проверки только на одноименные\n     * приватные поля объявленные в текущем классе!\n     */\n    equals(other: unknown) {\n        return other &&\n            typeof other === \"object\" &&\n            #name in other && // [*]\n            this.#name === other.#name;\n    }\n}\n`````\n\nПоскольку с помощью оператора `instanceof` невозможно точно выявить принадлежность экземпляра из-за осуществления её на всем дереве иерархии...\n\n`````ts\nclass A {\n\n}\nclass B extends A {\n\n}\nclass C extends B {\n\n}\nconst c = new C();\n\n\nconsole.log(c instanceof A); // [*]\n\n/**\n * [*] Невозможно однозначно интерпретировать экземпляр\n * при помощи оператора instanceof поскольку проверка\n * осуществляется по всей иерархии наследования.\n */\n`````\n\n... а строковое представление класса не гарантирует место его объявления...\n\n\n`````ts\nconsole.log(c.constructor.name === `A`); // [*]\n\n/**\n * [*] это ./a/A.ts или ./b/A.ts?\n */\n`````\n\n... механизм определения класса по приватным полям обозначается, как _эргонамичная проверка бренда_, поскольку только приватные поля отличают экземпляры в одном иерархическом древе.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Proverka_nalichiya_ECMAScript_privatnogo_polya","elementId":"Proverka_nalichiya_ECMAScript_privatnogo_polya","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_1","title":"Утверждение импорта","tags":["Адаптация"],"markdown":"## Утверждение импорта\n\nПомимо прочего, _TypeScript_ реализует предложенный _ECMAScript_ механизм утверждения импорта.\n\n`````ts\nimport config from \"./config.json\" assert { type: \"json\" };\n`````\n\nСтоит уточнить, что _TypeScript_ просто компилирует утверждения втом виде, в котором его указал разработчик, перекладывая ответственность за проверки на срежду выполнения кода. Поэтому при использовании данного механизма нужно быть придельно внимательным.\n\n`````ts\n// Ok на этапе компиляции и Error во время выполенния \nimport config from \"./config.json\" assert { type: \"shmaip\" };\n`````\n\nТакже подобный механизм может быть применен и к динамическому импорту.\n\n`````ts\nawait import(\"./config.json\", {\n    assert: { type: \"json\" }\n});\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Utverjdenie_importa","elementId":"Utverjdenie_importa","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_3","title":"Ускорение загрузки с помощью realPathSync.native","tags":["Улучшение"],"markdown":"## Ускорение загрузки с помощью realPathSync.native\n\nРаньше, функция `realPathSync.native` применялась только на `Linux`, но того, как _nodejs_ реализовала её поддержку в остальных операционных системах, загрузка проектов стала осуществлятся на 5%-13% быстрее.","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Uskorenie_zagruzki_s_pomoshchu_realPathSync.native","elementId":"Uskorenie_zagruzki_s_pomoshchu_realPathSync.native","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_4","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения в lib.d.ts","tags":["Критическое изменение"],"markdown":"## [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения в lib.d.ts\n\nКак всегда значительной переработке подверглись декларации входящии в групперовку `lib.d.ts`.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_v_lib.d.ts","elementId":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_v_lib.d.ts","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_10","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения от вывода Awaited","tags":["Критическое изменение"],"markdown":"## [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения от вывода Awaited\n\nИз-за введения в основную кодовую базу нового типа `Awaited` могут возникнуть при определении типа значения получаемого в асинхронных операциях.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_ot_vyvoda_Awaited","elementId":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_ot_vyvoda_Awaited","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}},{"key":"4.5@beta_7","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Проверка корневых параметров комилятора в tsconfig.json","tags":["Критическое изменение"],"markdown":"## [КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Проверка корневых параметров комилятора в tsconfig.json\n\nВозникновение ошибки при объявлении пустого поля верхнего уровня в `tsconfig.json`.\n\n`````json\n// tsconfig.json\n\n{\n    \"include\": [] // Error -> пустой массив\n}\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_Proverka_kornevyh_parametrov_komilyatora_v_tsconfig.json","elementId":"[KRITIChESKOE_IZMENENIE]_Proverka_kornevyh_parametrov_komilyatora_v_tsconfig.json","version":{"version":"4.5@beta","dateRelease":"October 1, 2021","datePublication":"Oct 12, 2021"}}]},"contentNavData":{"key":"4.5@beta","level":0,"index":0,"contentIndex":0,"title":"4.5@beta","path":"4.5@beta","elementId":"4.5@beta","children":[{"key":"Поддержка ECMAScript модулей в NodeJs_0","level":1,"index":1,"contentIndex":1,"title":"Поддержка ECMAScript модулей в NodeJs","path":"Podderjka_ECMAScript_modulei_v_NodeJs","elementId":"Podderjka_ECMAScript_modulei_v_NodeJs"},{"key":"Поддержка lib из node_modules_1","level":1,"index":2,"contentIndex":2,"title":"Поддержка lib из node_modules","path":"Podderjka_lib_iz_node_modules","elementId":"Podderjka_lib_iz_node_modules"},{"key":"Тип Awaited_2","level":1,"index":3,"contentIndex":3,"title":"Тип Awaited","path":"Tip_Awaited","elementId":"Tip_Awaited"},{"key":"Указание шаблонного литерального строкового типа в качестве дискриминанта_3","level":1,"index":4,"contentIndex":4,"title":"Указание шаблонного литерального строкового типа в качестве дискриминанта","path":"Ukazanie_shablonnogo_literalnogo_strokovogo_tipa_v_kachestve_diskriminanta","elementId":"Ukazanie_shablonnogo_literalnogo_strokovogo_tipa_v_kachestve_diskriminanta"},{"key":"Стабильная поддержка --module es2022_4","level":1,"index":5,"contentIndex":5,"title":"Стабильная поддержка --module es2022","path":"Stabilnaya_podderjka_--module_es2022","elementId":"Stabilnaya_podderjka_--module_es2022"},{"key":"Исключение хвостовой рекурсии на условных типа_5","level":1,"index":6,"contentIndex":6,"title":"Исключение хвостовой рекурсии на условных типа","path":"Iskluchenie_hvostovoi_rekursii_na_uslovnyh_tipa","elementId":"Iskluchenie_hvostovoi_rekursii_na_uslovnyh_tipa"},{"key":"Отключение исключения неиспользуемого импорта_6","level":1,"index":7,"contentIndex":7,"title":"Отключение исключения неиспользуемого импорта","path":"Otkluchenie_isklucheniya_neispolzuemogo_importa","elementId":"Otkluchenie_isklucheniya_neispolzuemogo_importa"},{"key":"Совмещение import type с обычным import_7","level":1,"index":8,"contentIndex":8,"title":"Совмещение import type с обычным import","path":"Sovmeshchenie_import_type_s_obychnym_import","elementId":"Sovmeshchenie_import_type_s_obychnym_import"},{"key":"Проверка наличия ECMAScript приватного поля_8","level":1,"index":9,"contentIndex":9,"title":"Проверка наличия ECMAScript приватного поля","path":"Proverka_nalichiya_ECMAScript_privatnogo_polya","elementId":"Proverka_nalichiya_ECMAScript_privatnogo_polya"},{"key":"Утверждение импорта_9","level":1,"index":10,"contentIndex":10,"title":"Утверждение импорта","path":"Utverjdenie_importa","elementId":"Utverjdenie_importa"},{"key":"Ускорение загрузки с помощью realPathSync.native_10","level":1,"index":11,"contentIndex":11,"title":"Ускорение загрузки с помощью realPathSync.native","path":"Uskorenie_zagruzki_s_pomoshchu_realPathSync.native","elementId":"Uskorenie_zagruzki_s_pomoshchu_realPathSync.native"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения в lib.d.ts_11","level":1,"index":12,"contentIndex":12,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения в lib.d.ts","path":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_v_lib.d.ts","elementId":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_v_lib.d.ts"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения от вывода Awaited_12","level":1,"index":13,"contentIndex":13,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Изменения от вывода Awaited","path":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_ot_vyvoda_Awaited","elementId":"[KRITIChESKOE_IZMENENIE]_Izmeneniya_ot_vyvoda_Awaited"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Проверка корневых параметров комилятора в tsconfig.json_13","level":1,"index":14,"contentIndex":14,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] Проверка корневых параметров комилятора в tsconfig.json","path":"[KRITIChESKOE_IZMENENIE]_Proverka_kornevyh_parametrov_komilyatora_v_tsconfig.json","elementId":"[KRITIChESKOE_IZMENENIE]_Proverka_kornevyh_parametrov_komilyatora_v_tsconfig.json"}]},"pageNav":{"isPrevPage":true,"isNextPage":false,"prevPage":{"title":"4.4","path":"4.4"},"nextPage":{"title":"","path":""}}},"__N_SSG":true}