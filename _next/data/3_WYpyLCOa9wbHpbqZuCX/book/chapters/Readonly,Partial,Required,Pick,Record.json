{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/046.(Расширенные типы) Readonly, Partial, Required, Pick, Record/images/"},"sectionInfoAll":[{"key":"Readonly, Partial, Required, Pick, Record","elementId":"Readonly,Partial,Required,Pick,Record","markdown":"# Readonly, Partial, Required, Pick, Record\n\nЧтобы сделать повседневные будни разработчика немного легче, _TypeScript_, реализовал несколько предопределенных сопоставимых типов, как - `Readonly<T>`, `Partial<T>`, `Required<T>`, `Pick<T, K>` и `Record<K, T>`. За исключением `Record<K, T>`, все они являются так называемым _гомоморфными типами_ (homomorphic types). Простыми словами, _гомоморфизм_ — это возможность изменять функционал сохраняя первоначальные свойства всех операций. Если на данный момент это кажется сложным, то текущая глава покажет, что за данным термином не скрывается ничего сложного. Кроме того, в ней будет подробно рассмотрен каждый из перечисленных типов."},{"key":"Readonly, Partial, Required, Pick, Record_0","elementId":"Readonly<T>_(sdelat_chleny_obekta_tolko_dlya_chteniya)","markdown":"## Readonly<T> (сделать члены объекта только для чтения)\n\nСопоставимый тип `Readonly<T>` добавляет каждому члену объекта модификатор `readonly`, делая их тем самым только для чтения.\n\n`````ts\n// lib.es6.d.ts\n\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n`````\n\nНаиболее частое применение данного типа можно встретить при определении функций и методов параметры которых принадлежать к объектным типам. Поскольку объектные типы передаются по ссылке, то с высокой долей вероятности, случайное изменение члена объекта может привести к непредсказуемым последствиям.\n\n`````ts\ninterface IPerson {\n  name: string;\n  age: number;\n}\n\n/**\n * Функция, параметр которой не\n * защищен от случайного изменения.\n * \n * Поскольку объектные типы передаются\n * по ссылке, то с высокой долей вероятности,\n * случайное изменение поля name нарушит ожидаемый\n * ход выполнения программы.\n */\nfunction mutableAction(person: IPerson) {\n  person.name = \"NewName\"; // Ok\n}\n\n\n/**\n * Надежная функция защищающая свои\n * параметры от изменения не требуя описания\n * нового неизменяемого типа.\n */\nfunction immutableAction(person: Readonly<IPerson>) {\n  person.name = \"NewName\"; // Error -> Cannot assign to 'name' because it is a read-only property.\n}\n`````\n\nТип сопоставления `Readonly<T>` является гомоморфным и добавляя свой модификатор `readonly` не влияет на уже существующие модификаторы. Сохранения исходным типом своих первоначальных характеристик (в данном случае — модификаторы), делает сопоставленный тип `Readonly<T>` гомоморфным.\n\n`````ts\ninterface IPerson {\n  gender?: string;\n}\n\ntype Person = Readonly<IPerson> // type Person = { readonly gender?: string; }\n`````\n\nВ качестве примера можно привести часто встречающейся на практике случай, в котором универсальный интерфейс описывает объект предназначенный для работы с данными. Поскольку в львиной доле данные представляются объектными типами, интерфейс декларирует их как неизменяемые, что в дальнейшем, при его реализации, избавит разработчика в типизации конструкций и тем самым сэкономив для него время на более увлекательные задачи.\n\n`````ts\n/**\n * Интерфейс необходим для описания экземпляра\n * провайдеров с которыми будет сопряженно\n * приложение. Кроме того, интерфейс описывает\n * поставляемые данные как только для чтения,\n *, что в будущем может сэкономить время.\n */\ninterface IDataProvider<OutputData, InputData = null> {\n  getData(): Readonly<OutputData>;\n}\n\n/**\n * Абстрактный класс описание определяющий\n * поле data доступный только потомка как\n * только для чтения. Это позволит предотвратить\n * случайное изменение данных в классах потомках.\n */\nabstract class DataProvider<InputData, OutputData = null> implements IDataProvider<InputData, OutputData> {\n  constructor(protected data?: Readonly<OutputData>) {\n  }\n\n  abstract getData(): Readonly<InputData>\n}\n\n\n\ninterface IPerson {\n  firstName: string;\n  lastName: string;\n}\n\ninterface IPersonDataProvider {\n  name: string;\n}\n\nclass PersonDataProvider extends DataProvider<IPerson, IPersonDataProvider> {\n    getData() {\n      /**\n       * Работая в теле потомков DataProvider\n       * будет не так просто случайно изменить\n       * данные доступные через ссылку this.data\n       */\n      let [firstName, lastName] = this.data.name.split(` `);\n      let result = { firstName, lastName };\n\n      return result;\n    }\n\n}\n\n\nlet provider = new PersonDataProvider({ name: `Ivan Ivanov` });\n`````"},{"key":"Readonly, Partial, Required, Pick, Record_1","elementId":"Partial<T>_(sdelat_vse_chleny_obekta_neobyazatelnymi)","markdown":"## Partial<T> (сделать все члены объекта необязательными)\n\nСопоставимый тип `Partial<T>` добавляет членам объекта модификатор `?:` делая их таким образом необязательными.\n\n`````ts\n// lib.es6.d.ts\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n`````\n\nТип сопоставления `Partial<T>` является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа.\n\n`````ts\ninterface IPerson {\n  readonly name: string; // поле помечено, как только для чтения\n}\n\n/**\n * добавлен необязательны модификатор\n * и при этом сохранен модификатор readonly\n * \n * type Person = {\n *  readonly name?: string;\n * }\n */\ntype Person = Partial<IPerson>\n`````\n\nПредставьте приложение зависящее от конфигурации, которая как полностью, так и частично, может быть переопределена пользователем. Поскольку работоспособность приложения завязана на конфигурации, члены определенные в типе представляющем её, должны быть обязательными. Но поскольку пользователь может переопределить лишь часть конфигурации, функция выполняющая её слияние с конфигурацией по умолчанию, не может указать в аннотации типа уже определенный тип, так как его члены обязательны. Описывать новый тип, слишком утомительно. В таких случаях необходимо прибегать к помощи `Partial<T>`.\n\n`````ts\ninterface IConfig {\n  domain: string;\n  port: \"80\" | \"90\";\n}\n\nconst DEFAULT_CONFIG: IConfig = {\n  domain: `https://domain.com`,\n  port: \"80\"\n};\n\n\nfunction createConfig(config: IConfig): IConfig {\n  return Object.assign({}, DEFAULT_CONFIG, config);\n}\n\n/**\n * Error -> Поскольку в типе IConfig все\n * поля обязательные, данную функцию\n * не получится вызвать с частичной конфигурацией.\n */\ncreateConfig({\n  port: \"80\"\n});\n\n\nfunction createConfig(config:Partial<IConfig>): IConfig {\n  return Object.assign({}, DEFAULT_CONFIG, config);\n}\n\n/**\n * Ok -> Тип Partial<T> сделал все члены\n * описанные в IConfig необязательными,\n * поэтому пользователь может переопределит\n * конфигурацию частично.\n */\ncreateConfig({\n  port: \"80\"\n});\n`````"},{"key":"Readonly, Partial, Required, Pick, Record_2","elementId":"Required<T>_(sdelat_vse_neobyazatelnye_chleny_obyazatelnymi)","markdown":"## Required<T> (сделать все необязательные члены обязательными)\n\nСопоставимый тип `Required<T>` удаляет все необязательные модификаторы `?:` приводя члены объекта к обязательным. Достигается это путем удаления необязательных модификаторов при помощи механизма _префиксов - и +_ рассматриваемого в главе [“Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -”](../042.%28Работа%20с%20типами%29%20Оператор%20keyof%2C%20Lookup%20Types%2C%20Mapped%20Types%2C%20Mapped%20Types%20-%20префиксы%20%2B%20и%20-/content.md).\n\n`````ts\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n`````\n\nТип сопоставления `Required<T>` является полной противоположностью типу сопоставления `Partial<T>`.\n\n`````ts\ninterface IConfig {\n  domain: string;\n  port: \"80\" | \"90\";\n}\n\n/**\n * Partial добавил членам IConfig\n * необязательный модификатор ->\n *\n * type T0 = {\n *  domain?: string;\n *  port?: \"80\" | \"90\";\n * }\n */\ntype T0 = Partial<IConfig>;\n\n/**\n * Required удалил необязательные модификаторы\n * у типа T0 ->\n *\n * type T1 = {\n *  domain: string;\n *  port: \"80\" | \"90\";\n * }\n */\ntype T1 = Required<T0>;\n`````\n\nТип сопоставления `Required<T>` является гомоморфным и не влияет на модификаторы отличные от необязательных.\n\n`````ts\ninterface IT {\n  readonly a?: number;\n  readonly b?: string;\n}\n\n/**\n * Модификаторы readonly остались\n * на месте ->\n *\n * type T0 = {\n *  readonly a: number;\n *  readonly b: string;\n * }\n */\ntype T0 = Required<IT>;\n`````"},{"key":"Readonly, Partial, Required, Pick, Record_3","elementId":"Pick_(otfiltrovat_obektnyi_tip)","markdown":"## Pick (отфильтровать объектный тип)\n\nСопоставимый тип `Pick<T, K>` предназначен для фильтрации объектного типа ожидаемого в качестве первого параметра типа. Фильтрация происходит на основе ключей представленных множеством литеральных строковых типов ожидаемых в качестве второго параметра типа. \n\n`````ts\n// lib.es6.d.ts\n\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n`````\n\nПростыми словами, результатом преобразования `Pick<T, K>` будет являться тип состоящий из членов первого параметра идентификаторы которых указанны во втором параметре.\n\n`````ts\ninterface IT {\n  a: number;\n  b: string;\n  c: boolean;\n}\n\n/**\n * Поле \"с\" отфильтровано ->\n * \n * type T0 = { a: number; b: string; }\n */\ntype T0 = Pick<IT, \"a\" | \"b\">;\n`````\n\nСтоит заметить, что в случае указания несуществующих ключей возникнет ошибка.\n\n`````ts\ninterface IT {\n  a: number;\n  b: string;\n  c: boolean;\n}\n\n/**\n * Error ->\n *\n * Type '\"a\" | \"U\"' does not satisfy the constraint '\"a\" | \"b\" | \"c\"'.\n * Type '\"U\"' is not assignable to type '\"a\" | \"b\" | \"c\"'.\n */\ntype T1 = Pick<IT, \"a\" | \"U\">;\n`````\n\nТип сопоставления `Pick<T, K>` является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа.\n\n`````ts\ninterface IT {\n  readonly a?: number;\n  readonly b?: string;\n  readonly c?: boolean;\n}\n\n/**\n * Модификаторы readonly и ? сохранены ->\n *\n * type T2 = { readonly a?: number; }\n */\ntype T2 = Pick<IT, \"a\">;\n`````\n\nПример, который самым первым приходит в голову, является функция `pick`, в задачу которой входит создавать новый объект путем фильтрации членов существующего.\n\n`````ts\nfunction pick<T, K extends string & keyof T>(object: T, ...keys: K[]) {\n    return Object\n        .entries(object) // преобразуем объект в массив [идентификатор, значение]\n        .filter(([key]: Array<K>) => keys.includes(key)) // фильтруем\n        .reduce((result, [key, value]) => ({...result, [key]: value}), {} as Pick<T, K>); // собираем объект из прошедших фильтрацию членов\n}\n\n\nlet person = pick({\n    a: 0,\n    b: ``,\n    c: true\n}, `a`, `b`);\n\nperson.a; // Ok\nperson.b; // Ok\nperson.c; // Error -> Property 'c' does not exist on type 'Pick<{ a: number; b: string; c: boolean; }, \"a\" | \"b\">'.\n\n`````"},{"key":"Readonly, Partial, Required, Pick, Record_4","elementId":"Record<K,T>_(dinamicheski_opredelit_pole_v_obektnom_tipe)","markdown":"## Record<K, T> (динамически определить поле в объектном типе)\n\nСопоставимый тип `Record<K, T>` предназначен для динамического определения полей в объектном типе. Данный тип определяет два параметра типа. В качестве первого параметра ожидается множество ключей представленных множеством `string` или `Literal String` - `Record<\"a\", T>` или `Record<\"a\" | \"b\", T>`. В качестве второго параметра ожидается конкретный тип данных, который будет ассоциирован с каждым ключом.\n\n`````ts\n// lib.es6.d.ts\n\ntype Record<K extends string, T> = {\n    [P in K]: T;\n};\n`````\n\nСамый простой пример, который первым приходит в голову, это замена индексных сигнатур.\n\n`````ts\n/**\n * Поле payload определенно как объект\n * с индексной сигнатурой, что позволит\n * динамически записывать в него поля.\n */\ninterface IConfigurationIndexSignature {\n  payload: {\n    [key: string]: string\n  }\n}\n\n/**\n * Поле payload определенно как\n * Record<string, string>, что аналогично\n * предыдущему варианту, но выглядит более\n * декларативно.\n */\ninterface IConfigurationWithRecord {\n  payload: Record<string, string>\n}\n\n\nlet configA: IConfigurationIndexSignature = {\n  payload: {\n    a: `a`,\n    b: `b`\n  }\n}; // Ok\nlet configB: IConfigurationWithRecord = {\n  payload: {\n    a: `a`,\n    b: `b`\n  }\n}; // Ok\n`````\n\nНо в отличии от индексной сигнатуры типа `Record<K, T>` может ограничить диапазон ключей.\n\n`````ts\ntype WwwConfig = Record<\"port\" | \"domain\", string>\n\nlet wwwConfig: WwwConfig = {\n  port: \"80\",\n  domain: \"https://domain.com\",\n\n  user: \"User\" // Error -> Object literal may only specify known properties, and 'user' does not exist in type 'Record<\"port\" | \"domain\", string>'.\n};\n`````\n\nВ данном случае было бы даже более корректным использовать `Record<K, T>` в совокупности с ранее рассмотренным типом `Partial<T>`.\n\n`````ts\ntype WwwConfig = Partial<Record<\"port\" | \"domain\", string>>\n\nlet wwwConfig: WwwConfig = {\n  port: \"80\",\n               // Ok -> поле domain теперь не обязательное\n  user: \"User\" // Error -> Object literal may only specify known properties, and 'user' does not exist in type 'Record<\"port\" | \"domain\", string>'.\n};\n`````\n\nТакже не будет лишним упомянуть, что поведение данного типа при определении в объекте с предопределенными членами, идентификаторы которых ассоциированы с типами отличными от типа указанного в качестве второго параметра, идентично поведению индексной сигнатуры. Напомню, что при попытке определить в объекте члены идентификаторы которых будут ассоциированы с типами отличными от указанных в индексной сигнатуре, возникнет ошибка.\n\n`````ts\n/**\n * Ok -> поле a ассоциировано с таким\n * же типом, что указан в индексной сигнатуре.\n */\ninterface T0 {\n  a: number;\n  \n  [key: string]: number;\n}\n\n/**\n * Error -> тип поля a не совпадает с типом\n * указанным в индексной сигнатуре.\n */\ninterface T1 {\n  a: string; // Error -> Property 'a' of type 'string' is not assignable to string index type 'number'.\n\n  [key: string]: number;\n}\n`````\n\nДанный пример можно переписать с использованием типа пересечения.\n\n`````ts\ninterface IValue {\n  a: number;\n}\n\ninterface IDynamic {\n  [key: string]: string;\n}\n\n\ntype T = IDynamic & IValue;\n\n/**\n * Error -> \n * Type '{ a: number; }' is not assignable to type 'IDynamic'. \n * Property 'a' is incompatible with index signature.\n * Type 'number' is not assignable to type 'string'.\n */\nlet t: T = {\n  a: 0,\n}\n`````\n\nАналогичное поведение будет и для пересечения определяемого типом `Record<K, T>`.\n\n`````ts\ninterface IValue {\n  a: number;\n}\n\n\ntype T = Record<string, string> & IValue;\n\n/**\n * Error -> \n * Type '{ a: number; }' is not assignable to type 'Record<string, string>'.\n * Property 'a' is incompatible with index signature.\n * Type 'number' is not assignable to type 'string'.\n */\nlet t: T = {\n  a: 0,\n}\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Условные типы (Conditional Types)","path":"Uslovnye_tipy_(Conditional_Types)"},"nextPage":{"title":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited","path":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit,Awaited"}},"contentNavData":{"key":"Readonly, Partial, Required, Pick, Record","level":0,"index":46,"contentIndex":0,"section":"Расширенные типы","title":"Readonly, Partial, Required, Pick, Record","path":"Readonly,Partial,Required,Pick,Record","elementId":"Readonly,Partial,Required,Pick,Record","children":[{"key":"Readonly, Partial, Required, Pick, Record_0","index":0,"contentIndex":1,"level":1,"section":"Расширенные типы","title":"Readonly<T> (сделать члены объекта только для чтения)","path":"Readonly<T>_(sdelat_chleny_obekta_tolko_dlya_chteniya)","elementId":"Readonly<T>_(sdelat_chleny_obekta_tolko_dlya_chteniya)"},{"key":"Readonly, Partial, Required, Pick, Record_1","index":1,"contentIndex":2,"level":1,"section":"Расширенные типы","title":"Partial<T> (сделать все члены объекта необязательными)","path":"Partial<T>_(sdelat_vse_chleny_obekta_neobyazatelnymi)","elementId":"Partial<T>_(sdelat_vse_chleny_obekta_neobyazatelnymi)"},{"key":"Readonly, Partial, Required, Pick, Record_2","index":2,"contentIndex":3,"level":1,"section":"Расширенные типы","title":"Required<T> (сделать все необязательные члены обязательными)","path":"Required<T>_(sdelat_vse_neobyazatelnye_chleny_obyazatelnymi)","elementId":"Required<T>_(sdelat_vse_neobyazatelnye_chleny_obyazatelnymi)"},{"key":"Readonly, Partial, Required, Pick, Record_3","index":3,"contentIndex":4,"level":1,"section":"Расширенные типы","title":"Pick (отфильтровать объектный тип)","path":"Pick_(otfiltrovat_obektnyi_tip)","elementId":"Pick_(otfiltrovat_obektnyi_tip)"},{"key":"Readonly, Partial, Required, Pick, Record_4","index":4,"contentIndex":5,"level":1,"section":"Расширенные типы","title":"Record<K, T> (динамически определить поле в объектном типе)","path":"Record<K,T>_(dinamicheski_opredelit_pole_v_obektnom_tipe)","elementId":"Record<K,T>_(dinamicheski_opredelit_pole_v_obektnom_tipe)"}]},"pageDescription":"Readonly, Partial, Required, Pick, Record"},"__N_SSG":true}