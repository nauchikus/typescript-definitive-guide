{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/034.(Типы) Обобщения (Generics)/images/"},"sectionInfoAll":[{"key":"Обобщения (Generics)","elementId":"Obobshcheniya_(Generics)","markdown":"# Обобщения (Generics)\n\nИз всего, что стало и ещё станет известным о типизированном мире, тем, кто только начинает свое знакомство с ним, тема, посвященная обобщениям (_generics_), может казаться наиболее сложной. Хотя данная тема, как и все остальные, обладает некоторыми нюансами, каждый из которых будет детально разобран, в реальности, рассматриваемые в ней механизмы очень просты и схватываются на лету. Поэтому приготовьтесь, к концу главы место занимаемое множеством вопросов, касающихся обобщений, займет желание сделать все пользовательские конструкции универсальными."},{"key":"Обобщения (Generics)_0","elementId":"Obobshcheniya_-_obshchie_ponyatiya","markdown":"## Обобщения - общие понятия\n\nПредставьте огромный, дорогущий и высокотехнологичный типографский печатный станок, выполненный в виде монолита, что в свою очередь делает его пригодным для печати только одного номера газеты. То есть для печати сегодняшних новостей необходим один печатный станок, для завтрашних, другой и т.д. Подобный станок сравним с _обычным типом_ признаки которого после объявления остаются неизменны при его реализации. Другими словами, если при существовании типа `A`, описание которого включает поле, принадлежащее к типу `number`, потребуется тип, отличие которого будет состоять лишь в принадлежности поля к другому типу, возникнет необходимость в его объявлении.\n\n`````ts\n// простые типы сравнимы с монолитами\n\n// этот станок предназначен для печати газет под номером A\ninterface A {\n    field: number;\n}\n\n// этот станок предназначен для печати газет под номером B\ninterface B {\n    field: string;\n}\n\n// и т.д.\n`````\n\nК счастью, в нашей реальности нашли решение не только относительно печатных станков, но и типов. Нежелания тратить усилия на постоянное описывание монолитных типов послужило причиной зарождения парадигмы _обобщенного программирования_.\n\n_Обобщенное программирование_ (_Generic Programming_) — это подход, при котором алгоритмы могут одинаково работать с данными, принадлежащими к разным типам данных без изменения декларации (описания типа).\n\nВ основе обобщенного программирования лежит такое ключевое понятие как _обобщение_. _Обобщение_ (_Generics_) — это _параметризированный тип_ позволяющий объявлять _параметры типа_, являющиеся временной заменой _конкретных типов_, _конкретизация_ которых будет выполнена в момент создания экземпляра. Параметры типа, при условии соблюдения некоторых правил, можно использовать в большинстве операций, допускающих работу с обычными типами. Все это вместе дает повод сравнивать обобщенный тип с _правильной версией_ печатного станка, чьи заменяемые валы, предназначенные для отпечатывания информации на проходящей через них бумаге, сопоставимы с _параметрами типа_.\n\nВ реальности обобщения позволяют сокращать количество преобразований (приведений) и писать многократно используемый код, при этом повышая его типобезопасность.\n\nЭтих примеров должно быть достаточно для образования отчетливого образа обобщений. Но прежде чем продолжить, стоит уточнить значения таких далеко не всем очевидных терминов, как: _обобщенный тип_, _параметризированный тип_ и _универсальная конструкция_.\n\nДля понимания этих терминов необходимо представить чертеж бумажного домика, в который планируется поселить пойманного на пикнике жука. Когда гипотетический жук мысленно располагается вне границ начерченного жилища, сопоставимого с типом, то оно предстает в виде _обобщенного типа_. Когда жук представляется внутри своей будущей обители, то о ней говорят как о _параметризированном типе_. Если же чертеж материализовался, хотя и в форму представленную обычной коробкой из-под печенья, то её называют _универсальной конструкцией_.\n\nДругими словами, тип, определяющий параметр, обозначается как обобщенный тип. При обсуждении типов, представляемых параметрами типа, необходимо понимать, что они определены в параметризированном типе. Когда объявление обобщенного типа получило реализацию, то такую конструкцию, будь, то класс или функция, называют универсальной (универсальный класс, универсальная функция или метод)."},{"key":"Обобщения (Generics)_1","elementId":"Obobshcheniya_v_TypeScript","markdown":"## Обобщения в TypeScript\n\nВ _TypeScript_ обобщения могут быть указаны для типов, определяемых с помощью:\n\n- _псевдонимов_ (`type`)\n- _интерфейсов_, объявленных с помощью ключевого слова `interface`\n- _классов_ (`class`), в том числе _классовых выражений_ (_class expression_)\n- _функций_ (`function`) определенных в виде как деклараций (_Function Declaration_), так и выражений (_Function Expression_)\n- _методов_ (_method_)\n\n\nОбобщения объявляются при помощи пары угловых скобок, в которые через запятую, заключены _параметры типа_, называемые также _типо-заполнителями_ или _универсальными параметрами_ `Type<T0, T1>`.\n\n`````ts\n      /** [0]  [1] [2] */\ninterface Type<T0, T1> {}\n\n/**\n * [0] объявление обобщенного типа Type,\n * определяющего два параметра типа [1][2]\n */\n`````\n\nПараметры типа могут быть указаны в качестве типа везде, где требуется аннотация типа, за исключением членов класса (static members). Область видимости параметров типа ограничена областью обобщенного типа. Все вхождения параметров типа будут заменены на конкретные типы переданные в качестве аргументов типа. Аргументы типа указываются в угловых скобках, в которых через запятую указываются конкретные типы данных `Type<number, string>`.\n\n`````ts\n        /** [0]  [1]      [2] */\nlet value: Type<number, string>\n\n/**\n * [0] указание обобщенного типа,\n * которому в качестве аргументов\n * указываются конкретные типы\n * number [1] и string [2]\n */\n`````\n\nИдентификаторы параметров типа должны начинаться с заглавной буквы и кроме фантазии разработчика они также ограничены общими для _TypeScript_ правилами. Если логическую принадлежность параметра типа возможно установить без какого-либо труда, как например в случае `Array<T>`, кричащего, что параметр типа `T` представляет тип, к которым могут принадлежать элементы этого массива, то идентификаторы параметров типа принято выбирать из последовательности `T`, `S`, `U`, `V` и т.д. Также частая последовательность `T`, `U`, `V`, `S` и т.д.\n\nС помощью `K` и `V` принято обозначать типы соответствующие `Key`/`Value`, а при помощи `P` — `Property`. Идентификатором `Z` принято обозначать полиморфный тип `this`.\n\nКроме того, не исключены случаи, в которых предпочтительнее выглядят полные имена, как, например, `RequestService`, `ResponseService`, к которым ещё можно применить _Венгерскую нотацию_ - `TRequestService`, `TResponseService`.\n\nК примеру, увидев в автодополнении редактора тип `Array<T>`, в голову тут же приходит верный вариант, что массив будет содержать элементы принадлежащие к указанному типу `T`. Но, увидев `Animal<T, S>`, можно никогда не догадаться, что эти типы данных будут указаны в аннотации типа полей `id` и `arial`. В этом случае было бы гораздо предпочтительней дать говорящие имена `Animal<AnimalID, AnimalArial>` или даже `Animal<TAnimalID, TAnimalArial>`, что позволит внутри тела параметризированного типа `Animal` отличать его параметры типа от конкретных объявлений.\n\nУказывается обобщение сразу после идентификатора типа. Это правило остается неизменным даже в тех случаях, когда идентификатор отсутствует (как в случае с безымянным классовым или функциональным выражением), или же и вовсе не предусмотрен (стрелочная функция).\n\n`````ts\ntype Identifier<T> = {};\n\ninterface Identifier<T> {}\n\nclass Identifier<T> {\n    public identifier<T>(): void {}\n}\n\nlet identifier = class <T> {};\n\nfunction identifier<T>(): void {}\n\nlet identifier = function <T>(): void {};\n\nlet identifier = <T>() => {};\n`````\n\nНо прежде чем приступить к детальному рассмотрению, нужно уточнить, что правила для функций, функциональных выражений и методов идентичны. Правила для классов ничем не отличаются от правил для классовых выражений. Исходя из этого, все дальнейшие примеры будут приводиться исключительно на классах и функциях.\n\nВ случае, когда обобщение указанно псевдониму типа (`type`), область видимости параметров типа ограничена самим выражением. \n\n`````ts\ntype T1<T> = { f1: T };\n`````\n\nОбласть видимости параметров типа при объявлении функции и функционального выражения, включая стрелочное, а также методов, ограничивается их сигнатурой и телом. Другими словами, параметр типа можно использовать в качестве типа при объявлении параметров, возвращаемого значения, а также в допустимых выражениях (аннотация типа, приведение типа и т.д.) расположенных в теле.\n\n`````ts\nfunction f1<T>(p1: T): T {\n    let v1: T;\n    \n    return v1;\n}\n`````\n\nПри объявлении классов (в том числе классовых выражений) и интерфейсов, область видимости параметров типа ограничиваются областью объявления и телом.\n\n`````ts\ninterface IT1<T> {\n    f1: T;\n}\n\nclass T1<T> {\n    public f1: T;\n}\n`````\n\nВ случаях, когда класс/интерфейс расширяет другой класс/интерфейс, который объявлен как обобщенный, потомок обязан указать типы для своего предка. Потомок в качестве аргумента типа может указать своему предку не только конкретный тип, но и тип, представляемый собственными параметрами типа.\n\n`````ts\ninterface IT1<T> {}\n\ninterface IT3<T> extends IT1<T> {}\ninterface IT2 extends IT1<string> {}\n\nclass T1<T> {}\n\nclass T2<T> extends T1<T> implements IT1<T> {}\nclass T3 extends T1<string> implements IT1<string> {}\n`````\n\nЕсли класс/интерфейс объявлен как обобщенный, а внутри него объявлен обобщенный метод, имеющий идентичный параметр типа, то последний в своей области видимости будет перекрывать первый (более конкретно это поведение будет рассмотрено позднее).\n\n`````ts\ninterface IT1<T> {\n    m2<T>(p1: T): T;\n}\n\nclass T1<T> {\n    public m1<T>(p1: T): T {\n        let v1: T;\n        \n        return p1;\n    }\n}\n`````\n\nПринадлежность параметра типа к конкретному типу данных устанавливается в момент передачи аргументов типа. При этом конкретные типы данных указываются в паре угловых скобок, а количество конкретных типов должно соответствовать количеству обязательных параметров типа.\n\n`````ts\nclass Animal<T> {\n    constructor(readonly id: T) {}\n}\n\nvar bird: Animal<string> = new Animal('bird'); // Ok\nvar bird: Animal<string> = new Animal(1); // Error\nvar fish: Animal<number> = new Animal(1); // Ok\n`````\n\nЕсли обобщенный тип указывается в качестве типа данных, то он обязан содержать аннотацию обобщения (исключением является параметры типа по умолчанию, которые рассматриваются далее в главе).\n\n`````ts\nclass Animal<T> {\n    constructor(readonly id: T) {}\n}\n\nvar bird: Animal = new Animal<string>('bird'); // Error\nvar bird: Animal<string> = new Animal<string>('bird'); // Ok\n`````\n\nКогда все обязательные параметры типа используются в параметрах конструктора, при создании экземпляра класса, аннотацию обобщения можно опускать. В таком случае вывод типов определит принадлежность к типам по устанавливаемым значениям. Если параметры являются необязательными и значение не будет передано, то вывод типов определит принадлежность параметров типа к типу данных `unknown`.\n\n`````ts\nclass Animal<T> {\n    constructor(readonly id?: T) {}\n}\n  \nlet bird: Animal<string> = new Animal('bird'); // Ok -> bird: Animal<string>\nlet fish = new Animal('fish'); // Ok -> fish: Animal<string>\nlet insect = new Animal(); // Ok -> insect: Animal<unknown>\n`````\n\nОтносительно обобщенных типов существуют такие понятия, как _открытый_ (open) и _закрытый_ (closed) тип. Обобщенный тип в момент определения называется _открытым_.\n`````ts\nclass T0<T, U> {} //  T0 - открытый тип\n`````\n \nКроме того, обобщенные типы, указанные в аннотации у которых хотя бы один из аргументов типа является параметром типа, также являются открытыми типами.\n\n`````ts\nclass T1<T> {\n  public f: T0<number, T>; // T0 - открытый тип\n}\n`````\n\nИ наоборот, если все аргументы типа принадлежат к конкретным типам, то такой обобщенный тип является _закрытым_ типом.\n\n`````ts\nclass T1<T> {\n  public f1: T0<number, string>; // T0 - закрытый тип\n}\n`````\n\nТе же самые правила применимы и к функциям, но за одним исключением — вывод типов для примитивных типов определяет принадлежность параметров типа к литеральным типам данных.\n\n`````ts\nfunction action<T>(value?: T): T | undefined {\n    return value;\n}\n  \naction<number>(0); // function action<number>(value?: number | undefined): number | undefined\naction(0); // function action<0>(value?: 0 | undefined): 0 | undefined\n\naction<string>('0'); // function action<string>(value?: string | undefined): string | undefined\naction('0'); // function action<\"0\">(value?: \"0\" | undefined): \"0\" | undefined\n\naction(); // function action<unknown>(value?: unknown): unknown\n`````\n\nЕсли параметры типа не участвуют в операциях при создании экземпляра класса и при этом аннотация обобщения не была указана явно, вывод типа теряет возможность установить принадлежность к типу по значению и поэтому устанавливает его принадлежность к типу `unknown`.\n\n`````ts\nclass Animal<T> {\n    public name: T;\n    \n    constructor(readonly id: string) {}\n}\n   \nlet bird: Animal<string> = new Animal('bird#1');\nbird.name = 'bird';\n// Ok -> bird: Animal<string>\n// Ok -> (property) Animal<string>.name: string\n\nlet fish = new Animal<string>('fish#1');\nfish.name = 'fish';\n// Ok -> fish: Animal<string>\n// Ok -> (property) Animal<string>.name: string\n\nlet insect = new Animal('insect#1');\ninsect.name = 'insect';\n// Ok -> insect: Animal<unknown>\n// Ok -> (property) Animal<unknown>.name: unknown\n`````\n\nИ опять, эти же правила верны и для функций.\n\n`````ts\nfunction action<T>(value?: T): T | undefined {\n    return value;\n}\n\naction<string>('0'); // function action<string>(value?: string | undefined): string | undefined\naction('0'); // function action<\"0\">(value?: \"0\" | undefined): \"0\" | undefined\naction(); // function action<unknown>(value?: unknown): unknown\n`````\n\nВ случаях, когда обобщенный класс содержит обобщенный метод, параметры типа метода будут затенять параметры типа класса.\n\n`````ts\ntype ReturnParam<T, U> = { a: T, b: U };\n\nclass GenericClass<T, U> {\n    public defaultMethod<T> (a: T, b?: U): ReturnParam<T, U> {\n        return { a, b };\n    }\n    \n    public genericMethod<T> (a: T, b?: U): ReturnParam<T, U> {\n        return { a, b };\n    }\n}\n\nlet generic: GenericClass<string, number> = new GenericClass();\ngeneric.defaultMethod('0', 0);\ngeneric.genericMethod<boolean>(true, 0);\ngeneric.genericMethod('0');\n\n// Ok -> generic: GenericClass<string, number>\n// Ok -> (method) defaultMethod<string>(a: string, b?: number): ReturnParam<string, number>\n// Ok -> (method) genericMethod<boolean>(a: boolean, b?: number): ReturnParam<boolean, number>\n// Ok -> (method) genericMethod<string>(a: string, b?: number): ReturnParam<string, number>\n`````\n\nСтоит заметить, что в _TypeScript_  нельзя создавать экземпляры типов представляемых параметрами типа.\n\n`````ts\ninterface CustomConstructor<T> {\n    new(): T;\n}\n\nclass T1<T extends CustomConstructor<T>>{\n    public getInstance(): T {\n        return new T(); // Error\n    }\n}\n`````\n\nКроме того, два типа, определяемые классом или функцией, считаются идентичными вне зависимости от того, являются они обобщенными или нет.\n\n`````ts\ntype T1 = {}\ntype T1<T> = {} // Error -> Duplicate identifier\n\nclass T2<T> {}\nclass T2 {} // Error -> Duplicate identifier\n\nclass T3 {\n    public m1<T>(): void {}\n    public m1(): void {} // Error -> Duplicate method\n}\n\nfunction f1<T>(): void {}\nfunction f1(): void {} // Error -> Duplicate function\n`````"},{"key":"Обобщения (Generics)_2","elementId":"Parametry_tipa_-_extends_(generic_constraints)","markdown":"## Параметры типа - extends (generic constraints)\n\nПомимо того, что параметры типа можно указывать в качестве конкретного типа, они также могут расширять другие типы, в том числе и другие параметры типа. Такой механизм требуется, когда значения внутри обобщенного типа должны обладать ограниченным набором признаков. Ключевое слово `extends` размещается левее расширяемого типа и правее идентификатора параметра типа `<T extends Type>`. В качестве расширяемого типа может быть указан как конкретный тип данных, так и другой параметр типа. При чем, если один параметр типа расширяет другой, нет разницы в каком порядке они объявляются. Если параметр типа ограничен другим параметром типа, то такое ограничение называют _неприкрытым ограничением типа_ (_naked type constraint_),\n\n`````ts\nclass T1 <T extends number> {}\nclass T2 <T extends number, U extends T> {} // неприкрытое ограничение типа\nclass T3 <U extends T, T extends number> {}\n`````\n\nМеханизм расширения требуется в тех случаях, в которых параметр типа должен обладать заданными характеристиками, необходимыми для выполнения конкретных операций над этим типом.\n\nДля примера рассмотрим случай, когда в коллекции `T` (`Collection<T>`) объявлен метод получения элемента по имени (`getItemByName`).\n\n`````ts\nclass Collection<T> {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item => item.name === name); // Error -> Property 'name' does not exist on type 'T'\n    }\n}\n`````\n\nПри операции поиска в массиве возникнет ошибка. Это происходит по причине того, что в типе `T` не описано свойство `name`. Для того, что бы ошибка исчезла, тип `T` должен расширить тип, в котором описано необходимое свойство `name`. В таком случае предпочтительней будет вариант объявления интерфейса `IName` с последующим его расширением.\n\n`````ts\ninterface IName {\n    name: string;\n}\n\nclass Collection<T extends IName> {\n    private itemAll: T[] = [];\n\n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item => item.name === name); // Ok\n    }\n}\n\nabstract class Animal {\n    constructor(readonly name: string) {}\n}\n\nclass Bird extends Animal {}\nclass Fish extends Animal {}\n\nlet birdCollection: Collection<Bird> = new Collection();\nbirdCollection.add(new Bird('raven'));\nbirdCollection.add(new Bird('owl'));\n\nlet raven: Bird = birdCollection.getItemByName('raven'); // Ok\n\nlet fishCollection: Collection<Fish> = new Collection();\nfishCollection.add(new Fish('shark'));\nfishCollection.add(new Fish('barracuda'));\n\nlet shark: Fish = fishCollection.getItemByName('shark'); // Ok\n`````\n\nПример, когда параметр типа расширяет другой параметр типа, будет рассмотрен немного позднее.\n\nТакже не лишним будет заметить, что когда параметр типа расширяет другой тип, в качестве аргумента типа можно будет передать только совместимый с ним тип.\n\n`````ts\ninterface Bird { fly(): void; }\ninterface Fish { swim(): void; }\n\ninterface IEgg<T extends Bird> { child: T; }\n\nlet v1: IEgg<Bird>; // Ok\nlet v2: IEgg<Fish>; // Error -> Type 'Fish' does not satisfy the constraint 'Bird'\n`````\n\nКроме того, расширять можно любые подходящие для этого типы, полученные любым доступным путем.\n\n`````ts\ninterface IAnimal {\n    name: string;\n    age: number;\n}\n\nlet animal: IAnimal;\n\nclass Bird<T extends typeof animal> {} // T extends IAnimal\nclass Fish<K extends keyof IAnimal> {} // K extends \"name\" | \"age\"\nclass Insect<V extends IAnimal[K], K extends keyof IAnimal> {} // V extends string | number\nclass Reptile<T extends number | string, U extends number & string> {}\n`````\n\nПомимо прочего, одна важная и не очевидная особенность связана с параметром типа расширяющего `any`. Может показаться, что в таком случае над параметром типа будет возможно производить любые операции допускаемые типом `any`. Но в реальности это не так. Поскольку `any` предполагает выполнение над собой любых операций, то для повышения типобезопасности подобное поведение для типов, представляемых параметрами типа, было отменено.\n\n`````ts\n class ClassType<T extends any> {\n     private f0: any = {}; // Ok\n     private field: T = {}; // Error [0]\n\n     constructor(){\n         this.f0.notExistsMethod(); // Ok [1]\n         this.field.notExistsMethod(); // Error [2]\n     }\n }\n\n /**\n  * Поскольку параметр типа, расширяющий тип any,\n  * подрывает типобезопасность программы, то вывод\n  * типов такой параметр расценивает как принадлежащий\n  * к типу unknown, запрещающий любые операции над собой.\n  * \n  * [0] тип unknown не совместим с объектным типом {}.\n  * [1] Ok на этапе компиляции и Error вовремя выполнения.\n  * [2] тип unknown не описывает метода notExistsMethod().\n  */ \n`````"},{"key":"Обобщения (Generics)_3","elementId":"Parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)","markdown":"## Параметра типа - значение по умолчанию = (generic parameter defaults)\n\nПомимо прочего, _TypeScript_ позволяет указывать для параметров типа значение по умолчанию.\n\nЗначение по умолчанию указывается с помощью оператора равно `=`, слева от которого располагается параметр типа, а справа конкретный тип, либо другой параметр типа `T = Type`. Параметры, которым заданы значения по умолчанию, являются необязательными параметрами. Необязательные параметры типа должны быть перечислены строго после обязательных. Если параметр типа указывается в качестве типа по умолчанию, то ему самому должно быть задано значение по умолчанию, либо он должен расширять другой тип.\n\n`````ts\nclass T1<T = string> {} // Ok\nclass T2<T = U, U> {} // Error -> необязательное перед обязательным\nclass T3<T = U, U  = number> {} // Ok\n\nclass T4<T = U, U extends number> {} // Error -> необязательное перед обязательным\nclass T5<U extends number, T = U> {} // Ok.\n`````\n\nКроме того, можно совмещать механизм установки значения по умолчанию и механизм расширения типа. В этом случае оператор равно `=` указывается после расширяемого типа.\n\n`````ts\nclass T1 <T extends T2 = T3> {}\n`````\n\nВ момент, когда тип `T` расширяет другой тип, он получает признаки этого типа. Именно поэтому для параметра типа, расширяющего другой тип, в качестве типа по умолчанию можно указывать только совместимый с ним тип. \n\nЧтобы было проще понять, нужно представить два класса, один из которых расширяет другой. В этом случае переменной с типом суперкласса можно в качестве значения присвоить объект его подкласса, но — не наоборот.\n\n`````ts\nclass Animal {\n    public name: string;\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nlet bird: Animal = new Bird(); // Ok\nlet animal: Bird = new Animal(); // Error\n`````\n\nТот же самый механизм используется для параметров типа.\n\n`````ts\nclass Animal {\n    public name: string;\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nclass T1 <T extends Animal = Bird> {} // Ok\n// -------(   Animal   ) = Bird\n\nclass T2 <T extends Bird = Animal> {} // Error\n// -------(   Bird   ) = Animal\n`````\n\nНеобходимо сделать акцент на том, что вывод типов обращает внимание на необязательные параметры типа только при работе с аргументами этого обобщенного типа. Чтобы было более понятно, вспомним ещё раз, что механизм ограничения параметров типа производится с помощью ключевого слова `extends`. Признаки типа расположенного правее ключевого слова `extends` рассматриваются не только при сопоставлении аргументов типа, но и при выполнении операций над типом, представленным параметром типа. Простыми словами, вывод типов берет во внимание расширенный тип как снаружи (аргумент типа), так и внутри (параметр типа) обобщенного типа.\n\n`````ts\n/**\n * T расширяет string...\n */\nclass A<T extends string> {\n    constructor(value?: T) {\n        /**\n         * ..., что заставляет вывод типов рассматривать\n         * значение, принадлежащее к нему, в качестве строкового\n         * как внутри...\n         */\n\n        if (value) {\n            value.charAt(0); // Ok -> ведь value наделено признаками присущими типу string\n        }\n    }\n}\n\n// ...так и снаружи\nlet a0 = new A(); // Ok -> let a0: A<string>. string, потому, что параметр типа ограничен им\nlet a1 = new A(`ts`); // Ok -> let a1: A<\"ts\">. literal string, потому, что он совместим со стринг, но более конкретен\nlet a2 = new A(0); // Error -> потому, что number не совместим с ограничивающим аргумент типа типом string\n\n`````\n\nТип, который указывается параметру типа в качестве типа по умолчанию, вообще ничего не ограничивает. \n\n`````ts\n// тип string устанавливается типу T в качестве типа по умолчанию...\nclass B<T = string> {\n    constructor(value?: T) {\n        if (value) {\n            // ..., что не оказывает никакого ограничения ни внутри...\n            value.charAt(0); // Error -> тип T не имеет определение метода charAt\n        }\n    }\n}\n\n\n// ...ни снаружи\nlet b0 = new B(); // Ok -> let b0: B<string>\nlet b1 = new B(`ts`); // Ok -> let b1: B<string>\nlet b2 = new B(0); // Ok -> let b2: B<number>\n`````\n\nПри отсутствии аргументов типа был бы выведен тип `unknown`, а не тип указанный по умолчанию.\n\n`````ts \n\n// с типом по умолчанию\nclass B<T = string> {\n    constructor(value?: T) {\n    }\n}\n\n// без типа по умолчанию\nclass С<T> {\n    constructor(value?: T) {\n    }\n}\n\n\nlet b = new B(); // Ok -> let b: B<string>\nlet с = new С(); // Ok -> let с: С<unknown>\n````` \n\nНе будет лишним также рассмотреть отличия этих двух механизмов при работе вывода типов.\n\n`````ts\n// ограничение типа T типом string\ndeclare class A<T extends string> {\n    constructor(value?: T)\n}\n\n// тип string устанавливается типу T в качестве типа по умолчанию\ndeclare class B<T = string> {\n    constructor(value?: T)\n}\n\n\nlet a0 = new A(); // Ok -> let a0: A<string>\nlet b0 = new B(); // Ok -> let b0: B<string>\n\nlet a1 = new A(`ts`); // Ok -> let a1: A<\"ts\">\nlet b1 = new B(`ts`); // Ok -> let b1: B<string>\n\nlet a2 = new A<string>(`ts`); // Ok -> let a2: A<string>\nlet b2 = new B<string>(`ts`); // Ok -> let b2: B<string>\n\nlet a3 = new A<number>(0); // Error\nlet b3 = new B<number>(0); // Ok -> let b3: B<number>\n`````"},{"key":"Обобщения (Generics)_4","elementId":"Parametry_tipa_-_kak_tip_dannyh","markdown":"## Параметры типа - как тип данных\n\nПараметры типа, указанные в угловых скобках при объявлении обобщенного типа, изначально не принадлежат ни к одному типу. Несмотря на это, компилятор расценивает параметры типа как совместимые с такими типами как `any` и `never`, а также самим собой.\n\n`````ts\nfunction f0<T>(p: any): T { // Ok, any совместим с T\n    return p;\n}\n\nfunction f1<T>(p: never): T { // Ok, never совместим с T\n    return p;\n}\n\nfunction f2<T>(p: T): T { // Ok, T совместим с T\n    return p;\n}\n`````\n\nЕсли обобщенная коллекция в качестве аргумента типа получает тип объединение (`Union`), то все её элементы будут принадлежать к типу объединения. Простыми словами, элемент из такой коллекции не будет, без явного преобразования, совместим ни с одним из вариантов, составляющих тип объединение.\n\n`````ts\ninterface IName { name: string; }\n\ninterface IAnimal extends IName {}\n\nabstract class Animal implements IAnimal {\n  constructor(readonly name: string) {}\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nclass Fish extends Animal {\n    public swim(): void {}\n}\n\nclass Collection<T extends IName> {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item => item.name === name); // Ok\n    }\n}\n\nlet collection: Collection<Bird | Fish> = new Collection();\n  collection.add(new Bird('bird'));\n  collection.add(new Fish('fish'));\n\nvar bird: Bird = collection.getItemByName('bird'); // Error -> Type 'Bird | Fish' is not assignable to type 'Bird'\nvar bird: Bird = collection.getItemByName('bird') as Bird; // Ok\n`````\n\nНо операцию приведения типов можно поместить (сокрыть) прямо в метод самой коллекции и тем самым упростить её использование. Для этого метод должен быть обобщенным, а его параметр типа, указанный в качестве возвращаемого из функции, расширять параметр типа самой коллекции. \n\n`````ts\n// ...\n\nclass Collection<T extends IName> {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    // 1. параметр типа U должен расширять параметр типа T\n    // 2. возвращаемый тип указан как U\n    // 3. возвращаемое значение нуждается в явном преобразовании к типу U\n    public getItemByName<U extends T>(name: string): U {\n        return this.itemAll.find(item => item.name === name) as U; // Ok\n    }\n}\n\nlet collection: Collection<Bird | Fish> = new Collection();\n collection.add(new Bird('bird'));\n collection.add(new Fish('fish'));\n\nvar bird: Bird = collection.getItemByName('bird'); // Ok\nvar birdOrFish = collection.getItemByName('bird'); // Bad, var birdOrFish: Bird | Fish\nvar bird = collection.getItemByName<Bird>('bird'); // Ok, var bird: Bird\n`````\n\nСокрытие приведения типов прямо в методе коллекции повысило “привлекательность” кода. Но, все же, в случаях, когда элемент коллекции присваивается конструкции без явной аннотации типа, появляется потребность вызывать обобщенный метод с аргументами типа.\n\nКроме того, нужно не забывать, что два разных объявления параметров типа несовместимы, даже если у них идентичные идентификаторы.\n\n`````ts\nclass Identifier<T> {\n    array: T[] = [];\n    \n    method<T>(param: T): void  {\n        this.array.push(param); // Error, T объявленный в сигнатуре функции не совместим с типом T объявленном в сигнатуре класса\n    }\n}\n`````"},{"key":"Обобщения (Generics)_5","elementId":"Modifikatory_variantnosti_parametrov_tipa_in_i_out","markdown":"## Модификаторы вариантности параметров типа in и out\n\nИдентификация данных осуществляется при помощи типов и предназначена для предотвращения попадания в операции неподходящих для них значений. Каждая операция имеет свое низкоуровневое описание содержащее, в том числе и тип, к которому должно принадлежать пригодное для неё значение. Сверка типа значения с этим типом называется процессом выявления совместимости. Совместимость осуществляется по правилам вариантности, которые бывают четырех видов. Но прежде, чем рассмотреть каждый из них, ненадолго отвлечемся на _TypeScript_.\nПоскольку _TypeScript_ реализует _структурную типизацию_, тип проще всего представить в виде обычного листка бумаги, который может содержать имена (идентификаторы) ассоциированные с какими-либо другими типами. Идентификатор + ассоциированный с ним тип = признак типа. Именно на основе этих признаков и осуществляется процесс выявления совместимости речь о которой пойдет сразу после того освещения ещё одной очень простой темы - иерархии наследования.\nПредставляя иерархию наследования в голове сразу вырисовывается картина из мира номинативной типизации, что неосознанно выбивает из колеи структурной. Поэтому сразу стоит сосредоточиться на интересующей нас детали - логическом обозначении иерархических отношений. Дело в том, что иерархия направлена сверху вниз, а значит более базовый тип расположен выше, чем его подтип. Таким образом, в логических выражениях представляющих иерархию базовые типы обозначаются, как большие (`>`) по отношению к своим подтипам. И наоборот. То есть, `SuperType > SubType` и `SubType < SuperType`. Но упомяну ещё раз, в структурной типизации нет понятия иерархия наследования, поскольку при сравнении берутся в расчет признаки типов, а не ссылки (`ref`). Но чтобы не забивать особо голову просто возьмем за правило, что тип, который обладает всеми признаками другого типа и кроме этого содержит дополнительные, будет считаться подтипом, а значит, в логических выражениях будет обозначаться меньшим (`<`).\n\n`````ts\ninterface A {\n    f0: boolean;\n}\ninterface B {\n    f0: boolean;\n    f1: number;\n}\ninterface С {\n    f0: boolean;\n    f1: number;\n}\n\n// A > B или B < A\n// A > C или C < A\n// B = C или C = B\n`````\n\nЭто очень просто и это знают все, но повторить все равно стоило, так как именно логические выражения нам помогут разобраться в количестве видов вариантов совместимости. Теперь, на основе полученной информации давайте рассмотрим варианты по которым может происходить проверка на совместимость.\n\nИ так, вариантов всего четыре и каждый из них имеет собственное название. Но чтобы было более понятно рассмотрим сценарий, когда переменной принадлежащей к типу `A` может быть присвоено значение с типом `B`.\n\n`Ковариантность` предполагает, что проверка на совместимость завершится успехом в случаи, когда `B < A` или `B = A` (в номинативной типизации `B` подтип `A` ). `Контрвариантность` предполагает, что `B > A` или `B = A` (в номинативной бы это звучало, как базовый тип можно совместим с подтипом или самим собой, но не наоборот). `Инвариантность`, это когда совместимы исключительно при условии `B = A`. `Бивариантность` подразумевает `B < A`, `B > A` или `B = A`, то есть - все предыдущие варианты в одном.\n\nА теперь к сути дела. В _TypeScript_ все типы проверяются на совместимость по ковариантным правилам, за исключением параметров функций, которые контрвариантны. Поскольку различные правила на сложных рекурсивных типах требуют дорогостоящие вычисления, _TypeScript_ реализует механизм явного аннотирования параметров типа при с помощью необязательных модификаторов `in` и `out`.\n\n`in` указывает, что параметр типа ковариантен, а `out` контрвариантен. Но стоит сделать акцент на том, что с помощью этих модификаторов невозможно изменить правила по которым _TypeScript_ производит вычисления совместимости, а можно лишь их конкретизировать.\n\n`````ts\ntype Setter<T> = (param: T) => void;\ntype Getter<T> = () => T;\n\n/**\n * Стандартный код.\n * При сравнении двух сеттеров параметры в сигнатуре будут проверятся по контрвариантным правилам, а для геттеров возвращаемые типы по ковариантным.\n */\n`````\n`````ts\ntype Setter<in T> = (param: T) => void;\ntype Getter<out T> = () => T;\n\n/**\n * [Код с модификаторами]\n * Правила будут идентичны предыдущему примеру. Разница лишь в явной конкретизации.\n */\n`````\n`````ts\ntype Setter<out T> = (param: T) => void; // [0]\ntype Getter<in T> = () => T; // [1]\n\n/**\n * [Код с модификаторами]\n * К тому же, нельзя изменить поведение, то есть - нельзя поменять модификаторы местами!\n */\n\n/**\n * [0]\n * Type 'Setter<sub-T>' is not assignable to type 'Setter<super-T>' as implied by variance annotation.\n *  Types of parameters 'param' and 'param' are incompatible.\n *   Type 'super-T' is not assignable to type 'sub-T'.ts(2636)\n */\n\n/**\n * [1]\n * Type 'Getter<super-T>' is not assignable to type 'Getter<sub-T>' as implied by variance annotation.\n *  Type 'super-T' is not assignable to type 'sub-T'.ts(2636)\n */\n`````\n\nПроще всего воспринимать эти модификаторы, как указание на то, что тип будет использоваться во входных параметрах (`<in T>`) или выходных (`<out T>`) или и то и другое одновременно `<in out T>`.\n\n`````ts\n/**\n * Указание на то, что тип используется во входных и в выходных параметрах. \n */\ntype Func<in out T> = (param: T) => T;\n`````"}],"githubFileInfo":{"lastUpdate":1650966357000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion"},"nextPage":{"title":"Дискриминантное объединение (Discriminated Union)","path":"Diskriminantnoe_obedinenie_(Discriminated_Union)"}},"contentNavData":{"key":"Обобщения (Generics)","level":0,"index":34,"contentIndex":0,"section":"Типы","title":"Обобщения (Generics)","path":"Obobshcheniya_(Generics)","elementId":"Obobshcheniya_(Generics)","children":[{"key":"Обобщения (Generics)_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Обобщения - общие понятия","path":"Obobshcheniya_-_obshchie_ponyatiya","elementId":"Obobshcheniya_-_obshchie_ponyatiya"},{"key":"Обобщения (Generics)_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Обобщения в TypeScript","path":"Obobshcheniya_v_TypeScript","elementId":"Obobshcheniya_v_TypeScript"},{"key":"Обобщения (Generics)_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Параметры типа - extends (generic constraints)","path":"Parametry_tipa_-_extends_(generic_constraints)","elementId":"Parametry_tipa_-_extends_(generic_constraints)"},{"key":"Обобщения (Generics)_3","index":3,"contentIndex":4,"level":1,"section":"Типы","title":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"Parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)","elementId":"Parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)"},{"key":"Обобщения (Generics)_4","index":4,"contentIndex":5,"level":1,"section":"Типы","title":"Параметры типа - как тип данных","path":"Parametry_tipa_-_kak_tip_dannyh","elementId":"Parametry_tipa_-_kak_tip_dannyh"},{"key":"Обобщения (Generics)_5","index":5,"contentIndex":6,"level":1,"section":"Типы","title":"Модификаторы вариантности параметров типа in и out","path":"Modifikatory_variantnosti_parametrov_tipa_in_i_out","elementId":"Modifikatory_variantnosti_parametrov_tipa_in_i_out"}]},"pageDescription":"Обобщения (Generics)"},"__N_SSG":true}