{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/037.(Типизация) Утверждение типов (Type Assertion)/images/"},"sectionInfoAll":[{"key":"Утверждение типов (Type Assertion)","elementId":"Utverjdenie_tipov_(Type_Assertion)","markdown":"# Утверждение типов (Type Assertion)\n\nПолучение значения, которое несоответствует ожидаемому типу, является обычным делом для типизированных языков. Понимание причин, лежащих в основе несоответствий, а также всевозможные способы их разрешений, являются целями данной главы."},{"key":"Утверждение типов (Type Assertion)_0","elementId":"Utverjdenie_tipov_-_obshchee","markdown":"## Утверждение типов - общее\n\nПри разработке приложений на языках со статической типизацией, время от времени может возникнуть нестыковка из-за несоответствия типов. Простыми словами, приходится работать с объектом, принадлежащим к известному типу, но ограниченному более специализированным (менее конкретным) интерфейсом.\n\nВ _TypeScript_ большинство операций с несоответствием типов приходится на работу с _dom_ (_Document Object Model_).\n\nВ качестве примера можно рассмотреть работу с таким часто используемым методом, как `querySelector()`. Но для начала вспомним, что в основе составляющих иерархию dom-дерева объектов лежит базовый тип `Node`, наделенный минимальными признаками, необходимыми для построения коллекции. Базовый тип `Node`, в том числе, расширяет и тип `Element`, который является базовым для всех элементов dom-дерева и обладает знакомыми всем признаками, необходимыми для работы с элементами dom, такими как атрибуты (`attributes`), список классов (`classList`), размеры клиента (`client*`) и другими. Элементы dom-дерева можно разделить на те, что не отображаются (унаследованные от `Element`, как например `script`, `link`) и те, что отображаются (например `div`, `body`). Последние имеют в своей иерархии наследования тип `HTMLElement`, расширяющий `Element`, который привносит признаки, присущие отображаемым объектам, как например координаты, стили, свойство `dataset` и т.д.\n\nВозвращаясь к методу `querySelector()`, стоит уточнить, что результатом его вызова может стать любой элемент, находящийся в dom-дереве. Если бы в качестве типа возвращаемого значения был указан тип `HTMLElement`, то операция получения элемента `<script>` или `<link>` завершилась бы неудачей, так как они не принадлежат к этому типу. Именно поэтому методу `querySelector()` в качестве типа возвращаемого значения указан более базовый тип `Element`.\n\n`````ts\n// <canvas id=\"stage\" data-inactive=\"false\"></canvas>\n\nconst element: Element = document.querySelector('#stage');\nconst stage: HTMLElement = element // Error, Element is not assignable to type HTMLElement\n`````\n\nНо, при попытке обратится к свойству `dataset` через объект, полученный с помощью `querySelector()`, возникнет ошибка, так как у типа `Element` отсутствует данное свойство. Факт, что разработчику известен тип, к которому принадлежит объект по указанному им селектору, дает ему основания попросить вывод типов пересмотреть свое отношение к типу конкретного объекта.\n\n_Попросить_ - дословно означает, что разработчик может лишь попросить вывод типов пересмотреть отношение к типу. Но решение разрешить операцию или нет все равно остается за последним.\n\nВыражаясь человеческим языком, в _TypeScript_ процесс, вынуждающий вывод типов пересмотреть свое отношение к какому-либо типу, называется _утверждением типа_ (`Type Assertion`).\n\nФормально утверждение типа похоже на _преобразование_ (приведение) типов (_type conversion_, _typecasting_), но, поскольку в скомпилированном коде от типов не остается и следа, то, по факту, это совершенно другой механизм. Именно поэтому он и называется _утверждение_. Утверждая тип, разработчик говорит компилятору — _“поверь мне, я знаю, что делаю”_ (_Trust me, I know what I'm doing_).\n\nНельзя не уточнить, что хотя в _TypeScript_ и существует термин утверждение типа, по ходу изложения в качестве синонимов будут употребляться слова преобразование, реже — приведение. А так же, не будет лишним напомнить, что приведение — это процесс в котором объект одного типа преобразуется в объект другого типа."},{"key":"Утверждение типов (Type Assertion)_1","elementId":"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa","markdown":"## Утверждение типа с помощью <Type> синтаксиса\n\nОдним из способов указать компилятору на принадлежность значения к заданному типу является механизм утверждения типа при помощи угловых скобок `<ConcreteType>`, заключающих в себе конкретный тип, к которому и будет выполняться преобразование. Утверждение типа располагается строго перед выражением, результатом выполнения которого, будет преобразуемый тип.\n\n`````ts\n<ToType>FromType\n`````\n\nПерепишем предыдущий код и исправим в нем ошибку, связанную с несоответствием типов.\n\n`````ts\n// <canvas id=\"stage\" data-inactive=\"false\"></canvas>\n\nconst element: Element = document.querySelector('#stage');\n\nconst stage: HTMLElement = <HTMLElement>element // Ok\nstage.dataset.inactive = 'true';\n`````\n\nЕсли тип, к которому разработчик просит преобразовать компилятор, не совместим с преобразуемым типом, то в процессе утверждения возникнет ошибка.\n\n`````ts\nclass Bird {\n    public fly(): void {}\n}\n\nclass Fish {\n    public swim(): void {}\n}\n\nlet bird: Bird = new Bird();\nlet fish: Fish = <Fish>bird; // Ошибка, 'Bird' не может быть преобразован в 'Fish'\n`````\n\nКроме того, существуют ситуации, в которых возникает необходимость множественного последовательного преобразования. Ярким примером являются значения полученные от _dom_ элементов, которые воспринимаются разработчиком как числовые или логические, но по факту принадлежат к строковому типу.\n\n`````ts\n// <div id=\"#container\"></div>\n\nlet element = document.querySelector('#container') as HTMLElement;\nlet { width, height } = element.style;\nlet area: number = width * height; // ошибка -> width и height типа 'string'\n`````\n\nДело в том, что в _TypeScript_ невозможно привести тип `string` к типу `number`.\n\n`````ts\n// <div id=\"#container\"></div>\n\nlet element = document.querySelector('#container') as HTMLElement;\nlet { width: widthString, height: heightString } = element.style;\n\nlet width: number = <number>widthString; // Ошибка -> тип 'string' не может быть преобразован  в 'number'\nlet height: number = <number>heightString; // Ошибка -> тип 'string' не может быть преобразован  в 'number'\n`````\n\nНо осуществить задуманное можно преобразовав тип `string` сначала в тип `any`, а уже затем — в тип `number`.\n\n`````ts\n// <div id=\"#container\"></div>\n\nlet element = document.querySelector('#container') as HTMLElement;\nlet { width: widthString, height: heightString } = element.style;\n\nlet width: number = <number><any>widthString; // Ok\nlet height: number = <number><any>heightString; // Ok\n\nlet area: number = width * height; // Ok\n`````\n\nСтоит также заметить, что данный способ утверждения типа, кроме синтаксиса, больше ничем не отличается от указания с помощью оператора `as`."},{"key":"Утверждение типов (Type Assertion)_2","elementId":"Utverjdenie_tipa_s_pomoshchu_operatora_as","markdown":"## Утверждение типа с помощью оператора as\n\nВ отличие от синтаксиса угловых скобок, которые указываются перед преобразуемым типом, оператор `as` указывается между преобразуемым и типом, к которому требуется преобразовать.\n\n`````ts\nFromType as ToType\n`````\n\nДля демонстрации оператора `as` рассмотрим ещё один часто встречающийся случай, требующий утверждения типов.\n\nОбычное дело: при помощи метода `querySelector()` получить объект, принадлежащий к типу `HTMLElement` и подписать его на событие `click`. Задача заключается в том, что при возникновении события, нужно изменить значение поля `dataset`, объявленного в типе `HTMLElement`. Было бы нерационально снова получать ссылку на объект при помощи метода `querySelector()`, ведь нужный объект хранится в свойстве объекта события `target`. Но дело в том, что свойство `target` имеет тип `EventTarget`, который не находится в иерархической зависимости с типом `HTMLElement` имеющим нужное свойство `dataset`.\n\n`````ts\n// <span id=\"counter\"></span>\n\nlet element = document.querySelector('#counter') as HTMLElement;\nelement.dataset.count = (0).toString();\n\nelement.addEventListener('click', ({ target }) => {\n    let count: number = target.dataset.count; // Error -> Property 'dataset' does not exist on type 'EventTarget'\n});\n`````\n\nНо эту проблему легко решить с помощью оператора утверждения типа `as`. Кроме того, с помощью этого же оператора можно привести тип `string`, к которому принадлежат все свойства находящиеся в `dataset`, к типу `any`, а уже затем к типу `number`.\n\n`````ts\nlet element = document.querySelector('#counter') as HTMLElement;\nelement.dataset.count = (0).toString();\n\nelement.addEventListener('click', ({ target }) => {\n    let element = target as HTMLElement;\n    let count: number = element.dataset.count as any as number;\n\n    element.dataset.count = (++count).toString();\n});\n`````\n\nВ случае несовместимости типов возникнет ошибка.\n\n`````ts\nclass Bird {\n    public fly(): void {}\n}\n\nclass Fish {\n    public swim(): void {}\n}\n\nlet bird: Bird = new Bird();\nlet fish: Fish = bird as Fish; // Ошибка, 'Bird' не может быть преобразован в 'Fish'\n`````\n\nЕщё одна острая необходимость, требующая утверждения типа, возникает тогда, когда разработчику приходится работать с объектом, ссылка на который ограничена более общим типом, как например `any`.\n\nФакт, что над значением, принадлежащему к типу `any`, разрешено выполнение любых операций, означает, что компилятор их не проверяет. Другими словами, разработчик, указывая тип `any`, усложняет процесс разработки, мешая компилятору проводить статический анализ кода, а также лишает себя помощи со стороны редактора кода. Когда разработчику известно к какому типу принадлежит значение, можно попросить компилятор изменить мнение о принадлежности значения к его типу с помощью механизма утверждения типов.\n\n`````ts\nclass DataProvider {\n    constructor(readonly data: any) {}\n}\n\nlet provider: DataProvider = new DataProvider('text');\n\nvar charAll: string[] = provider.data.split(''); // Ок\nvar charAll: string[] = provider.data.sPlIt(''); // Ошибка во время выполнения программы\nvar charAll: string[] = (provider.data as string).split(''); // Ок\n\nlet dataString: string = provider.data as string;\nvar charAll: string[] = dataString.split(''); // Ок\n`````\n\nНапоследок, стоит сказать, что выражения, требующие _утверждения типа_, при работе с _dom api_ — это неизбежность. Кроме того, для работы с методом `document.querySelector()`, который был использован в примерах к этой главе, вместо приведения типов с помощью операторов `<Type>` или `as` предпочтительней конкретизировать тип с помощью обобщения, которые рассматриваются в главе [“Типы - Обобщения (Generics)”](../032.(Типы)%20Обобщения%20(Generics)). Но в случае, если утверждение требуется для кода, написанного самим разработчиком, то, скорее всего, это следствие плохо продуманной архитектуры."},{"key":"Утверждение типов (Type Assertion)_3","elementId":"Privedenie_(utverjdenie)_k_konstante_(const_assertion)","markdown":"## Приведение (утверждение) к константе (const assertion)\n\nНи для кого не секрет, что с точки зрения _JavaScript_, а следовательно и _TypeScript_, все примитивные литеральные значения являются константными значениями. С точки зрения среды исполнения два эквивалентных литерала любого литерального типа являются единым значением. То есть, среда исполнения расценивает два строковых литерала `'text'` и `'text'` как один литерал. Тоже справедливо и для остальных литералов, к которым помимо типа `string` также относятся типы `number`, `boolean` и `symbol`.\n\nТем не менее, сложно найти разработчика _TypeScript_, не испытавшего трудностей, создаваемых выводом типов, при определении конструкций, которым предстоит проверка на принадлежность к литеральному типу.\n\n`````ts\ntype Status = 200 | 404;\ntype Request = { status: Status }\n\nlet status = 200;\n\nlet request: Request = { status }; // Error, TS2322: Type 'number' is not assignable to type 'Status'.\n`````\n\nВ коде выше ошибка возникает по причине того, что вывод типов определяет принадлежность значения переменной `status` к типу `number`, а не литеральному числовому типу `200`.\n\n`````ts\n// вывод типов видит как\nlet status: number = 200\n\n// в, то время как требуется так\nlet port: 200 = 200;\n`````\n\nПрежде всего не будет лишним упомянуть, что данную проблему можно решить с помощью механизма утверждения при помощи таких операторов как `as` и угловых скобок `<>`.\n\n`````ts\ntype Status = 200 | 404;\ntype Request = { status: Status }\n\nlet status = 200;\n\n// утверждаем компилятору..\nlet request: Request = { status: status as 200 }; // ...с помощью as оператора\n// let request: Request = { status: <200>status }; // ...или с помощью угловых скобок\n// ..., что он должен рассматривать значение, ассоциированное с as, как значение, принадлежащие к литеральному типу '200'\n`````\n\nНо лучшим решением будет специально созданный для подобных случаев механизм, позволяющий производить утверждение к константе.\n\nКонстантное утверждение производится с помощью оператора `as` или угловых скобок `<>` и говорит компилятору, что значение является константным.\n\n`````ts\ntype Status = 200 | 404;\ntype Request = { status: Status }\n\nlet status = 200 as const;\n// let status = <const>200;\n\nlet request: Request = { status }; // Ok\n`````\n\nУтверждение, что значение является константным, заставляет вывод типов расценивать его как принадлежащее к литеральному типу. Утверждение к константе массива заставляет вывод типов определять его принадлежность к типу `readonly tuple`.\n\n`````ts\nlet a = [200, 404]; // let a: number[]\n\nlet b = [200, 404] as const; // let b: readonly [200, 404]\nlet c = <const>[200, 404]; // let c: readonly [200, 404]\n`````\n\nВ случае с объектным типом, утверждение к константе рекурсивно помечает все его поля как `readonly`. Кроме того, все его поля, принадлежащие к примитивным типам, расцениваются как литеральные типы.\n\n`````ts\ntype NotConstResponseType = {\n    status: number;\n    data: {\n        role: string;\n    };\n}\n\ntype ConstResponseType = {\n    status: 200 | 404;\n    data: {\n        role: 'user' | 'admin';\n    };\n}\n\nlet a = { status: 200, data: { role: 'user' }}; // NotConstResponseType\n\nlet b = { status: 200, data: { role: 'user' }} as const; // ConstResponseType\nlet c = <const>{ status: 200, data: { role: 'user' }}; // ConstResponseType\n`````\n\nНо стоит помнить, что утверждение к константе применимо исключительно к литералам таких типов, как `number`, `string`, `boolean`, `array` и `object`.\n\n`````ts\nlet a = 'value' as const; // Ok - 'value' является литералом, let a: \"value\"\nlet b = 100 as const; // Ok - 100 является литералом, let b: 100\nlet c = true as const; // Ok - true является литералом, let c: true\n\nlet d = [] as const; // Ok - [] является литералом, let d: readonly []\nlet e = { f: 100 } as const; // Ok - {} является литералом, let e: {readonly f: 100}\n\nlet value = 'value'; // let value: string\nlet array = [0, 1, 2]; // let array: number[]\nlet object = { f: 100 }; // let object: {f: number}\n\nlet f = value as const; // Ошибка, value — это ссылка на идентификатор, хранящий литерал\nlet g = array as const; // Ошибка, array — это ссылка на идентификатор, хранящий ссылку на массив\nlet h = object as const; // Ошибка, object — это ссылка на идентификатор, хранящий ссылку на объект\n`````\n\nПосле рассмотрения всех случаев утверждения к константе (примитивных, массивов и объектных типов) может сложиться впечатление, что в _TypeScript_, наконец, появились структуры, которые справедливо было бы назвать _полноценными константами_, неизменяемыми ни при каких условиях. И это, отчасти, действительно так. Но дело в том, что на данный момент, принадлежность объектных и массивоподобных типов к константе зависит от значений, с которыми они ассоциированы.\n\nВ случае, когда литералы ссылочных типов (массивы и объекты) ассоциированы со значением также принадлежащим к ссылочному типу, они представляются такими, какими были на момент ассоциации. Кроме того, поведение механизма приведения к константе зависит от другого механизма — деструктуризации.\n\n`````ts\nlet defaultObject = { f: 100 }; // let defaultObject: {f: number}\nlet constObject = { f: 100 } as const; // let constObject: {readonly f: 100}\n\nlet defaultArray = [0, 1, 2]; // let defaultArray: number[]\nlet constArray = [0, 1, 2] as const; // let constArray: readonly [0, 1, 2]\n\n// o0 иммутабельный (неизменяемый) объект\nlet o0 = { f: { f: 100 } } as const; // {readonly f: {readonly f: 100}}\n// o1.f имеет модификатор readonly, o1.f.f - мутабельный (изменяемый) объект\nlet o1 = { f: defaultObject } as const; // {readonly f: {f: number}}\n// o2 иммутабельный (неизменяемый) объект\nlet o2 = { ...defaultObject } as const; // {readonly f: number}\n// o3.f и o3.f.f иммутабельные (неизменяемые) объекты\nlet o3 = { f: { ...defaultObject } } as const; // {readonly f: {readonly f: number}}\n\n// o4.f и o4.f.f иммутабельные (неизменяемые) объекты\nlet o4 = { f: constObject } as const; // let o4: {readonly f: {readonly f: 100}}\n// o5 иммутабельный (неизменяемый) объект\nlet o5 = { ...constObject } as const; // let o5: {readonly f: 100}\n// o6 иммутабельный (неизменяемый) объект\nlet o6 = { f: { ...constObject } } as const; // {readonly f: {readonly f: 100}}\n`````\n\nПо причине, что объектные типы данных, хранящиеся в массиве, подчиняются описанным выше правилам, подробное рассмотрение процесса утверждения массива к константе будет опущено.\n\nИ последнее, о чем стоит упомянуть — утверждение к константе применимо только к простым выражениям.\n\n`````ts\nlet a = (Math.round(Math.random() * 1) ? 'yes' : 'no') as const; // Ошибка\nlet b = Math.round(Math.random() * 1) ? 'yes' as const : 'no' as const; // Ok, let b: \"yes\" | \"no\"\n`````"},{"key":"Утверждение типов (Type Assertion)_4","elementId":"Utverjdenie_v_signature_(Signature_Assertion)","markdown":"## Утверждение в сигнатуре (Signature Assertion)\n\nПомимо функций, реализующих механизм _утверждения типа_, в _TypeScript_ существует механизм _утверждения в сигнатуре_, позволяющий определять утверждающие функции, вызов которых, в случае невыполнения условия, приводит к выбрасыванию исключения. Для того, что бы объявить утверждающую функцию, в её сигнатуре (там где располагается возвращаемое значение) следует указать ключевое слово `asserts`, а затем параметр принимаемого на вход условия.\n\n`````ts\nfunction identifier(condition: any): asserts condition {\n    if (!condition) {\n        throw new Error('');\n    }\n}\n`````\n\nКлючевой особенностью утверждения в сигнатуре является то, что в качестве аргумента утверждающая функция ожидает выражение, определяющие принадлежность к конкретному типу с помощью любого предназначенного для этого механизма (`typeof`, `instanceof` и даже с помощью механизма утверждения типов, реализуемого самим _TypeScript_).\n\nЕсли принадлежность значения к указанному типу подтверждается, то далее по коду компилятор будет рассматривать его в роли этого типа. Иначе выбрасывается исключение.\n\n`````ts\n// утверждение в сигнатуре\nfunction isStringAssert(condition: any): asserts condition {\n    if (!condition) {\n        throw new Error(``);\n    }\n}\n\n// утверждение типа\nfunction isString(value: any): value is string {\n    return typeof value === 'string';\n}\n\nconst testScope = (text: any) => {\n    text.toUppercase(); // до утверждения расценивается как тип any..\n\n    isStringAssert(text instanceof String); // выражение с оператором instanceof\n    isStringAssert(typeof text === 'string'); // выражение с оператором typeof\n    isStringAssert(isString(text)); // механизм \"утверждения типа\"\n\n    text.toUppercase(); // ..после утверждения, как тип string\n}\n`````\n\nПри использовании механизма _утверждения в сигнатуре_ с механизмом _утверждения типа_, условие можно перенести из вызова утверждающей функции в её тело.\n\n`````ts\nfunction isStringAsserts(value: any): asserts value is string {\n    if (typeof value !== \"string\") {\n        throw new Error(``);\n    }\n}\n\nconst testScope = (text: any) => {\n    text.toUppercase(); // не является ошибкой, потому, что тип — any\n\n    isStringAsserts(text); // условие определено внутри утверждающей функции\n\n    text.toUppercase(); // теперь ошибка, потому, что тип утвержден как string\n}\n`````\n\nСтоит обратить внимание на то, что механизм утверждения типа не будет работать в случае переноса условного выражения в тело утверждающей функции, сигнатура которой, лишена _утверждения типов_ и содержит исключительно _утверждения в сигнатуре_.\n\n`````ts\nfunction isStringAsserts(value: any): asserts value /** is string */ {\n    if (typeof value !== \"string\") {\n        throw new Error(``);\n    }\n}\n\nconst testScope = (text: any) => {\n    text.toUppercase(); // не является ошибкой, потому, что тип — any\n\n    isStringAsserts(text); // условие определено в утверждающей функции\n\n    text.toUppercase(); // нет ошибки, потому, что утверждение типов не работает\n}\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Импорт и экспорт только типа","path":"Import_i_eksport_tolko_tipa"},"nextPage":{"title":"Защитники типа","path":"Zashchitniki_tipa"}},"contentNavData":{"key":"Утверждение типов (Type Assertion)","level":0,"index":37,"contentIndex":0,"section":"Типизация","title":"Утверждение типов (Type Assertion)","path":"Utverjdenie_tipov_(Type_Assertion)","elementId":"Utverjdenie_tipov_(Type_Assertion)","children":[{"key":"Утверждение типов (Type Assertion)_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Утверждение типов - общее","path":"Utverjdenie_tipov_-_obshchee","elementId":"Utverjdenie_tipov_-_obshchee"},{"key":"Утверждение типов (Type Assertion)_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Утверждение типа с помощью <Type> синтаксиса","path":"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa","elementId":"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa"},{"key":"Утверждение типов (Type Assertion)_2","index":2,"contentIndex":3,"level":1,"section":"Типизация","title":"Утверждение типа с помощью оператора as","path":"Utverjdenie_tipa_s_pomoshchu_operatora_as","elementId":"Utverjdenie_tipa_s_pomoshchu_operatora_as"},{"key":"Утверждение типов (Type Assertion)_3","index":3,"contentIndex":4,"level":1,"section":"Типизация","title":"Приведение (утверждение) к константе (const assertion)","path":"Privedenie_(utverjdenie)_k_konstante_(const_assertion)","elementId":"Privedenie_(utverjdenie)_k_konstante_(const_assertion)"},{"key":"Утверждение типов (Type Assertion)_4","index":4,"contentIndex":5,"level":1,"section":"Типизация","title":"Утверждение в сигнатуре (Signature Assertion)","path":"Utverjdenie_v_signature_(Signature_Assertion)","elementId":"Utverjdenie_v_signature_(Signature_Assertion)"}]},"pageDescription":"Утверждение типов (Type Assertion)"},"__N_SSG":true}