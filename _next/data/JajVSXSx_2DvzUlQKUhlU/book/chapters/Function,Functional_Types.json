{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/020.(Типы) Function, Functional Types/images/"},"sectionInfoAll":[{"key":"Function, Functional Types","elementId":"Function,Functional_Types","markdown":"# Function, Functional Types\n\n_Функция_ — это ключевая концепция _JavaScript_. Функции присваиваются в качестве значений переменным и передаются как аргументы при вызове других функций. Поэтому не удивительно, что _TypeScript_ очень много внимания уделяет возможностям _функционального типа_, к которым, начиная с текущей главы, повествование периодически будет возвращаться."},{"key":"Function, Functional Types_0","elementId":"Function_Types_-_tip_funkciya","markdown":"## Function Types - тип функция\n\nВ _TypeScript_ тип `Function` представляет одноименный _JavaScript_ конструктор, являющийся базовым для всех функций. Тип `Function` можно указывать в аннотации типа тогда, когда о сигнатуре функции ничего не известно или в качестве значения могут выступать функции с несовместимыми сигнатурами.\n\n`````ts\nfunction f1(p1: number): string {\n    return p1.toString();\n}\n\nfunction f2(p1: string): number {\n    return p1.length;\n}\n\nlet v1: Function = f1;\nlet v2: Function = f2;\n`````\n\nПри этом нельзя забывать, что по канонам статически типизированных языков, архитектуру программы нужно продумывать так, что бы сводить присутствие высших в иерархии типов к нулю. В тех случаях, когда сигнатура функции известна, тип стоит конкретизировать при помощи определения более конкретных функциональных типов.\n\nПоведение типа `Function` идентично одноимённому типу из _JavaScript_."},{"key":"Function, Functional Types_1","elementId":"Functional_Types_-_funkcionalnyi_tip","markdown":"## Functional Types - функциональный тип\n\nПомимо того, что в _TypeScript_ существует объектный тип `Function`, также существует функциональный тип, с помощью которого осуществляется описание сигнатур функциональных выражений.\n\nФункциональный тип обозначается с помощью пары круглых скобок `()`, после которых располагается стрелка, а после неё обязательно указывается тип возвращаемого значения `() => type`. При наличии у функционального выражения параметров, их декларация заключается между круглых скобок `(p1: type, p2: type) => type`.\n\n`````ts\ntype FunctionalType = (p1: type, p2: type) => type;\n`````\n\nЕсли декларация сигнатуры функционального выражения известна, то рекомендуется использовать более конкретный функциональный тип, поскольку он в большей степени соответствует типизированной атмосфере.\n\n`````ts\ntype SumFunction = (a: number, b: number) => number;\n\nconst sum: SumFunction = (a: number, b: number): number => a + b;\n`````\n\nПоведение функционального типа указывающегося с помощью функционального литерала идентично поведению типа `Function`, но при этом оно более конкретно и поэтому предпочтительнее."},{"key":"Function, Functional Types_2","elementId":"this_v_signature_funkcii","markdown":"## this в сигнатуре функции\n\nНи для кого не будет секретом, что в _JavaScript_ при вызове функций можно указать их контекст. В львиной доле случаев, возможность изменять контекст вызова функции является нежелательным поведением _JavaScript_, но только не в случае реализации конструкции, называемой _функциональная примесь_ (functional mixins).\n\nФункциональная примесь — это функция, в теле которой происходит обращение к членам, объявленных в объекте, к которому она _“примешивается”_. Проблем не возникнет, если подобный механизм реализуется в динамически типизированном языке, каким является _JavaScript_.\n\n`````ts\n// .js\n\nclass Animal {\n    constructor(){\n        this.type = 'animal';\n    }\n}\n\nfunction getType() {\n    return this.type;\n}\n\nlet animal = new Animal();\nanimal[getType.name] = getType;\n\nconsole.log(animal.getType()); // animal\n`````\n\nНо в статически типизированном языке такое поведение должно быть расценено как ошибочное, поскольку у функции нет присущего объектам признака `this`. Несмотря на это в _JavaScript_, а значит и в _TypeScript_, контекст самой программы (или, по другому, глобальный объект) является объектом. Это, в свою очередь, означает, что не существует места, в котором бы ключевое слово `this` привело к возникновению ошибки (для запрещения `this` в нежелательных местах нужно активировать опцию компилятора `--noImplicitThis`). Но при этом за невозможностью предугадать поведение разработчика, в _TypeScript_ ссылка `this` вне конкретного объекта ссылается на тип `any`, что лишает ide автодополнения. Для таких и не только случаев была реализованна возможность декларировать тип `this` непосредственно в функциях.\n\n`this` указывается в качестве первого параметра любой функции и как обычный параметр имеет аннотацию типа, устанавливающую принадлежность к конкретному типу.\n\n`````ts\ninterface IT1 {p1: string;}\n\nfunction f1(this: IT1): void {}\n`````\n\nНесмотря на то, что `this` декларируется в параметрах функции, таковым оно не считается. Поведение функции с декларацией `this` аналогично поведению функции без декларации `this`. Единственное, на что стоит обратить внимание, что в случае указания принадлежности к типу отличного от `void`, не получится вызвать функцию вне указанного контекста.\n\n`````ts\ninterface IT1 { p1: string; }\n\nfunction f1(this: void): void {}\nfunction f2(this: IT1): void {}\nfunction f3(): void {}\n\nf1(); // Ok\nf2(); // Error\nf3(); // Ok\n\nlet v1 = { // v1: {f2: (this: IT1) => void;}\n    f2: f2\n};\n\nv1.f2(); // Error\n\nlet v2 = { // v2: {p1: string; f2: (this: IT1) => void;}\n    p1: '',\n    f2: f2\n};\n\nv2.f2(); // Ok\n`````\n\nКроме того, возможность ограничивать поведение ключевого слова `this` в теле функции призвано частично решить самую часто возникающую проблему, связанную с потерей контекста. Вряд ли найдется разработчик _JavaScript_, который может похвастаться, что ни разу не сталкивался с потерей контекста при передаче метода объекта в качестве функции обратного вызова (_callback_). В случаях, когда в теле метода происходит обращение через ссылку `this` к членам объекта, в котором он определен, то при потере контекста, в лучшем случае возникнет ошибка. В худшем, предполагающем, что в новом контексте будут присутствовать схожие признаки, возникнет трудно выявляемая ошибка.\n\n`````ts\nclass Point {\n    constructor(\n        public x: number = 0,\n        public y: number = 0\n    ){}\n}\n\nclass Animal {\n    private readonly position: Point = new Point();\n\n    public move({clientX, clientY}: MouseEvent): void {\n        this.position.x = clientX;\n        this.position.y = clientY;\n    }\n}\n\nlet animal = new Animal();\n\ndocument.addEventListener('mousemove', animal.move); // ошибка во время выполнения\n`````\n\nДля этих случаев _TypeScript_ предлагает ограничить ссылку на контекст с помощью конкретизации типа ссылки `this`.\n\nТак как реальный пример, иллюстрирующий полную картину, получается очень объемным, то ограничимся одним методом, реализующим обсуждаемое поведение.\n\n`````ts\ntype IContextHandler = (this: void, event: MouseEvent) => void;\n\nclass Controller {\n    public addEventListener(type: string, handler: IContextHandler): void {}\n}\n\n\nlet animal = new Animal();\nlet controller = new Controller();\n\ncontroller.addEventListener('mousemove', animal.move); // ошибка во время выполнения\n`````\n\nСтоит заметить, что одной конкретизации типа ссылки `this` в слушателе событий недостаточно. Для того, что бы пример заработал должным образом, необходимо конкретизировать ссылку `this` в самом слушателе событий.\n\n`````ts\nclass Point {\n    constructor(\n        public x: number = 0,\n        public y: number = 0\n    ){}\n}\n\nclass Animal {\n    private readonly position: Point = new Point();\n\n    public move(this: Animal, {clientX, clientY}: MouseEvent): void { // <= изменения\n        this.position.x = clientX;\n        this.position.y = clientY;\n    }\n}\n\n\ntype IContextHandler = (this: void, event: MouseEvent) => void;\n\nclass Controller {\n    public addEventListener(type: string, handler: IContextHandler): void {}\n}\n\n\nlet animal = new Animal();\nlet controller = new Controller();\n\ncontroller.addEventListener('mousemove', animal.move); // ошибка во время компиляции\ncontroller.addEventListener('mousemove', event => animal.move(event)); // Ok\n`````\n\nТакже стоит обратить внимание на одну неочевидную на первый взгляд деталь. Когда мы передаем слушатель, обернув его в стрелочную функцию либо в метод функции `.bind`, ошибки не возникает только потому, что у передаваемой функции отсутствует декларация `this`."}],"githubFileInfo":{"lastUpdate":1643269367000,"contributorAll":[{"name":"Romanov Yuri","avatar":"https://avatars.githubusercontent.com/u/31193144?v=4","bio":"","githubUrl":"https://github.com/darteil"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Object, Array, Tuple","path":"Object,Array,Tuple"},"nextPage":{"title":"Interfaces","path":"Interfaces"}},"contentNavData":{"key":"Function, Functional Types","level":0,"index":20,"contentIndex":0,"section":"Типы","title":"Function, Functional Types","path":"Function,Functional_Types","elementId":"Function,Functional_Types","children":[{"key":"Function, Functional Types_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Function Types - тип функция","path":"Function_Types_-_tip_funkciya","elementId":"Function_Types_-_tip_funkciya"},{"key":"Function, Functional Types_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Functional Types - функциональный тип","path":"Functional_Types_-_funkcionalnyi_tip","elementId":"Functional_Types_-_funkcionalnyi_tip"},{"key":"Function, Functional Types_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"this в сигнатуре функции","path":"this_v_signature_funkcii","elementId":"this_v_signature_funkcii"}]},"pageDescription":"Function, Functional Types"},"__N_SSG":true}