{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/014.(Типы) Примитивные типы Null, Undefined, Void, Never, Unknown/images/"},"sectionInfoAll":[{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown","elementId":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown","markdown":"# Примитивные типы Null, Undefined, Void, Never, Unknown\nНастало время рассмотреть следующую порцию типов некоторые из которых являются уникальными для _TypeScript_."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_0","elementId":"Vajno","markdown":"## Важно\n\nПрежде чем приступить к знакомству с такими типами, как `Null`, `Undefined`, `Void`, `Never` и `Unknown`, стоит обговорить одну очень важную деталь. Дело в том, что все перечисленные типы можно указывать в качестве типа всем конструкциям, которые это позволяют. То есть, типом данных `null` можно аннотировать даже переменную (`let identifier: null`). Данная книга будет изобиловать подобными примерами, так как эта возможность облегчает демонстрацию совместимости типов. Но при этом стоит понимать, что проделывать подобное в реальном коде противопоказано."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_1","elementId":"Null_(null)_primitivnyi_null_tip","markdown":"## Null (null) примитивный null тип\n\nПримитивный тип `Null` служит обозначением _“ничего”_. \n\nТип `Null` указывается с помощью ключевого слова `null` (не путать с единственным литеральным значением `null` типа `Null`, которое присваивается в качестве значения).\n\n`````ts\nlet identifier: null = null; // null, указанный после оператора двоеточия, это имеющийся только в TypeScript псевдоним (alias) для глобального типа Null. В, то время как null, указанный после оператора присваивания, это единственное значение типа Null.\n`````\n\nТип `null` является подтипом только одного типа `any`. Это в свою очередь означает, что значение `null` может быть совместимо только с типами `any` и `null`, а они с ним.\n\n`````ts\nlet a: any = null;// Ok\nlet b: number = null;// Error\nlet c: string = null;// Error\nlet d: boolean = null;// Error\nlet e: undefined = null;// Error\nlet f: null = null;// Ok\n`````\n\nТогда, когда тип данных указывается не явно, а в качестве значения используется значение `null`, вывод типов определяет принадлежность к типу `any`.\n\n`````ts\nlet identifier = null; // identifier: any\n`````\n\nТип `null` идентичен по своей работе с одноимённым типом из _JavaScript_."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_2","elementId":"Undefined_(undefined)_primitivnyi_neopredelennyi_tip","markdown":"## Undefined (undefined) примитивный неопределенный тип\n\nПримитивный тип `undefined` указывает на то, что значение не определено. Тип данных `undefined` указывается с помощью ключевого слова `undefined` (не путать со свойством глобального объекта `undefined`, которое представляет единственное значение типа `Undefined`).\n\n`````ts\nlet identifier: undefined = undefined; // undefined, указанный после оператора двоеточия, это имеющийся только в TypeScript псевдоним (alias) для глобального типа Undefined. В, то время как undefined, указанный после оператора присваивания, это единственное значение типа Undefined.\n`````\n\nВо время выполнения объявленные, но не инициализированные переменные, поля и свойства класса, а также параметры имеют значение `undefined`. Также значение `undefined` является результатом вызова методов или функций, которые не возвращают значения.\n\n\nТип `undefined` является подтипом всех типов, что делает его совместимым со всеми остальными типами.\n\n`````ts\nclass TypeSystem {\n    static any: any = undefined; // Ok\n    static number: number = undefined; // Ok\n    static string: string = undefined; // Ok\n    static boolean: boolean = undefined; // Ok\n    static null: null = undefined; // Ok\n    static undefined: undefined = undefined; // Ok\n}\n`````\n\nМожет возникнуть вопрос, почему тип `null`, который не имеет непосредственного отношения к типу `undefined`, совместим с ним? На данный момент этот вопрос так и остается неразгаданным.\n\nВ, то время как тип данных `undefined` совместим со всеми типами, помимо него самого, с ним совместимы лишь `null` и `any`.\n\n`````ts\nTypeSystem.undefined = TypeSystem.any; // Ok\nTypeSystem.undefined = TypeSystem.number; // Error\nTypeSystem.undefined = TypeSystem.string; // Error\nTypeSystem.undefined = TypeSystem.boolean; // Error\nTypeSystem.undefined = TypeSystem.null; // Ok\n`````\n\nТогда, когда тип данных `undefined` указывается не явно, компилятор устанавливает тип `any`.\n\n`````ts\nlet identifier = undefined; // identifier: any\n`````\n\nПри активном флаге `--strictNullChecks`, тип `undefined` является подтипом только одного типа `any`. Поэтому его и ему в качестве значения, помимо самого себя, можно присвоить только тип `any`.\n\n`````ts\nclass TypeSystem {\n    static any: any = undefined; // Ok\n    static number: number = undefined; // Error\n    static string: string = undefined; // Error\n    static boolean: boolean = undefined; // Error\n    static null: null = undefined; // Error\n    static undefined: undefined = undefined; // Ok\n}\n\nTypeSystem.undefined = TypeSystem.any; // Ok\nTypeSystem.undefined = TypeSystem.number; // Error\nTypeSystem.undefined = TypeSystem.string; // Error\nTypeSystem.undefined = TypeSystem.boolean; // Error\nTypeSystem.undefined = TypeSystem.null; // Error\n`````\n\nПри активном флаге `--strictNullChecks`, при условии, что в качестве значения выступает значение `undefined`, вывод типов определяет принадлежность к типу `undefined`.\n\n`````ts\nlet identifier = undefined; // identifier: undefined\n`````\n\nТип `undefined` идентичен по своей работе с одноимённым типом из _JavaScript_."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_3","elementId":"Void_(void)_otsutstvie_konkretnogo_tipa","markdown":"## Void (void) отсутствие конкретного типа\n\nТип данных `Void` можно назвать полной противоположностью типа `any`, так как этот тип означает отсутствие конкретного типа. Основное предназначение типа `Void` — явно указывать на то, что у функции или метода отсутствует возвращаемое значение.\n\nТип данных `Void` указывается с помощью ключевого слова `void` (не путать с одноимённым оператором из _JavaScript_) и, в отличие от таких типов, как `null` и `undefined`, не имеет никаких значений.\n\nТип `void` является подтипом `any` и супертипом для `null` и `undefined`.\n\n`````ts\nfunction action(): void {\n\n}\n\nclass TypeSystem {\n    static any: any = action(); // Ok\n    static number: number = action(); // Error\n    static string: string = action(); // Error\n    static boolean: boolean = action(); // Error\n    static null: null = action(); // Error\n    static undefined: undefined = action(); // Error\n    static void: void = action(); // Ok\n}\n\nTypeSystem.void = TypeSystem.any; // Ok\nTypeSystem.void = TypeSystem.number; // Error\nTypeSystem.void = TypeSystem.string; // Error\nTypeSystem.void = TypeSystem.boolean; // Error\nTypeSystem.void = TypeSystem.null; // Ok\nTypeSystem.void = TypeSystem.undefined; // Ok\nTypeSystem.void = TypeSystem.void; // Ok\n`````\n\nОднако с активным флагом `--strictNullChecks`, тип данных `void` совместим лишь с `any` и `undefined`.\n\n`````ts\nfunction action(): void {\n\n}\n\nclass TypeSystem {\n    static any: any = action(); // Ok\n    static number: number = action(); // Error\n    static string: string = action(); // Error\n    static boolean: boolean = action(); // Error\n    static null: null = action(); // Error\n    static undefined: undefined = action(); // Error\n    static void: void = action(); // Ok\n}\n\nTypeSystem.void = TypeSystem.any; // Ok\nTypeSystem.void = TypeSystem.number; // Error\nTypeSystem.void = TypeSystem.string; // Error\nTypeSystem.void = TypeSystem.boolean; // Error\nTypeSystem.void = TypeSystem.null; // Error\nTypeSystem.void = TypeSystem.undefined; // Ok\nTypeSystem.void = TypeSystem.void; // Ok\n`````\n\nКому-то может показаться, что примеры чересчур излишни, или, что примеры, в которых результат вызова функции не имеющей возвращаемого значения присваивается полям с различными типами, не имеет никакого отношения к реальности. Да, это так. Но целью данных примеров является научить думать как компилятор _TypeScript_.\n\nКогда функции в качестве возвращаемого типа указан тип `void`, может показаться, что возвращая различные значения с помощью оператора `return`, компилятор выбрасывает ошибки из-за понимания, что функция помечена как ничего не возвращающая. Но это не так. Ошибка возникает по причине несовместимости типов.\n\n`````ts\nfunction a(): void {\n    let result: number = 5;\n\n    return result; // Error\n}\n\nfunction b(): void {\n    let result: string = '5';\n    \n    return result; // Error\n}\n\nfunction c(): void {\n    let result: any = 5;\n    \n    return result; // Ok\n}\n`````\n\nНельзя не упомянуть, что для функций и методов, которые ничего не возвращают и у которых отсутствует аннотация типа возвращаемого значения, вывод типов определяет принадлежность к типу `void`.\n\n`````ts\nfunction action() { // function action(): void\n\n}\n`````\n\nВ отличие от `null` и `undefined`, тип `void` не имеет ни одного значения, которое могло бы явно продемонстрировать присвоение. Однако компилятор понимает, что имеет дело с типом `void` при вызове функции или метода, которые не возвращают значение. Этот становится ещё нагляднее, когда вывод типов устанавливает тип полученный при вызове функции или метода которые ничего не возвращают.\n\n`````ts\nfunction action(): void {\n\n}\n\nlet identifier = action(); // identifier: void\n`````\n\nТип `void` является уникальным для _TypeScript_. В _JavaScript_ подобного типа не существует."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_4","elementId":"Never_(never)_primitivnyi_tip","markdown":"## Never (never) примитивный тип\n\nПримитивный типа данных `Never` служит для указания того, что какие-либо операции никогда не будут выполнены.\n\n`Never` обозначается ключевым словом `never` и так же как и `void` не имеет явных значений.\n\nТип данных `never` является подтипом всех типов, что делает его совместим со всеми остальными типами.\n\n`````ts\nfunction action(): never {\n    throw new Error();\n};\n\nclass TypeSystem {\n    static any: any = action(); // Ok\n    static number: number = action(); // Ok\n    static string: string = action(); // Ok\n    static boolean: boolean = action(); // Ok\n    static null: null = action(); // Ok\n    static undefined: undefined = action(); // Ok\n    static void: void = action(); // Ok\n    static never: never = action(); // Ok\n}\n\nTypeSystem.never = TypeSystem.any; // Error\nTypeSystem.never = TypeSystem.number; // Error\nTypeSystem.never = TypeSystem.string; // Error\nTypeSystem.never = TypeSystem.boolean; // Error\nTypeSystem.never = TypeSystem.null; // Error\nTypeSystem.never = TypeSystem.undefined; // Error\nTypeSystem.never = TypeSystem.void; // Error\nTypeSystem.never = TypeSystem.never; // Ok\n`````\n\nТак как типу `never` нельзя присвоить значение отличное от самого типа `never`, единственным местом, в котором его может использовать разработчик является аннотация возвращаемого из функции или метода значения, с одной оговоркой. Тип `never` можно указать только той функции, из которой программа действительно никогда не сможет выйти. \n\nТакой сценарий может выражаться в виде функции вызов которой приведет к однозначному исключению или тело функции будет включать бесконечный цикл.\n\n`````ts\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\nfunction loop(): never {\n    while(true) {\n        \n    }\n}\n`````\n\nВывод типов определит принадлежность возвращаемого функцией значения к типу `never` только если он указан в аннотации возвращаемого типа явно.\n\n`````ts\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\nfunction action() { // function action(): never\n    return error('All very, very bad.');\n}\n\nlet identifier = error(); // let identifier: never\nlet identifier = action(); // let identifier: never\n`````\n\nСтоит заметить, что без явного указания типа `never` для декларации функции (_function declaration_) вывод типов определит принадлежность возвращаемого значения к типу `void`.\n\n`````ts\nfunction error(message: string) { // function error(): void \n    throw new Error(message);\n}\n\nfunction loop() { // function loop(): void\n    while(true) {\n        \n    }\n}\n`````\n\nТем не менее для функционального выражения (_function expression_) будет выведен тип `never`.\n\n`````ts\nconst error = function error(message: string) { // const error: (message: string) => never\n  throw new Error(message);\n}\n\nconst loop = function loop() { // const loop: () => never\n  while(true) {\n\n  }\n}\n`````\n\nТип `never` является уникальным для _TypeScript_. В _JavaScript_ подобного типа не существует."},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_5","elementId":"Unknown_(unknown)","markdown":"## Unknown (unknown)\n\n\nТип `Unknown` является типобезопасным аналогом типа `any` и представлен в виде литерала `unknown`. Все типы совместимы с типом `unknown`, в, то время как сам тип `unknown` совместим только с самим собой и типом `any`.\n\n`````ts\nclass TypeSystem {\n    static unknown: unknown;\n    \n    static any: any = TypeSystem.unknown; // Ok\n    static number: number = TypeSystem.unknown; // Error\n    static string: string = TypeSystem.unknown; // Error\n    static boolean: boolean = TypeSystem.unknown; // Error\n    static null: null = TypeSystem.unknown; // Error\n    static undefined: undefined = TypeSystem.unknown; // Error\n    static void: void = TypeSystem.unknown; // Error\n    static never: never = TypeSystem.unknown; // Error\n}\n\nTypeSystem.unknown = TypeSystem.any; // Ok\nTypeSystem.unknown = TypeSystem.number; // Ok\nTypeSystem.unknown = TypeSystem.string; // Ok\nTypeSystem.unknown = TypeSystem.boolean; // Ok\nTypeSystem.unknown = TypeSystem.null; // Ok\nTypeSystem.unknown = TypeSystem.undefined; // Ok\nTypeSystem.unknown = TypeSystem.void; // Ok\nTypeSystem.unknown = TypeSystem.unknown; // Ok\n`````\n\nКроме того, над типом `unknown` запрещено выполнение каких-либо операций.\n\n`````ts\nlet v0: any;\nv0.a = 5; // Ok\nv0.a = ''; // Ok\nv0(); // Ok\n\n\nlet v1: unknown = v0; // Ok\nv1.a = 5; // Error\nv1.a = ''; // Error\nv1(); // Error\n`````\n\nЕсли тип `unknown` составляет тип пересечение (`intersection`), то он будет перекрыт всеми типами.\n\n`````ts\ntype T0 = any & unknown; // type T0 = any\ntype T1 = number & unknown; // type T1 = number\ntype T2 = string & unknown; // type T2 = string\ntype T3 = boolean & unknown; // type T3 = boolean\ntype T4 = null & unknown; // type T4 = null\ntype T5 = undefined & unknown; // type T5 = undefined\ntype T6 = void & unknown; // type T6 = void\ntype T7 = never & unknown; // type T7 = never\ntype T8<T> = T & unknown; // type T8 = T\ntype T9 = unknown & unknown; // type T9 = unknown\n`````\n\nЕсли тип `unknown` составляет тип объединение (`union`), то он перекроет все типы, за исключением типа `any`.\n\n`````ts\ntype T0 = any | unknown; // type T0 = any\ntype T1 = number | unknown; // type T1 = unknown\ntype T2 = string | unknown; // type T2 = unknown\ntype T3 = boolean | unknown; // type T3 = unknown\ntype T4 = null | unknown; // type T4 = unknown\ntype T5 = undefined | unknown; // type T5 = unknown\ntype T6 = void | unknown; // type T6 = unknown\ntype T7 = never | unknown; // type T7 = unknown\ntype T8<T> = T | unknown; // type T8 = unknown\ntype T9 = unknown | unknown; // type T9 = unknown\n`````\n\nПомимо этого, запрос ключей (`keyof`) для типа `unknown` возвращает тип `never`.\n\n`````ts\ntype T0 = keyof number; // type T0 = \"toString\" | \"toFixed\" | \"toExponential\" | \"toPrecision\" | \"valueOf\" | \"toLocaleString\"\ntype T1 = keyof any; // type T1 = string | number | symbol\ntype T2 = keyof unknown; // type T2 = never\n`````\n\nТип `unknown` позволяется использовать только в операциях равенства `===`, `==`, `!==` и `!=` и в операциях с логическими операторами `&&`, `||` и `!`.\n\n`````ts\nlet v0: unknown = 5;\n\nlet v1 = 5 === v0; // Ok\nlet v2 = 5 !== v0; // Ok\nlet v3 = 5 > v0; // Error\nlet v4 = 5 < v0; // Error\nlet v5 = 5 >= v0; // Error\nlet v6 = 5 <= v0; // Error\nlet v7 = 5 - v0; // Error\nlet v8 = 5 * v0; // Error\nlet v9 = 5 / v0; // Error\nlet v10 = ++v0; // Error\nlet v11 = --v0; // Error\nlet v12 = v0++; // Error\nlet v13 = v0--; // Error\n\nlet v14 = 5 && v0; // Ok, let v14: unknown\nlet v15 = 5 || v0; // Ok, let v15: number\nlet v16 = v0 || 5; // Ok, let v16: unknown\nlet v17 = !v0; // Ok, let v17: boolean\n`````\n\nТакже стоит упомянуть, что функция у которой возвращаемый тип принадлежит к типу `unknown`, может не возвращать значение явно.\n\n`````ts\nfunction f0(): unknown {\n    return; // Ok\n}\n\nfunction f1(): number {\n    return; // Error\n}\n\nlet v = f0(); // Ok, let v: unknown\n`````\n\nПри активной опции `--strictPropertyInitialization` принадлежащие к типу `unknown` поля не нуждаются в инициализации.\n\n`````ts\nclass T {\n    f0: unknown; // Ok\n    f1: number; // Error\n    f2: number = 5; // Ok\n}\n`````\n\nЕсли в определении типа данных участвует сопоставленный тип (`Mapped Type`) которому в качестве аргумента типа передается тип `unknown`, то такой сопоставленный тип будет выведен как объектный тип `{}`. Поскольку сопоставленные типы (`Mapped Types`), псевдонимы типов (`types`), а также обобщения (`Generics<>`) будут рассмотрены позднее, то стоит просто помнить об этом факте и повторно прочесть написанное при необходимости.\n\n`````ts\ntype MappedType<T> = {\n    [K in keyof T]: T;\n}\n\ntype T0 =  MappedType<number>; // type T0 = number\ntype T1 =  MappedType<any>; // type T1 = { [x: string]: any; }\ntype T2 =  MappedType<unknown>; // type T2 = {}\n`````"}],"githubFileInfo":{"lastUpdate":1635230453000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"Primitivnye_tipy_Number,String,Boolean,Symbol,BigInt"},"nextPage":{"title":"Примитивный Тип Enum","path":"Primitivnyi_Tip_Enum"}},"contentNavData":{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown","level":0,"index":14,"contentIndex":0,"section":"Типы","title":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown","elementId":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown","children":[{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Важно","path":"Vajno","elementId":"Vajno"},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Null (null) примитивный null тип","path":"Null_(null)_primitivnyi_null_tip","elementId":"Null_(null)_primitivnyi_null_tip"},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Undefined (undefined) примитивный неопределенный тип","path":"Undefined_(undefined)_primitivnyi_neopredelennyi_tip","elementId":"Undefined_(undefined)_primitivnyi_neopredelennyi_tip"},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_3","index":3,"contentIndex":4,"level":1,"section":"Типы","title":"Void (void) отсутствие конкретного типа","path":"Void_(void)_otsutstvie_konkretnogo_tipa","elementId":"Void_(void)_otsutstvie_konkretnogo_tipa"},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_4","index":4,"contentIndex":5,"level":1,"section":"Типы","title":"Never (never) примитивный тип","path":"Never_(never)_primitivnyi_tip","elementId":"Never_(never)_primitivnyi_tip"},{"key":"Примитивные типы Null, Undefined, Void, Never, Unknown_5","index":5,"contentIndex":6,"level":1,"section":"Типы","title":"Unknown (unknown)","path":"Unknown_(unknown)","elementId":"Unknown_(unknown)"}]},"pageDescription":"Примитивные типы Null, Undefined, Void, Never, Unknown"},"__N_SSG":true}