{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/023.(Классы) Модификаторы доступа (Access Modifiers)/images/"},"sectionInfoAll":[{"key":"Модификаторы доступа (Access Modifiers)","elementId":"Modifikatory_dostupa_(Access_Modifiers)","markdown":"# Модификаторы доступа (Access Modifiers)\n\nПоскольку сокрытие является одним из основных принципов структурного и объектно-ориентированного проектирования, при создании программ принято скрывать как можно больше информации об объектах. Это необходимо не только для предотвращения случайного изменения, но и для повышения слабого зацепления (_low coupling_). Для этих целей _TypeScript_ реализует механизм, называемый _модификаторы доступа_.\n \n_Модификаторы доступа_ — это ключевые слова, с помощью которых осуществляется управление сокрытием данных в классе. Простыми словами, модификаторы доступа задают уровень доступности членам класса ограничивая область их видимости.\n\nВ _TypeScript_ существует три модификатора доступа, указывающихся с помощью ключевых слов `public`, `protected` и `private`. Влияние модификаторов доступа ограничивается _TypeScript_ и после компиляции от них не остается ни следа. В скомпилированном коде нет никакой разницы между членами, к которым были применены те или иные модификаторы доступа.\n\nС помощью модификаторов доступа можно указать уровень доступа для полей, аксессоров и методов, в том числе статических. Кроме того, в _TypeScript_ при помощи модификаторов доступа можно ограничивать доступ к конструктору класса.\n\n`````ts\nclass Animal {\n    private static DEFAULT_NICKNAME: string = 'animal';\n\n    protected static inputInfoDecor(text: string): string {\n        return `[object ${text}]`;\n    }\n    \n    private _nickname: string = Animal.DEFAULT_NICKNAME;\n    \n    public get nickname(): string {\n        return this._nickname;\n    }\n\n    public set nickname(value: string){\n        this._nickname = value;\n    }\n    \n    public constructor() {}\n    \n    public toString(): string {\n        return Animal.inputInfoDecor('Animal');\n    }\n}\n`````"},{"key":"Модификаторы доступа (Access Modifiers)_0","elementId":"Modifikator_dostupa_public_(publichnyi)","markdown":"## Модификатор доступа public (публичный)\n\nЧлены, помеченные ключевым словом `public`, доступны в определяющих их классах, их потомках, а также к ним можно обращаться через экземпляр или, в случае статических членов, через ссылку на класс.\n\nЕсли при разработке приложения особое внимание уделяется архитектуре, то, как правило, модификатором доступа `public` помечаются только члены описанные в интерфейсе (глава [“Типы - Interface”](../021.(Типы)%20Interfaces)).\n\n`````ts\nclass Animal {\n    public nickname: string;\n    \n    constructor() {\n        this.nickname = 'animal';\n    }\n}\n\nclass Bird extends Animal {\n  constructor() {\n      super();\n      super.nickname = 'bird';\n  }\n}\n\nlet animal: Animal = new Animal();\nanimal.nickname = 'newAnimal';\n\nlet bird: Bird = new Bird();\nbird.nickname = 'newBird';\n`````\n\nЧлены, у которых отсутствует указание какого-либо модификатора доступа, воспринимаются компилятором как `public`:\n\n`````ts\nclass Animal {\n nickname: string; // эквивалентно public nickname: string\n}\n`````"},{"key":"Модификаторы доступа (Access Modifiers)_1","elementId":"Modifikator_dostupa_private_(zakrytyi_ili_skrytyi)","markdown":"## Модификатор доступа private (закрытый или скрытый)\n\nМодификатор доступа `private` является полной противоположностью модификатору доступа `public`. Члены, помеченные с помощью ключевого слова `private`, доступны только контексту класса, в котором они определены.\n\nЧем меньше окружающему миру известно о внутреннем устройстве классов, тем меньше оно взаимодействует с ним. Взаимодействия программы с объектом называют _сопряжением_ (coupling), уровень которого варьируется от сильного до слабого. _Слабое сопряжение_ (_loose coupling_) является признаком качественной архитектуры программы. Этот факт подталкивает скрывать как можно больше информации при проектировании программы. В языках программирования, в которых существуют модификаторы доступа, скрывать различные конструкции принято с помощью модификатора `private`.\n\n`````ts\nclass Animal {\n    private metainfo: string;\n    \n    constructor() {\n        this.metainfo = '...';\n    }\n}\n\nclass Bird extends Animal {\n    constructor() {\n        super();\n        super.metainfo = 'bird'; // Error\n    }\n}\n\nlet animal: Animal = new Animal();\nanimal.metainfo = 'newAnimal'; // Error\n\nlet bird: Bird = new Bird();\nbird.metainfo = 'newBird'; // Error\n`````"},{"key":"Модификаторы доступа (Access Modifiers)_2","elementId":"Modifikator_dostupa_protected_(zashchishchennyi)","markdown":"## Модификатор доступа protected (защищенный)\n\nЧлены, которым установлен модификатор доступа `protected`, доступны только контексту класса, в котором они определенны, а также всем его потомкам. Попытка обратится к членам, помеченным как `protected` снаружи, приведет к возникновению ошибки.\n\nКак правило, при современной разработке упор делается только на два вида модификаторов доступа - `public` и `private`. Но, в редких случаях, по сценарию может возникнуть необходимость обращаться к членам своего суперкласса в подклассах, которые при этом, должны быть скрыты от окружающего мира. В таких случаях члены помечают как `protected`.\n\n`````ts\nclass Animal {\n    protected isUpdate: boolean;\n    \n    constructor() {\n        this.isUpdate = false;\n    }\n}\n\nclass Bird extends Animal {\n    constructor() {\n        super();\n        super.isUpdate = false;\n    }\n}\n\nlet animal: Animal = new Animal();\nanimal.isUpdate = true; // Error\n\nlet bird: Bird = new Bird();\nbird.isUpdate = true; // Error\n`````"},{"key":"Модификаторы доступа (Access Modifiers)_3","elementId":"Modifikatory_dostupa_i_konstruktory_klassa","markdown":"## Модификаторы доступа и конструкторы класса\n\nВ _TypeScript_ существует возможность управлять доступом конструкторов. Конструктор, который не отмечен ни одним модификатором доступа эквивалентен конструктору, помеченному как `public`.\n\n`````ts\nclass A {\n    public constructor() {} // модификатор public установлен явно\n}\n\nclass B {\n    constructor() {} // модификатор public установлен не явно\n}\n`````\n\nЕсли класс состоит только из статических свойств и методов, как например класс `Math`, то его конструктор более разумно пометить как приватный и, тем самым, запретить создание его экземпляров.\n\n`````ts\nclass AnimalUtil {\n    private static MS_TO_DAY: number = 1000 * 60 * 60 * 24;\n    \n    public static ageFromMsToDayFormat(time: number): number { \n        return Math.ceil(time / AnimalUtil.MS_TO_DAY);\n    }\n    \n    private constructor() {};\n}\n\nclass Animal {\n    private _timeOfBirth: number = Date.now();\n    \n    public get age(): number {\n        return this._timeOfBirth - Date.now();\n    }\n    \n    public constructor() {}\n}\n\nlet animal: Animal = new Animal();\nlet age: number = AnimalUtil.ageFromMsToDayFormat(animal.age);\n\nlet util = new AnimalUtil(); // Ошибка при компиляции, нельзя создать экземпляр\n`````\n\nКроме того, класс, у которого конструктор объявлен с модификатором доступа `private`, нельзя расширять (`extends`).\n\n`````ts\nclass AnimalUtil {\n    // ...\n    \n    private constructor() {};\n}\n\nclass AnimalStringUtil extends AnimalUtil {} // Ошибка\n`````\n\nКласс, в котором конструктор объявлен с модификатором доступа `protected`, как и в случае с модификатором доступа `private`, также не позволит создать свой экземпляр, но открыт для расширения (`extends`).\n\n`````ts\nclass Animal {\n    protected constructor() {}\n}\n\n// можно наследоваться от класса с защищенным конструктором\nclass Bird extends Animal {\n    constructor() {\n        super();\n    }\n}\n\nlet animal: Animal = new Animal(); // Error\nlet bird: Bird = new Bird(); // Ok\n`````\n\nТем не менее есть один нюанс. Не получится создать экземпляр подкласса, если он не переопределил конструктор суперкласса.\n\n`````ts\nclass Animal {\n    protected constructor() {}\n}\n\n// потомок переопределяет конструктор предка\nclass Bird extends Animal {\n    constructor() {\n        super();\n    }\n}\n\n// потомок не переопределяет конструктор предка\nclass Fish extends Animal {}\n\nlet bird: Bird = new Bird(); // Ok\nlet fish: Fish = new Fish(); // Error\n`````"},{"key":"Модификаторы доступа (Access Modifiers)_4","elementId":"Bystroe_obyavlenie_polei","markdown":"## Быстрое объявление полей\n\nВ разработке очень часто используются классы, состоящие только из открытых полей, ассоциированных со значением, переданным в качестве аргументов конструктора.\n\nПомимо обычного способа объявления полей в теле класса с последующей инициализацией в конструкторе, существует сокращенный вариант с объявлением непосредственно в конструкторе за счет добавления его параметрам модификаторов.\n\nОбычный способ:\n\n`````ts\nclass BirdEntity {\n    public name: string;\n    public age: number;\n    public isAlive: boolean;\n\n    constructor(name: string, age: number, isAlive: boolean){\n        this.name = name;\n        this.age = age;\n        this.isAlive = isAlive;\n    }\n}\n`````\n\nСокращенный способ инициализации полей класса:\n\n`````ts\nclass FishEntity { \n    constructor(\n        public name: string,\n        public age: number,\n        public isAlive: boolean\n    ) {}\n}\n`````\n\nВ сокращенном варианте поля не указываются в теле класса, а указываются непосредственно в конструкторе. При этом обязательным условием является указание одного из существующих модификаторов доступа (либо модификатора `readonly`, о котором речь пойдет в главе [“Классы - Модификатор readonly”](../027.(Классы)%20Модификатор%20readonly%20(только%20для%20чтения))), после чего параметры начинают расцениваться компилятором в качестве полей класса.\n\n`````ts\nclass FishEntity {\n    constructor(\n        public name: string, // поле\n        public age: number, // поле\n        isAlive: boolean // параметр\n    ) {}\n}\n`````\n\nПри этом не существует строго заданного порядка, в котором должны объявляться параметры и сокращенное объявление полей.\n\n`````ts\nclass FishEntity {\n    constructor(\n        name: string, // параметр\n        public age: number, // поле\n        isAlive: boolean // параметр\n    ) {}\n}\n`````\n\nПолям, объявленным в конструкторе так же, как и полям, объявленным в теле класса, можно устанавливать различные модификаторы доступа.\n\n`````ts\nclass FishEntity {\n    constructor(\n        public name: string,\n        protected age: number,\n        private isAlive: boolean\n    ) {}\n}\n`````\n\nОбращение к полям, объявленным прямо в конструкторе, ничем не отличается от обращения к полям, объявленным в теле класса.\n\n`````ts\nclass Animal {\n    constructor(\n        public name: string,\n        protected age: number,\n        private isAlive: boolean\n    ) {}\n\n    public dead(): void {\n        this.isAlive = false;\n    }\n}\n\nclass Bird extends Animal {\n    public toString(): string {\n        return `[bird ${super.name}]`;\n    }\n}\n`````"}],"githubFileInfo":{"lastUpdate":1616400513000,"contributorAll":[{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)"},"nextPage":{"title":"Закрытые поля определенные спецификацией ECMAScript","path":"Zakrytye_polya_opredelennye_specifikaciei_ECMAScript"}},"contentNavData":{"key":"Модификаторы доступа (Access Modifiers)","level":0,"index":23,"contentIndex":0,"section":"Классы","title":"Модификаторы доступа (Access Modifiers)","path":"Modifikatory_dostupa_(Access_Modifiers)","elementId":"Modifikatory_dostupa_(Access_Modifiers)","children":[{"key":"Модификаторы доступа (Access Modifiers)_0","index":0,"contentIndex":1,"level":1,"section":"Классы","title":"Модификатор доступа public (публичный)","path":"Modifikator_dostupa_public_(publichnyi)","elementId":"Modifikator_dostupa_public_(publichnyi)"},{"key":"Модификаторы доступа (Access Modifiers)_1","index":1,"contentIndex":2,"level":1,"section":"Классы","title":"Модификатор доступа private (закрытый или скрытый)","path":"Modifikator_dostupa_private_(zakrytyi_ili_skrytyi)","elementId":"Modifikator_dostupa_private_(zakrytyi_ili_skrytyi)"},{"key":"Модификаторы доступа (Access Modifiers)_2","index":2,"contentIndex":3,"level":1,"section":"Классы","title":"Модификатор доступа protected (защищенный)","path":"Modifikator_dostupa_protected_(zashchishchennyi)","elementId":"Modifikator_dostupa_protected_(zashchishchennyi)"},{"key":"Модификаторы доступа (Access Modifiers)_3","index":3,"contentIndex":4,"level":1,"section":"Классы","title":"Модификаторы доступа и конструкторы класса","path":"Modifikatory_dostupa_i_konstruktory_klassa","elementId":"Modifikatory_dostupa_i_konstruktory_klassa"},{"key":"Модификаторы доступа (Access Modifiers)_4","index":4,"contentIndex":5,"level":1,"section":"Классы","title":"Быстрое объявление полей","path":"Bystroe_obyavlenie_polei","elementId":"Bystroe_obyavlenie_polei"}]},"pageDescription":"Модификаторы доступа (Access Modifiers)"},"__N_SSG":true}