{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/022.(Типы) Объектные типы с индексными членами (объектный тип с динамическими ключами)/images/"},"sectionInfoAll":[{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","elementId":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)","markdown":"# Объектные типы с индексными членами (объектный тип с динамическими ключами)\n\nВпервые реализуя динамические ключи в статически типизированном _TypeScript_, могут возникнуть трудности, которые вместе с сопряженными тонкостями, будут подробно рассмотрены в этой главе."},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_0","elementId":"Indeksnye_chleny_(opredelenie_dinamicheskih_kluchei)","markdown":"## Индексные члены (определение динамических ключей)\n\nСтатический анализ кода всеми силами стремится взять под контроль синтаксические конструкции, тем самым переложить работу, связанную с выявлением ошибок, на себя, оставляя разработчику больше времени на более важные задачи. И несмотря на то, что динамические операции являются причиной “головной боли” компилятора, потребность в них при разработке программ все-таки существует. Одной из таких операций является определение в объектах _индексных членов_ (динамических ключей).\n\n_Индексная сигнатура_ (_index signature_) состоит из двух частей. В первой части расположен имеющий собственную аннотацию типа _идентификатор привязки_ (_binding identifier_) заключенный в квадратные скобки `[]`. Во второй части расположена _аннотация типа_ (_type annotation_) представляющего значение ассоциируемое с динамическим ключом.\n\n`````ts\n{ [identifier: Type]: Type }\n`````\n\nИдентификатору привязки можно дать любое имя, которое должно быть ассоциировано только с типами `string`, `number`, `symbol` или `literal template string` , а в качестве типа указанного справа от двоеточия, может быть указан любой тип.\n\n`````ts\n// именование ключа - идентификатор ключа может быть любым\ninterface Identifier {\n    [identifier: string]: string; // идентификатор - identifier\n}\n// или\ninterface Identifier {\n    [someKey: string]: string; // идентификатор - someKey\n}\n\n// допустимые типы - string, number, symbol или litelral template string\ninterface Identifier {\n    [key: string]: string; // будет соответствовать o[`key`]\n}\ninterface Identifier {\n    [key: number]: string; // будет соответствовать o[5]\n}\ninterface Identifier {\n    [key: symbol]: string; // будет соответствовать o[Symbol(`key`)]\n}\ninterface Identifier {\n    [key: `data-${string}`]: string; // будет соответствовать o[`data-*`]\n}\n`````\n\nВ одном объектном типе одновременно могут быть объявлены индексные сигнатуры, чьи идентификаторы привязки принадлежат к типу `string`, `number`, `symbol` или `literal template string`. Но с одной оговоркой. Их типы, указанные в аннотации типов, должны быть совместимы (совместимость типов подробно рассматривается в главах [“Типизация - Совместимость объектов”](../038.(Типизация)%20Совместимость%20объектных%20типов%20(Compatible%20Object%20Types)) и [“Типизация - Совместимость функций”](../039.(Типизация)%20Совместимость%20функциональных%20типов%20(Compatible%20Function%20Types))).\n\n`````ts\ninterface A {\n    [key: string]: string;\n    [key: number]: string;\n    [key: symbol]: string;\n    [key: `data-${string}`]: string;\n}\n\nlet a: A = {\n    validKeyDeclareStatic: 'value', // Ok, значение принадлежит к string\n    invalidKeyDeclareStatic: 0 // Error, значение должно быть совместимым с типом string\n};\n\na.validKeyDefineDynamicKey = 'value'; // Ok\na.invalidKeyDefineDynamicKey = 0; // Error, значение должно быть совместимым с типом string\na[0] = 'value'; // Ok\n\ninterface B {\n    [identifier: string]: string; // Ok\n    [identifier: string]: string; // Error, дубликат\n}\n\ninterface С {\n    [identifier: string]: string; // Ok\n    [identifier: number]: number; // Error, должен принадлежать к типу string\n}\n\nclass SuperClass { // суперкласс\n    a: number;\n}\n\nclass SubClass extends SuperClass { // подкласс\n    b: number;\n}\n\ninterface D {\n    [identifier: string]: SuperClass; // Ok\n    [identifier: number]: SubClass; // Ok, SubClass совместим с SuperClass\n}\n\nlet d: D = {};\nd.dynamicKey = new SubClass(); // Ok\nd[0] = new SubClass(); // Ok\n\ninterface E {\n    [identifier: string]: SubClass; // Ok\n    [identifier: number]: SuperClass; // Error, SuperClass несовместим с SubClass\n}\n`````\n\nМножественное определение типов, к которым могут принадлежать ключи индексной сигнатуры, можно записать также с помощью типа объединение.\n\n`````ts\ninterface A {\n    [key: string | number | symbol | `data-${string}`]: string; // это тоже самое, что и...\n}\ninterface A { // ...это\n    [key: string]: string;\n    [key: number]: string;\n    [key: symbol]: string;\n    [key: `data-${string}`]: string;\n}\n`````\n\nТак как классы принадлежат к объектным типам, их тела также могут определять индексные сигнатуры, в том числе и уровня самого класса, то есть - статические индексные сигнатуры (`static`). Правила, относящиеся к индексным сигнатурам, которые были и будут рассмотрены в этой главе, в полной мере справедливы и для классов.\n\n`````ts\nclass Identifier {\n  static [key: string]: string; // статическая индексная сигнатура\n\n\n  [key: string]: string;\n  [key: number]: string;\n\n  [0]: 'value';\n  [1]: 5; // Error, все члены должны принадлежать к совместимым со string типам\n\n  public a: string = 'value'; // Ok, поле name с типом string\n  public b: number = 0; // Error, все члены должны принадлежать к совместимым со string типам\n\n  public c(): void {} // Error, метод тоже член и на него распространяются те же правила\n}\n\nlet identifier: Identifier = new Identifier();\n\n/**индексная сигнатура экземпляра класса */\nidentifier.validDynamicKey = 'value'; // Ok\nidentifier.invalidDynamicKey = 0; // Error\n\nidentifier[2] = 'value'; // Ok\nidentifier[3] = 0; // Error\n\n/**индексная сигнатура класса */\nIdentifier.validDynamicKey = 'value'; // Ok\nIdentifier.invalidDynamicKey = 0; // Error\n\nIdentifier[2] = 'value'; // Ok\nIdentifier[3] = 0; // Error\n`````\n\nКроме того, классы накладывают ограничение не позволяющее использовать модификаторы доступа (`private`, `protected`, `public`). При попытке указать данные модификаторы для индексной сигнатуры возникнет ошибка.\n\n`````ts\nclass A {\n    public [key: string]: string; // Error\n}\n\n`````\n\nНо, относительно модификаторов, есть несколько нюансов, связанных с модификатором `readonly`, который подробно рассматривается в главе [“Классы - Модификатор readonly”](../027.(Классы)%20Модификатор%20readonly%20(только%20для%20чтения)). Чтобы ничего не ускользнуло от понимания, начнем по порядку.\n\nПри указании модификатора `readonly` искажается смысл использования индексной сигнатуры, так как это дает ровно противоположный эффект. Вместо объекта с возможностью определения динамических членов получается объект, позволяющий лишь объявлять динамические ключи, которым нельзя ничего присвоить. То есть, объект полностью закрыт для изменения.\n\nВ случае с интерфейсом:\n\n`````ts\ninterface IIdentifier {\n    readonly [key: string]: string; // Ok, модификатор readonly\n}\n\nlet instanceObject: IIdentifier = {};\n\ninstanceObject.a; // Ok, можно объявить\ninstanceObject.a = 'value'; // Error, но нельзя присвоить значение\n`````\n\nВ случае с классом:\n\n`````ts\nclass Identifier {\n    readonly [key: string]: string;\n}\n\nlet instanceClass = new Identifier();\ninstanceClass.a; // Ok, можно объявить\ninstanceClass.a = 'value'; // Error, но нельзя присвоить значение\n`````\n\nВторой нюанс заключается в том, что если в объекте или классе определена индексная сигнатура, становится невозможным объявить в их теле или добавить через точечную и скобочную нотацию ключи, ассоциированные с несовместимым типом данных. Простыми словами — тело объекта или класса, имеющего определение индексной сигнатуры, не может иметь определения членов других типов.\n\nВ случае с интерфейсом:\n\n`````ts\ninterface IIdentifier {\n    [key: string]: string;\n\n    a: string; // Ok, [в момент декларации]\n    b: number; // Error, [в момент декларации] допускается объявление идентификаторов принадлежащих только к типу string\n}\n\nlet instanceObject: IIdentifier = {\n    c: '', // Ok, [в момент объявления]\n    d: 0   // Error, [в момент объявления] допускается объявление идентификаторов принадлежащих только типу string\n};\n\ninstanceObject.e = ''; // Ok, [после объявления]\ninstanceObject.f = 0;  // Error, [после объявления] допускается объявление идентификаторов принадлежащих только типу string\n`````\n\nВ случае с классом:\n\n`````ts\nclass Identifier {\n    [key: string]: string;\n\n    a: string; // Ok, [в момент объявления]\n    b: number; // Error, [в момент объявления] допускается объявление идентификаторов принадлежащих только типу string\n}\n\nlet instanceClass = new Identifier();\ninstanceClass.c = ''; // Ok, [после объявления]\ninstanceClass.d = 0;  // Error, [после объявления] допускается объявление идентификаторов принадлежащих только типу string\n`````\n\nНо, в случае с модификатором `readonly`, поведение отличается. Несмотря на то, что указывать идентификаторы членов, принадлежащие к несовместимым типам, по-прежнему нельзя, допускается их декларация и объявление.\n\nВ случае с интерфейсом:\n`````ts\ninterface IIdentifier {\n    readonly [key: string]: string; // Ok\n\n    a: string; // Ok, декларация\n}\n\nlet instanceObject: IIdentifier = {\n    a: '', // Ok, объявление\n    b: ''  // Ok, объявление\n};\n\ninstanceObject.с = 'value'; // Error, ассоциировать ключ со значением после создания объекта по-прежнему нельзя\n`````\n\nВ случае с классом:\n\n`````ts\nclass Identifier {\n    readonly [key: string]: string;\n\n    a: string = 'value'; // Ok, декларация и объявление\n}\n\nlet instanceClass = new Identifier();\ninstanceClass.b = 'value'; // Error, ассоциировать ключ со значением после создания объекта по-прежнему нельзя\n`````\n\nК тому же объекты и классы имеющие определение индексной сигнатуры не могут содержать определения методов.\n\n`````ts\ninterface IIdentifier {\n    readonly [key: string]: string;\n\n    method(): void; // Error -> TS2411: Property 'method' of type '() => void' is not assignable to string index type 'string'\n}\n\nclass Identifier {\n    readonly [key: string]: string;\n\n    method(): void {} // Error -> TS2411: Property 'method' of type '() => void' is not assignable to string index type 'string'.\n}\n`````\n\nТретий нюанс проистекает от предыдущего и заключается в том, что значения, ассоциированные с идентификаторами, которые были задекларированы в типе, можно перезаписать после инициализации объекта.\n\nВ случае с интерфейсом:\n\n`````ts\ninterface IIdentifier {\n    readonly [key: string]: string; // Ok\n\n    a: string; // Ok, декларация\n}\n\nlet instanceObject: IIdentifier = {\n    a: 'value', // Ok, реализация\n    b: 'value'  // Ok, объявление\n};\n\ninstanceObject.a = 'new value'; // Ok, можно перезаписать значение\ninstanceObject.b = 'new value'; // Error, нельзя перезаписать значение\n`````\n\nВ случае с классом:\n\n`````ts\nclass Identifier {\n    readonly [key: string]: string;\n\n    a: string = 'value'; // Ok, декларация и объявление\n}\n\nlet instanceClass = new Identifier();\ninstanceClass.a = 'new value'; // Ok, можно перезаписать значение\n`````\n\nЕсли учесть, что модификатор `readonly` вообще не стоит применять к индексной сигнатуре, то все эти нюансы вообще можно выкинуть из головы. Но, так как цель этой книги защитить читателя от как можно большего количества подводных камней, я решил не опускать данный факт, ведь знание — лучшая защита.\n\nКроме того, не будет лишним знать наперед, что если идентификатор привязки принадлежит к типу `string`, то в качестве ключа может быть использовано значение, принадлежащее к типам `string`, `number`, `symbol`, `Number Enum` и `String Enum`.\n\n`````ts\ninterface StringDynamicKey {\n    [key: string]: string;\n}\n\nenum NumberEnum {\n    Prop = 0\n}\n\nenum StringEnum {\n    Prop = 'prop'\n}\n\nlet example: StringDynamicKey = {\n    property: '',            // Ok String key\n    '': '',                  // Ok String key\n    1: '',                   // Ok Number key\n    [Symbol.for('key')]: '', // Ok Symbol key\n    [NumberEnum.Prop]: '',   // Ok Number Enum key\n    [StringEnum.Prop]: '',   // Ok String Enum key\n};\n`````\n\nВ случае, когда идентификатор привязки принадлежит к типу `number`, то значение, используемое в качестве ключа, может принадлежать к таким типам, как `number`, `symbol`, `Number Enum` и `String Enum`.\n\n`````ts\ninterface NumberDynamicKey {\n    [key: number]: string;\n}\n\nenum NumberEnum {\n    Prop = 0\n}\n\nenum StringEnum {\n    Prop = 'prop'\n}\n\nlet example: NumberDynamicKey = {\n    property: '',               // Error String key\n    '': '',                     // Error String key\n    1: '',                      // Ok Number key\n    [Symbol.for('key')]: '',    // Ok Symbol key\n    [NumberEnum.Prop]: '',      // Ok Number Enum key\n    [StringEnum.Prop]: '',      // Ok String Enum key\n};\n`````\n\nВывод типов, в некоторых случаях, выводит тип, принадлежащий к объектному типу с индексной сигнатурой. Напомню, что в _JavaScript_, помимо привычного способа при объявлении идентификаторов в объектных типах, можно использовать строковые литералы и выражения заключённые в квадратные скобки `[]`.\n\n`````ts\nlet computedIdentifier = 'e';\n\nlet v = {\n    a: '', // объявление идентификатора привычным способом,\n    ['b']: '', // объявление идентификатора с помощью строкового литерала.\n    ['c' + 'd']: '', // объявление идентификатора с помощью выражения со строковыми литералами\n    [computedIdentifier]: '' // объявление идентификатора при помощи вычисляемого идентификатора\n}; \n`````\n\nВ первых двух случаях, вывод типов выводит ожидаемый тип, а в оставшихся тип с индексной сигнатурой.\n\n`````ts\n// let v1: { a: string; }\nlet v1 = {\n    a: 'value'  // Ok, привычный идентификатор\n};\n\nv1.b = 'value'; // Error, в типе { a: string } не задекларирован идентификатор b\n`````\n`````ts\n// let v2: { ['a']: string; }\nlet v2 = {\n    ['a']: 'value'  // Ok, строковый литерал\n};\n\nv2.b = 'value'; // Error, в типе { ['a']: string } не задекларирован идентификатор b\n`````\n`````ts\nlet computedIdentifier: string = 'a';\n\n// let v3: { [x: string]: string }; - вывод типов выводит как тип с индексной сигнатурой...\nlet v3 = {\n    [computedIdentifier]: 'value' // вычисляемое свойство\n};\n\nv3.b = 'value'; // ... а это, в свою очередь, позволяет добавлять новое значение\n`````\n`````ts\n// let v4: { [x: string]: string }; - вывод типов выводит как тип с индексной сигнатурой...\nlet v4 = {\n    ['a' + 'b']: 'value' // выражение со строковыми литералами\n};\n\nv4.b = 'value'; // ... а это, в свою очередь, позволяет добавлять новое значение\n`````"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_1","elementId":"Strogaya_proverka_pri_obrashchenii_k_dinamicheskim_klucham","markdown":"## Строгая проверка при обращении к динамическим ключам\n\nПоскольку механизм, позволяющий определение _индексной сигнатуры_, не способен отслеживать идентификаторы (имена) полей определенных динамически, такой подход не считается типобезопасным.\n\n`````ts\ntype T = {\n    [key: string]: number | string;\n}\n\nfunction f(p: T) {\n    /**\n     * Обращение к несуществующим полям\n     */\n    p.bad.toString(); // Ok -> Ошибка времени исполнения\n    p[Math.random()].toString(); // Ok -> Ошибка времени исполнения\n}\n`````\n\nДанная проблема решается с помощью флага `--noUncheckedIndexedAccess` активирующего строгую проверку при обращении к динамическим членам объектных типов. Флаг `--noUncheckedIndexedAccess` ожидает в качестве значения `true` либо `false`. Активация механизма позволяет обращаться к динамическим членам только после подтверждения их наличия в объекте, а также совместно с такими операторами, как оператор опциональной последовательности `?.` и опциональный оператор `!.`.\n\n`````json\n// @filename: tsconfig.json\n\n{\n    \"compilerOptions\": {\n        \"noUncheckedIndexedAccess\": true\n    }\n}\n`````\n\n`````ts\ntype T = {\n  [key: string]: number | string;\n}\n\n\nfunction f(p: T) {\n  /**\n   * Обращение к несуществующим полям\n   */\n  p.bad.toString(); // Error -> TS2532: Object is possibly 'undefined'.\n  p[Math.random()].toString(); // Error -> TS2532: Object is possibly 'undefined'.\n\n\n  // Проверка наличия поля bad\n  if (\"bad\" in p) {\n      p.bad?.toString(); // Ok\n  }\n\n  // Использование опционального оператора\n  p[Math.random()]!.toString(); // Ok -> ошибка во время выполнения\n\n  p[Math.random()]?.toString();  // Ok -> Ошибка не возникнет\n}\n`````\n\nНе будет лишним упомянуть, что влияние данного механизма распространяется также и на массивы. В случае с массивом не получится избежать аналогичной ошибки при попытке обращения к его элементам при помощи индексной сигнатуры.\n\n`````ts\nfunction f(array: string[]) {\n    for (let i = 0; i < array.length; i++) {\n        array[i].toString(); // Error -> TS2532: Object is possibly 'undefined'.\n    }\n}\n`````"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_2","elementId":"Zapret_obrashcheniya_k_dinamicheskim_klucham_cherez_tochechnuu_notaciu","markdown":"## Запрет обращения к динамическим ключам через точечную нотацию\n\nПоскольку к динамическим ключам можно обращаться, как через точечную, так и скобочную нотацию, то может возникнуть потребность в разделении такого поведения. Для подобных случаев, в _TypeScript_ существует флаг `--noPropertyAccessFromIndexSignature`, установление которого в значение `true`, запрещает обращение к динамическим членам с помощью точечной нотации.\n\n`````json\n// @filename: tsconfig.json\n\n{\n    \"compilerOptions\": {\n        \"noPropertyAccessFromIndexSignature\": \"true\"\n    }\n}\n`````\n\n`````ts\ntype Settings = {\n    env?: string[]; // определение необязательного предопределенного поля\n\n    [key: string]: any; // определение динамических полей\n}\n\n\nfunction configurate(settings: Settings){\n    //---------------------------\n    // динамическое поле\n    if(settings.envs){ // Ошибка при активном флаге и Ok при не активном\n\n    }\n    if(settings['envs']){ // Ok при любом значении флага\n\n    }\n\n    //----------------------------\n    // предопределенное поле\n    if(settings.env){ // Ok [1]\n\n    }\n    if(settings['env']){ // Ok при любом значении флага\n\n    }\n}\n`````"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_3","elementId":"Tonkosti_sovmestimosti_indeksnoi_signaturoi_s_neobyazatelnymi_polyami","markdown":"## Тонкости совместимости индексной сигнатурой с необязательными полями\n\nОбъектные типы определяющие строковую индексную сигнатуру считаются совместимыми с объектными типами имеющими необязательные поля.\n\n`````ts\n/**\n * [0] поля определены как необязательные!\n */\ntype Magic = {\n    fire?: string[];\n    water?: string[];\n}\n\ndeclare const HERO_CONFIG: Magic;\n\nconst hero: {[key: string]: string[]} = HERO_CONFIG; // Ok\n/**Ok*/\n`````\n\nНо существует два неочевидных момента. При попытке инициализировать необязательные поля значением `undefined` возникнет ошибка.\n\n`````ts\n/**\n * [0] поля определены как необязательные!\n */\ntype Magic = {\n    fire?: string[];\n    water?: string[];\n}\n\ndeclare const HERO_CONFIG: Magic;\n\n/**\n * [1] Error -> \n * Type 'undefined' is not assignable to type 'string[]'.\n */\nconst hero: {[key: string]: string[]} = HERO_CONFIG;\nhero['fire'] = ['fireball']; // Ok\nhero['water'] = undefined; // Error [1]\n`````\n\nКроме этого, ошибки не удастся избежать тогда, когда объектный тип, вместо опционального оператора, явно указывает принадлежность типа членов к типу `undefined`.\n\n`````ts\n/**\n * [0] поля определены как обязательные!\n */\ntype Magic = {\n    fire: string[] | undefined; // [0]\n    water: string[] | undefined; // [0]\n}\n\ndeclare const HERO_CONFIG: Magic;\n\n/**\n * [1] Error ->\n * Type 'Magic' is not assignable to type '{ [key: string]: string[]; }'.\n */\nconst hero: {[key: string]: string[]} = HERO_CONFIG;\n/**[1]*/\n`````\n\nИ, кроме того, данные правила применимы исключительно к строковой индексной сигнатуре.\n\n`````ts\n/**\n * [0] ключи полей определены как индексы!\n */\ntype Port = {\n    80?: string; // [0]\n    88?: string; // [0]\n}\n\ndeclare const SERVER_PORT: Port;\n\n/**\n * [2] Ключ индексной сигнатуры принадлежит к типу number.\n * \n * [1] Error -> \n * Type 'Port' is not assignable to type '{ [key: number]: string[]; }'.\n */\nconst port: {[key: number]: string[]} = SERVER_PORT;\n   /**[1] */     /**[2] */\n`````"}],"githubFileInfo":{"lastUpdate":1632219105000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Interfaces","path":"Interfaces"},"nextPage":{"title":"Модификаторы доступа (Access Modifiers)","path":"Modifikatory_dostupa_(Access_Modifiers)"}},"contentNavData":{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","level":0,"index":22,"contentIndex":0,"section":"Типы","title":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)","elementId":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)","children":[{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Индексные члены (определение динамических ключей)","path":"Indeksnye_chleny_(opredelenie_dinamicheskih_kluchei)","elementId":"Indeksnye_chleny_(opredelenie_dinamicheskih_kluchei)"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Строгая проверка при обращении к динамическим ключам","path":"Strogaya_proverka_pri_obrashchenii_k_dinamicheskim_klucham","elementId":"Strogaya_proverka_pri_obrashchenii_k_dinamicheskim_klucham"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Запрет обращения к динамическим ключам через точечную нотацию","path":"Zapret_obrashcheniya_k_dinamicheskim_klucham_cherez_tochechnuu_notaciu","elementId":"Zapret_obrashcheniya_k_dinamicheskim_klucham_cherez_tochechnuu_notaciu"},{"key":"Объектные типы с индексными членами (объектный тип с динамическими ключами)_3","index":3,"contentIndex":4,"level":1,"section":"Типы","title":"Тонкости совместимости индексной сигнатурой с необязательными полями","path":"Tonkosti_sovmestimosti_indeksnoi_signaturoi_s_neobyazatelnymi_polyami","elementId":"Tonkosti_sovmestimosti_indeksnoi_signaturoi_s_neobyazatelnymi_polyami"}]},"pageDescription":"Объектные типы с индексными членами (объектный тип с динамическими ключами)"},"__N_SSG":true}