{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/054.(React) Типизированные хуки/images/"},"sectionInfoAll":[{"key":"Типизированные хуки","elementId":"Tipizirovannye_huki","markdown":"# Типизированные хуки\n\n_React_ _api_ насчитывает десять предопределенных хуков большинство которых являются универсальными. Каждый из них будет рассмотрен по отдельности. Кроме того, данная глава будет посвящена определению пользовательских хуков с учетом последних возможностей _TypeScript_."},{"key":"Типизированные хуки_0","elementId":"Predopredelennye_huki_-_useState<T>()","markdown":"## Предопределенные хуки - useState<T>()\n\nРассмотрение данной темы стоит начать с самого часто применяемого универсального хука `useState<T>(initialState): [state, dispatch]` параметр типа которого представляет определяемое им состояние. В случаях когда при вызове универсальной функции `useState<T>(initialState)` аргумент типа не устанавливается, тип значения будет выведен на основе аргумента функции обозначаемого `initialState`. Это в свою очередь означает, что при отсутствии инициализационного значения (вызов функции `useState` без значения) или его временном замещении значением принадлежащим к другому типу (например объектный тип замещается значением `null`), или частичном значении (объектный тип определяющий лишь часть своих членов), изменить его в будущем с помощью функции обозначаемой `dispatch` будет невозможно, поскольку она при определении также ассоциируется с выведенным на основе `initialState` типом.\n\n`````ts\nconst A: FC = () => {\n                              /**[0][1] */\n    let [state, dispatch] = useState();\n    dispatch(0); // Error -> type 0 is not type undefined\n\n    /**\n     * Поскольку отсутствие initialState [1] не было\n     * компенсировано аргументом типа [0] невозможно\n     * установит новое значение с помощью функции dispatch\n     * если оно принадлежит к типу отличному от выведенного\n     * в момент определения.\n     */\n\n\n    return null;\n}\n\nconst B: FC = () => {\n                               /**[0][1] */\n    let [state, dispatch] = useState(null);\n    dispatch({ a: 0 }); // Error -> type {a: number} is not type null\n\n    /**\n    * Поскольку initialState [1] принадлежит к типу null\n    * и отсутствует уточнение типа состояния при помощи\n    * аргумента типа [0], то будет невозможно установить новое\n    * значение с помощью функции dispatch если оно принадлежит\n    * к типу отличному от выведенного в момент определения.\n    */\n\n\n    return null;\n}\nconst С: FC = () => {\n                               /**[0] [1] */\n    let [state, dispatch] = useState({a: 0});\n    dispatch({ a: 0, b: `` }); // Error -> type {a: number, b: string} is not type {a: number}\n\n    /**\n    * Поскольку initialState [1] представляет из себя лишь \n    * часть от предполагаемого типа и при этом отсутствует\n    * уточнение типа состояния при помощи\n    * аргумента типа [0], то будет невозможно установить новое\n    * значение с помощью функции dispatch если оно принадлежит\n    * к типу отличному от выведенного в момент определения.\n    */\n\n\n    return null;\n}\n`````\n\nВ подобных случаях необходимо уточнить тип к которому принадлежит состояние при помощи аргумента типа. Единственное нужно помнить, что несмотря на уточнение типа, при отсутствии `initialState`, состояние будет принадлежать к объединению `T | undefined`.\n\n\n`````ts\nconst A: FC = () => {\n    let [state, dispatch] = useState<number>();\n    dispatch(0); // Ok\n    state; // number | undefined\n\n\n    return null;\n}\n\nconst B: FC = () => {\n                                              /**[*] */\n    let [state, dispatch] = useState<{a: number} | null>(null);\n    dispatch({ a: 0 }); // Ok\n    state; // {a: number} | null\n\n\n    return null;\n}\nconst С: FC = () => {\n                                             /**[*] */\n    let [state, dispatch] = useState<{a: number; b?: string;}>({a: 0});\n    dispatch({ a: 0, b: `` }); // Ok\n    state; // {a: number; b?: string | undefined}\n\n\n    return null;\n}\n\n/**\n * [*] конкретизация типа\n */\n `````\n\nВсе описанные случаи так или иначе предполагают дополнительные проверки на существование значения, которые на практике отягощают код. Поэтому при отсутствии конкретного состояния выступающего в роли аргумента универсальной функции, всегда лучше устанавливать значение по умолчанию в полной мере соответствующего типу, нежели допускать его отсутствие, замещение или частичную установку.\n\nПри условии, что `initialState` представлен значением в полной мере соответствующим требуемому типу, необходимость в уточнении с помощью аргумента типа пропадает, поскольку выводу типов не составит особого труда справиться самостоятельно. Простыми словами, если аргумент типа не устанавливается, его тип выводится на основе типа к которому принадлежит аргумент вызываемой функции. В случае, когда состояние в полной мере устанавливается в качестве единственного аргумента хука `useState<T>()` необходимости в уточнении типа, при помощи аргумента функционального типа, не требуется. Если в качестве значения выступает примитив или объект, все члены которого инициализированны, вывод типов будет только рад взять работу по установлению типа на себя.\n\n`````ts\nconst A: FC = () => {\n    let [state, dispatch] = useState(0);\n    dispatch(0); // Ok\n    state; // number\n\n\n    return null;\n}\n\nconst B: FC = () => {\n    let [state, dispatch] = useState({a: 0});\n    dispatch({ a: 0 }); // Ok\n    state; // {a: number}\n\n\n    return null;\n}\nconst С: FC = () => {\n    let [state, dispatch] = useState({a: 0, b: ``});\n    dispatch({ a: 0, b: `` }); // Ok\n    state; // {a: number; b: string;}\n\n\n    return null;\n}\n`````"},{"key":"Типизированные хуки_1","elementId":"Predopredelennye_huki_-_useEffect()_i_useLayoutEffect()","markdown":"## Предопределенные хуки - useEffect() и useLayoutEffect()\n\nСледующими на очереди расположились сразу два идентичных с точки зрения типизации хука `useEffect(effect, deps?): void` и `useLayoutEffect(effect, deps?): void`, ожидающие в качестве первого параметра функцию, а в качестве второго необязательного параметра, массив, изменение элементов которого приводит к повторному вызову первого аргумента. Поскольку у данных хуков отсутствует возвращаемое значение, сложно представить сценарий в котором возникает ошибка связанная с передачей аргументов. Поэтому подробное рассмотрение и пояснение будет опущено.\n\n`````ts\nconst A: FC = () => {\n    useEffect(() => {\n        return () => {}\n    }, []);\n\n    useLayoutEffect(() => {\n        return () => {}\n    }, []);\n\n\n    return null;\n}\n`````"},{"key":"Типизированные хуки_2","elementId":"Predopredelennye_huki_-_useContext<T>()","markdown":"## Предопределенные хуки - useContext<T>()\n\nСледующий претендент на рассмотрение предназначен для работы с контекстом и является универсальной функцией `useContext<T>(context)` принимающей в качестве аргумента объект контекста, который при необходимости можно уточнить с помощью аргумента типа. Поскольку вывод типов в состоянии самостоятельно вывести тип опираясь на обязательный параметр `context`, то уточнение типа с помощью аргумента типа не требуется.\n\n\n`````ts\nimport React, {createContext, useContext, FC} from \"react\";\n\nconst StringContext = createContext(`Is Context Value!`);\n\nconst A: FC = () => {\n    let context = useContext(StringContext // let context: string\n\n\n    return null;\n}\n`````\nУточнение с помощью аргумента типа может потребоваться только при необходимости приведения более общего типа к более конкретному. Но в реальности универсальная функция этого не позволяет сделать.\n\n`````ts\nimport React, {createContext, useContext, FC} from \"react\";\n\ninterface T0 {\n    a: number;\n}\ninterface T1 {\n    b: string;\n}\n\n\n       /**[0] */\ninterface T2 extends T0, T1 {}\n\n/**\n * [0] более общий тип\n */\n\n\nlet contextDefaultValue: T2 = {\n    a: 0,\n    b: ``\n};\n\nconst StringContext = createContext(contextDefaultValue); // const StringContext: React.Context<T2>\n\nconst A: FC = () => {\n    let c0 = useContext(StringContext); // let c0: T2\n    let c1 = useContext<T0>(StringContext); // Error -> [1]\n\n    /**\n     * [1] при попытке приведения более общего типа\n     * T2 к более конкретному типу T0 возникает ошибка ->\n     * Argument of type 'Context<T2>' is not assignable\n     * to parameter of type 'Context<T0>'.\n     */\n\n    return null;\n}\n`````\n\nПри возникновении потребности в подобном приведении конкретизировать необходимо идентификатор ассоциированный со значением, то есть переменную.\n\n`````ts\nconst A: FC = () => {\n    let c2: T0 = useContext(StringContext); // Ok -> let c2: T0\n\n    return null;\n}\n`````"},{"key":"Типизированные хуки_3","elementId":"Predopredelennye_huki_-_useReducer<R>()","markdown":"## Предопределенные хуки - useReducer<R>()\n\nСледующий в списке предопределенных хуков расположился `useReducer<R>(reducer, initialState, stateInit):[state, dispatch]` представленный универсальной функцией имеющей множество перегрузок. Чтобы познакомится с каждым из параметров данной функции, для начала, нам потребуется объявить два типа описывающих состояние (`state`) и инициализационное состояние (`initialState`), которое специально будет отличаться от обычного, что бы преобразовать его при помощи функции обозначенной как `stateInit`.\n\n`````ts\n/**[0] */\ninterface InitialState {\n    name: string;\n    age: number;\n    gender: `male` | `female` | `notSpecified`;\n}\n/**[1] */\ninterface State {\n    name: string;\n    gender: `male` | `female` | `notSpecified`;\n}\n\n/**\n * Объявление интерфейсов описывающих\n * состояние [1] и инициализационное состояние [0].\n * \n */\n `````\n\nЗатем определим функцию `reducer` для описания сигнатуры которой воспользуемся импортированным их пространства имен _React_ обобщенным типом `Reducer<S, A>` ожидающего в качестве первого аргумента типа тип описывающий `state`, а в качестве второго тип описывающий действие `Action`. В нашем примере второй аргумент типа `Reducer<S, A>` будет представлен псевдонимом для двух конкретных типов действий, перед объявлением которых стоит обратить внимание на один относящийся к ним тонкий момент. Тонкость заключается в том, что функция-редюсер, в качестве второго параметра, может, и в большинстве случаев будет принимать объекты действий принадлежащих к разным типам. Для их конкретизации выводу типов потребуется помощь в виде дискриминантных полей.\n\n`````ts\nimport React, {useReducer, Reducer, FC} from \"react\";\n\ninterface InitialState {\n    name: string;\n    gender: number;\n    gender: `male` | `female` | `notSpecified`;\n}\ninterface State {\n    name: string;\n    gender: `male` | `female` | `notSpecified`;\n}\n\n\n/**[0] */\nenum ActionType {\n    Name = `name`,\n    Gender = `gender`,\n}\n\n/**\n * [0] определение перечисления содержащего\n * константы необходимые для конкретизации типа\n * Action.\n */\n\n\n            /**[1] */\ninterface NameAction {\n    type: ActionType.Name; /**[2] */\n    name: string; /**[3] */\n}\n            /**[1] */\ninterface GenderAction {\n    type: ActionType.Gender; /**[2] */\n    gender: `male` | `female` | `notSpecified`; /**[3] */\n}\n\n/**\n * [1] объявление более конкретных типов действий\n * объявляющий поля name и gender [3] и дискриминантное\n * поле type [2] в качестве типа которого указан элемент\n * перечисления.\n */\n\n\n/**[4] */\ntype Actions = NameAction | GenderAction;\n\n/**\n * [4] объявление псевдонима ссылающегося на\n * тип объединение представленный типами Action.\n */\n\n\n     /**[5]      [6]    [7]     [8]            [9]     [10] */\nconst reducer: Reducer<State, Actions> = (state, action) => {\n                /**[11] */\n    if(action.type === ActionType.Name){\n                                /**[12] */\n        return {...state, name: action.name};\n                      /**[11] */\n    }else if(action.type === ActionType.Gender){\n                                /**[12] */\n        return {...state, gender: action.gender};\n    }\n\n\n    return state;\n}\n\n/**\n * [5] определение функции редюсера сигнатура\n * которой уточняется при помощи импортированного\n * из пространства имен React обобщенного типа Reducer<S, A> [6]\n * в качестве первого параметра который получает тип представляющей\n * State [7], а в качестве второго тип объединение Actions [8].\n * При таком сценарии сигнатура функции в явном указании типов не нуждается [9] [10]\n * \n * Блок кода, вхождение в который возможно в результате положительного\n * результата выполнения условия на принадлежность дискриминантного поля type\n * элементу перечисления [11], подразумевает, что объект action принадлежит\n * к соответствующему типу, что позволяет обращаться к присущим только ему членам [12]\n * \n */\n`````\n\nКак было сказано ранее, сигнатура редюсера не нуждается в аннотации если его тип конкретизирован с помощью `Reducer<S, A>`. За этим скрывается один коварный момент. Представьте ситуацию при которой некоторое время приложение работало с состоянием определяющим `name`, а затем было принято решение изменить его на `fullName`.\n\n`````ts\n// было\n\ninterface State {\n    name: string;\n    age: number;\n}\n\ninterface NameAction {\n    type: `name`;\n    name: string;\n}\n\nconst reducer: Reducer<State, NameAction> = (state, action) => {\n    if(action.type === `name`){\n        return {...state, name: action.name};\n    }\n    \n    return state;\n}\n`````\n\nПосле того как тип описывающий состояние и действие претерпят изменения, неминуемо возникнет ошибка указывающая, что в действии больше нет поля `name`. Если впопыхах изменить лишь старый идентификатор `name` на новый `fullName`, то можно не заметить как значение ассоциированное с новым идентификатором определенным в объекте действия присваивается старому идентификатору определяемому в объекте нового состояния. К ошибке это не приведет, поскольку механизм распространения старого состояния `...state` наделяет новое всеми признаками необходимыми для совместимости с типом `State`. Старый идентификатор `name` в новом состоянии делает его принадлежащим к более общему типу который совместим с объектом `State`. Это неминуемо приводит к трудновыявляемому багу, поскольку значение поля `fullName` всегда будет старым.\n\n`````ts\ninterface State {\n    fullName: string; /**[0] */\n    age: number;\n}\n\ninterface NameAction {\n    type: `name`;\n    fullName: string; /**[0] */\n}\n\nconst reducer: Reducer<State, NameAction> = (state, action) => {\n    if(action.type === `name`){\n                        /**[1]        [2] */\n        return {...state, name: action.fullName};\n    }\n\n    return state;\n}\n\n/**\n * При изменении State и NameAction [0] ошибка\n * укажет на отсутствие поля name  в объекте\n * принадлежащего к типу NameAction [2]. Интуитивное\n * исправление лишь этой ошибки приведет к трудновыявляемому\n * багу, поскольку новое поле действия присваивается старому идентификатору [1].\n * Нужно быть внимательным, поскольку ошибки не возникнет. Причина заключается в том\n *, что распространение старой версии ...state наделяет новый объект всеми необходимыми\n * характеристиками, что бы быть совместимым с типом State. Старое поле делает из нового объекта\n * значение принадлежащие к более общему типу который совместим с типом State. Поэтому\n * ошибки связанной с неверным возвращающимся значением не возникает. Тем не менее редюсер\n * никогда не изменит значение на новое. Оно всегда будет браться из предыдущего объекта состояния.\n */\n`````\n\nВозвращаясь к основному примеру осталось определить компонент в котором и будет происходить определение элементов _Redux_. Первым делом в теле компонента определим инициализационное состояние которое с помощью функции обозначенной ранее как `stateInit` будет преобразовано в значение соответствующее типу необходимого редюсеру. Стоит заметить, что поскольку инициализационное значение в полной мере соответствует типу `InitialState` аннотация типа является излишней. При определении с помощью универсальной функции `useReducer()` элементов редакса стоит сделать акцент на отсутствии необходимости в указании аргументов типа, поскольку вывод типов будет опираться на аннотации типов параметров данного хука.\n\nОсталось последовательно изменить состояние с помощью функции `dispatch` вызов которой с объектами в точносте соответствующих типам `*Action` не вызывает никаких нареканий. Вызов с аргументом не надлежащего типа приводит к возникновению ошибки, что в свою очередь подтверждает надежность описанной логики сопряженной с хуком `useReducer()`.\n\n\n`````ts\n        /**[13]               [14] */\nconst initState = (initialState: InitialState) => {\n    let {gender, ...reducerState} = initialState;\n\n    return reducerState; /**[15] */\n};\n\nconst A: FC = () => {\n        /** [16]       [17] */\n    let initialState: InitialState = {\n        name: `noname`,\n        age: NaN,\n        gender:  `notSpecified`\n    };\n                        /**[18] */\n    let [state, dispatch] = useReducer(reducer, initialState, initState);\n\n    /**[19] */\n    dispatch({\n        type: ActionType.Name,\n        name: `superuser`\n    });\n\n    /**[19] */\n    dispatch({\n        type: ActionType.Gender,\n        gender: `male`\n    });\n\n    /**[20] */\n    dispatch({\n        type: ActionType.Gender,\n        gender: `male`,\n        age: 100\n    }); // Error -> Object literal may only specify known properties, and 'age' does not exist in type 'GenderAction'.\n\n\n    return null;\n}\n\n/**\n * [14] определение инициализационного состояния которое будет\n * передано в качестве единственного аргумента [14] функции initState [13]\n * предназначенной для его трансформации в состояние пригодное редюсеру [15].\n * Данная функция вместе с редюсером и инициализационным состоянием передается\n * в универсальную функцию useReducer в качестве аргументов. Стоит заметить, что \n * универсальная функция useReducer определяющая элементы redux [18] \n * в указании аргументов типа не нуждается так как вывод типов отталкивается от\n * типов указанных в аннотациях элементов ожидаемых в качестве параметров.\n * \n * [19] успешное изменение состояния.\n * [20] попытка изменить состояние с помощью объекта тип которого не совместим\n * с типом State приводит к ошибке.\n */\n`````\n\nНе будет лишним пролить свет на подход объявления типов действий в основе которых лежит базовый тип. Подобное часто требуется для так называемых `DataAction`, действий которые помимо поля `type` определяют ещё и поле `data` с типом `T`.\n\nДля этого потребуется объявить два обобщенных типа. Первым объявим обобщенный тип `Action<T>`, единственный параметр типа которого будет указан в аннотации типа дискриминантного поля `type`. Вторым тип `DataAction<T, D>`, первый параметр типа которого будет передан при расширении в качестве аргумента типу `Action<T>`, а второй параметр типа будет указан в аннотации типа единственного поля `data`. Такой подход часто применяется на практике и значительно упрощает объявление типов представляющих действия предназначенных исключительно для транспортировки данных.\n\n`````ts\n/**[0] */\ninterface Action<T> {\n    type: T;\n}\n/**[1] */\ninterface DataAction<T, D> extends Action<T> {\n    readonly data: D;\n}\n\n/**\n * Объявление обобщенных типов действий первый из которых\n * описывает обычное действие с единственным полем\n * type: T [0], а другой расширяет первый и определяет\n * поле data: D.\n */\n\n\n\nenum ActionType {\n    Name = `name`,\n    Gender = `gender`,\n}\n\n\ninterface NameData {\n    name: string;\n}\ninterface GenderData {\n    gender: `male` | `female` | `notSpecified`;\n}\n\n\n          /**[2]                [3]            [4]          [5] */\ninterface NameAction extends DataAction<ActionType.Name, NameData> {\n}\n          /**[2]                [3]            [4]               [5] */\ninterface GenderAction extends DataAction<ActionType.Gender, GenderData> {\n}\n\n/**\n * [2] определение конкретных действий в основе\n * которых лежит базовый обобщенный тип DataAction<T, D> [3]\n * которому при расширении в качестве первого аргумента типа\n * устанавливается тип дискриминантного поля [4], а в качестве\n * второго тип представляющий данные [5].\n */\n\ntype Actions = NameAction | GenderAction;\n`````\n\nОсталось рассмотреть только случай предполагающий указания аргументов типа универсальной функции острая необходимость в которых возникнет при определении аргументов в момент вызова. В таком случае в качестве первого аргумента типа универсальная функция ожидает тип описывающий функцию редюсер, вторым инициализационное состояние. Кроме того, прибегнуть к помощи аргументов типа может потребоваться и при других сценариях рассматриваемых на всем протяжении темы посвященной хукам. Также не стоит забывать, что универсальная функция `useReducer` имеет множество перегрузок, что на практике допускает сценарии отличные от данного примера.\n\n`````ts\nimport React, {useReducer, Reducer, FC, useRef} from \"react\";\n\ninterface InitialState {\n    name: string;\n    age: number;\n    gender: `male` | `female` | `notSpecified`;\n}\ninterface State {\n    name: string;\n    gender: `male` | `female` | `notSpecified`;\n}\n\n\nenum ActionType {\n    Name = `name`,\n    Gender = `gender`,\n}\n\nenum Genders {\n    Male = `male`,\n    Female = `female`,\n    NotSpecified = `notSpecified`\n}\n\n\ninterface NameAction {\n    type: ActionType.Name;\n    name: string;\n}\ninterface GenderAction {\n    type: ActionType.Gender;\n    gender: Genders;\n}\n\n\ntype Actions = NameAction | GenderAction;\n\nconst App: FC = () => {\n                                            /**[0]                  [1] */\n    let [state, dispatch] = useReducer<Reducer<State, Actions>, InitialState>(\n        (state, action) => state, /**[2] */\n        {name: ``, age: 0, gender: Genders.NotSpecified}, /**[3] */\n        (initialState) => ({name: initialState.name, gender: initialState.gender})\n    );\n\n    return null;\n}\n\n/**\n * Указание аргументов типа универсальной функции\n * требуется тогда, когда её аргументы определяются\n * при вызове. В таком случае первый аргумент типа\n * будет представлять описание [0] функции редюсера [02],\n * второй инициализационного состояния [1] [3]. Также возможны\n * и другие сценарии требующий указания аргументов типа которые \n * были затронуты ранее в теме. Кроме того, универсальная функция\n * имеет множество перегрузок допускающих отличие от данного примера. \n */\n `````"},{"key":"Типизированные хуки_4","elementId":"Predopredelennye_huki_-_useCallback<T>()","markdown":"## Предопределенные хуки - useCallback<T>()\n\nСледующий на очереди универсальный хук `useCallback<T>(callback: T, deps): T` рассмотрение которого можно ограничить иллюстрацией его применения, поскольку с ним не связанно ничего, что к данному моменту могло бы вызвать хоть какой-то вопрос. Другими словами, как и в остальных рассмотренных ранее случаях прибегать к помощи аргументов типа следует только тогда, когда сигнатура функции обозначенной как `callback` частично или вовсе не имеет указания типов.\n\n`````ts\nimport React, {useCallback, FC} from \"react\";\n\n\nconst A: FC = () => {\n    /**[0] */\n    const greeter = useCallback((userName: string) => {\n        return `Hello ${userName}!`;\n    }, []);\n\n    /**\n     * [0] вывод типов ->\n     * \n     * const greeter: (userName: string) => string\n     */\n\n\n    return null;\n}\n\n\n\ntype Decorate = (username: string) => string;\n\nconst B: FC = () => {\n    /**[0] */\n    const greeter = useCallback<Decorate>( userName => {\n        return `Hello ${userName}!`;\n    }, []);\n\n    /**\n     * [0] аргумент типа ->\n     * \n     * const greeter: Decorate\n     */\n\n\n    return null;\n}\n`````"},{"key":"Типизированные хуки_5","elementId":"Predopredelennye_huki_-_useRef<T>()","markdown":"## Предопределенные хуки - useRef<T>()\n\nСледующий хук `useRef<T>(initialValue)` является универсальной функцией предназначенной для создания объекта рефы. Поскольку объект рефы возвращаемый из данного хука может служить не только для хранения ссылок на _React элементы_ и _React компоненты_, но и на любые другие значения, которые к тому же могут выступать в качестве единственного аргумента, данная функция имеет множество перегрузок. И кроме этого на текущий момент с ней связан один нюанс. Но обо всем по порядку.\n\nВ тех случаях когда объект рефы выполняет роль хранилища для не относящихся к _React_ значений, в его определении нет ничего необычного. Простыми словами, если инициализационное значение устанавливается частично или не устанавливается вовсе, то его тип необходимо конкретизировать с помощью аргумента типа. В противном случае переложить эту работу на вывод типов.\n\n`````ts\nimport React, {useRef, FC} from \"react\";\n\ninterface Data {\n    a: number;\n    b: string;\n}\n\nconst A: FC = () => {\n                        /**[0]   [1]      [2] */\n    let dataRef = useRef<Partial<Data>>({a: 0}); // let dataRef: React.MutableRefObject<Partial<Data>>\n    let a = dataRef.current.a; // let a: number | undefined\n\n    return null;\n}\n\n/**\n * Поскольку значение [1] установлено частично [2]\n * возникла необходимость прибегнуть к помощи типа\n * Partial<T> [0].\n */\n\nconst B: FC = () => {\n                            /**[0]        [1] */\n    let dataRef = useRef<Data | undefined>(); // let dataRef: React.MutableRefObject<Data | undefined>\n    let a = dataRef.current?.a; // let a: number | undefined\n\n    return null;\n}\n\n/**\n * Поскольку значение [1] вовсе не было установлено\n * аргумент типа указан как объединение включающего\n * тип undefined [0].\n */\n\nconst C: FC = () => {\n           /**[0]      [1]   [2] */\n    let dataRef = useRef({a: 0, b: ``}); // let dataRef: React.MutableRefObject<{a: number;b: string;}>\n    let a = dataRef.current.a; // let a: number\n\n    return null;\n}\n\n/**\n * Поскольку значение [2] в полной мере соответствует\n * предполагаемому типу необходимости в конкретизации\n * типа отпадает [0] [1].\n */\n `````\n\nТакже стоит обратить внимание, что идентификатор которому в момент определения присваивается результат вызова функции `useRef()` в явной аннотации не нуждается.\n\n`````ts\nconst C: FC = () => {\n        /**[0] */\n    let dataRef = useRef({a: 0, b: ``});\n\n    return null;\n}\n\n/**\n * [0] ссылка на возвращаемый хуком useRef объект\n * в аннотации типа не нуждается. Указание аннотаций\n * типа в подобных случаях лишь отнимают время и\n * затрудняют чтение кода.\n * \n * let dataRef: React.MutableRefObject<{a: number;b: string;}>\n */\n`````\n\nОсталось оговорить упомянутый в самом начале нюанс который связан с объектом рефы устанавливаемого _React элементу_. Дело в том, что декларация _React элементов_, в частности поля `ref`, аннотирована устаревшим типом, который не совместим с типом значения получаемого в результате вызова хука `useRef()`. К тому же уточнение типа в аннотации идентификатора или с помощью аргументов типа универсальной функции с данной проблемой справится не помогут. Единственное решение явное приведение к типу `RefObject<T>` возвращаемое хуком значение с помощью оператора `as`.\n \n`````ts\nimport React, {useRef, FC, RefObject} from \"react\";\n\nconst A: FC = () => {\n    // let formRef: RefObject<HTMLFormElement> | null = useRef(); // Error\n    // let formRef = useRef<RefObject<HTMLFormElement> | null>(); // Error\n    let formRef = useRef() as RefObject<HTMLFormElement> | null; // Ok\n\n\n    return <form ref={formRef}></form>\n}\n`````\n\nБолее подробно с данным хуком можно познакомиться в главе посвященной рефам."},{"key":"Типизированные хуки_6","elementId":"Predopredelennye_huki_-_useImperativeHandle<T,R>()","markdown":"## Предопределенные хуки - useImperativeHandle<T, R>()\n\nСледующий на очереди хук `useImperativeHandle<T, R>(ref: Ref<T>, apiFactory() => R): void` предназначенный для присваивания объекта выступающего в роли открытой части _api_ функционального компонента. В тех случаях когда открытая часть _api_ отличается от закрытой, универсальная функция нуждается в уточнении при помощи аргументов типа. В остальных случах всегда рекомендуется поручить эту работу выводу типов. \n\n\n`````ts\nimport React, {ForwardRefRenderFunction, RefObject, useRef, useImperativeHandle, FC, forwardRef} from \"react\";\n\ninterface FormProps {\n\n}\n\n/**[0] */\ninterface PublicFormApi {\n    a: () => void;\n}\n/**[1] */\ninterface PrivateFormApi extends PublicFormApi {\n    b: () => void;\n}\n\n/**\n * [0] объявление типа представляющего открытую часть\n * api компонента, которую будет расширять объявленный\n * позже тип описывающий его закрытую часть [1].\n */\n\n\n /**\n  * \n  * [!] не обращать внимание на код\n  * помеченный восклицательным знаком,\n  * поскольку данные участи кода будут\n  * подробно рассмотрены в свое время.\n  */\n\n                    /**[!] */\nconst Form: ForwardRefRenderFunction<PublicFormApi, FormProps> = (props, ref) => {\n                         /**[2]             [3] */\n    useImperativeHandle<PublicFormApi, PrivateFormApi>(ref, () => ({\n        a: () => {},\n        b: () => {},\n    }), []);\n\n    /**\n     * С помощью аргументов типа указываем тип\n     * открытой [2] и закрытой [3] части api компонента.\n     */ \n\n\n    return null;\n}\n\n        /**[!]            [!] */\nconst FormWithRef = forwardRef(Form);\n\n\nconst App: FC = () => {\n                        /**[!] */\n    let formRef = useRef() as RefObject<PublicFormApi>;\n\n    formRef.current?.a(); // Ok\n    // formRef.current?.b(); // Error\n\n                     /**[6] */\n    return <FormWithRef ref={formRef} />;\n}\n `````"},{"key":"Типизированные хуки_7","elementId":"Predopredelennye_huki_-_useMemo<T>()","markdown":"## Предопределенные хуки - useMemo<T>()\n\nСледующим на очереди хук `useMemo<T>(factory): T` является универсальной функцией ожидающей в качестве первого параметра фабричную функцию вычисляющую возвращаемое хуком значение тип которого, при необходимости, можно указать с помощью аргумента типа. Второй обязательный параметр принадлежит к типу массива, при наличии и изменении элементов которого происходит повторный вызов фабричной функции. Как всегда, стоит упомянуть, что явное указание аргумента типа универсальной функции необходимо в очень редких случаях, каждый из которых был рассмотрен на протяжении всей темы посвященной хукам. Кроме того, переменная которой присваивается возвращаемое из хука значение, в аннотации типа и вовсе не нуждается.\n\n`````ts\nimport React, {useMemo, FC} from \"react\";\n\nconst A: FC = () => {\n            /**[0]           [1] */\n    let memoizedValue = useMemo( () => 2 + 2, [] ); // let memoizedValue: number\n\n    return null;\n}\n\n/**\n * Нет необходимости указывать аннотацию\n * типа переменной [0] и передавать аргументы\n * типа [1] универсальной функции поскольку\n * вывод типов самостоятельно справится с этой работой.\n */\n `````"},{"key":"Типизированные хуки_8","elementId":"Predopredelennye_huki_-_useDebugValue<T>()","markdown":"## Предопределенные хуки - useDebugValue<T>()\n\nСледующий и последний на очереди хук `useDebugValue<T>(data: T, format(data: T) => any): void` предназначенный для вывода логов в _devtools_ является универсальной функцией первый параметр которой ожидает выводимое в консоль значение, чьё форматирование может быть осуществлено при помощи функции выступающей в роли второго необязательного параметра. Вся информация имеющаяся к этому моменту и касающаяся явного указания типов в полной мере справедлива и для текущего хука.\n\n `````ts\nimport React, {useDebugValue, FC} from \"react\";\n\nconst A: FC = () => {\n                    /**[0]    [1]           [2] */\n    useDebugValue(new Date(), date => date.getMilliseconds() );\n\n    return null;\n}\n\n/**\n * Хук принимает значение тпа Date [0]\n * и затем передает его в функцию форматирования [1]\n * из которой возвращается значение принадлежащее к\n * типу number [2].\n */\n`````"},{"key":"Типизированные хуки_9","elementId":"Polzovatelskii_huk","markdown":"## Пользовательский хук\n\nПомимо предопределенных хуков рассмотренных ранее, _React_ также позволяет определять пользовательские хуки, которым будет посвящен остаток текущей главы.\n\nЧтобы стразу перейти к делу представьте, что перед разработчиком встала задача реализовать эффект печатающегося текста с возможностью его запускать, останавливать и ставить на паузу при необходимости. Для этого потребуется реализовать пользовательский хук `usePrintText(text, interval)`, который на вход будет принимать исходный текс и значение скорости печати. Поскольку печатающийся текст будет реализован за счет постепенного изменения состояния определенного внутри хука и выдаваемого наружу, начать стоит именно с описания его типа.\n\n`````ts\n/**описание объекта состояния */\ninterface TextPrintInfo {\n    isDone: boolean;\n    status: TextPrintStatus;\n    currentText: string;\n    sourceText: string;\n}\n`````\n\nКроме состояния, хук должен предоставлять функции выступающие в роли контролов предназначенных для управления анимацией печатанья. Поэтому вторым шагом потребуется описать тип представляющих контролы, что совершенно не составит никакого труда, так как старт\\пауза\\стоп являются обычными функциями которые ничего не возвращают.\n\n`````ts\n/**описание типа контролов старт\\пауза\\стоп */\ntype ControlCallback = () => void;\n`````\n\nОсталось описать тип представляющий сам хук или если быть точнее, сигнатуры функции, которой по сути он является. Особое внимание стоит обратить на возвращаемый тип представленный размеченным кортежем, для которого несмотря на большое количество кода не был создан псевдоним. Такое решение было принято из-за того, что автокомплит _ide_ указал бы возвращаемый тип как псевдоним, сделав тем самым подсказку малоинформативной, лишив её информации, доступной благодаря меткам.\n\n`````ts\n        /**[0]                                               [1] */\ntype UsePrintText = (sourceText: string, interval?: number) => [\n    textInfo: TextPrintInfo,\n    start: ControlCallback,\n    pause: ControlCallback,\n    stop: ControlCallback\n];\n\n/**\n * [0] тип представляющий пользовательский хук,\n * тип возвращаемого значения представлен размеченным кортежем [1]\n */\n `````\n\n Осталось лишь определить сам хук. \n\n`````ts\ninterface TextPrintInfo {\n    isDone: boolean;\n    status: TextPrintStatus;\n    currentText: string;\n    sourceText: string;\n}\n\ntype ControlCallback = () => void;\n\ntype UsePrintText = (sourceText: string, interval?: number) => [\n    textInfo: TextPrintInfo,\n    start: ControlCallback,\n    pause: ControlCallback,\n    stop: ControlCallback\n];\n\n\n\nconst usePrintText: UsePrintText = (sourceText, interval = 200) => {\n    // определение состояния\n    let [textInfo, setTextInfo] = useState({\n        isDone: false,\n        status: TextPrintStatus.Waiting,\n        currentText: ``,\n        sourceText,\n    });\n\n\n    // определение контролов\n    const start = () => {\n    }\n    const pause = () => {\n    }\n    const stop = () => {\n    }\n\n\n    return [textInfo, start, pause, stop];\n}\n`````\n\nПоскольку логика работы хука не имеет никакого отношения к _TypeScript_, её детального разбора не будет. Тем не менее полный код представлен и при желании испытать свои знания, предлагается самостоятельно устно его прокомментировать. \n\n`````ts\nimport React, { useState, useEffect } from \"react\";\n\nenum TextPrintStatus {\n    Print = `print`,\n    Waiting = `waiting`,\n    Pause = `pause`,\n    Done = `done`\n}\n\ninterface TextPrintInfo {\n    isDone: boolean;\n    status: TextPrintStatus;\n    currentText: string;\n    sourceText: string;\n}\n\ntype ControlCallback = () => void;\ntype UsePrintText = (sourceText: string, interval?: number) => [\n    textInfo: TextPrintInfo,\n    start: ControlCallback,\n    pause: ControlCallback,\n    stop: ControlCallback\n];\n\nconst usePrintText: UsePrintText = (sourceText, interval = 200) => {\n    let [timeoutId, setTimeoutId] = useState(NaN);\n    let [textInfo, setTextInfo] = useState({\n        isDone: false,\n        status: TextPrintStatus.Waiting,\n        currentText: ``,\n        sourceText,\n    });\n\n\n    const isDone = () => textInfo.currentText.length === sourceText.length;\n    const getNextText = () => textInfo.currentText.concat(sourceText.charAt(textInfo.currentText.length));\n\n    useEffect(() => {\n        if (textInfo.status === TextPrintStatus.Print && !textInfo.isDone) {\n            print();\n        }\n\n    }, [textInfo]);\n\n    useEffect(() => () => cancel(), []);\n\n\n    const print = () => {\n        let timeoutId = setTimeout(() => {\n            setTextInfo({\n                status: isDone() ? TextPrintStatus.Done : TextPrintStatus.Print,\n                isDone: isDone(),\n                currentText: getNextText(),\n                sourceText\n            });\n        }, interval);\n\n        setTimeoutId(timeoutId);\n    }\n\n    const cancel = () => {\n        if (!Number.isNaN(timeoutId)) {\n            clearTimeout(timeoutId);\n        }\n    }\n    const start = () => {\n        setTextInfo({\n            ...textInfo,\n            status: TextPrintStatus.Print,\n        });\n    }\n    const pause = () => {\n        cancel();\n        setTextInfo({\n            ...textInfo,\n            status: TextPrintStatus.Pause,\n            isDone: false,\n        });\n        setTimeoutId(NaN);\n    }\n    const stop = () => {\n        cancel();\n        setTextInfo({\n            isDone: false,\n            status: TextPrintStatus.Waiting,\n            currentText: ``,\n            sourceText\n        });\n        setTimeoutId(NaN);\n    }\n\n\n    return [textInfo, start, pause, stop];\n}\n\n\n\nconst App = () => {\n    let [{currentText}, start, pause, stop] = usePrintText(`React + TypeScript = ♥`);\n\n\n    return (\n        <>\n            <p>{currentText}</p>\n            <button onClick={() => start()}>start</button>\n            <button onClick={() => pause()}>pause</button>\n            <button onClick={() => stop()}>stop</button>\n        </>\n    )\n}\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Универсальные компоненты","path":"Universalnye_komponenty"},"nextPage":{"title":"Контекст (Context)","path":"Kontekst_(Context)"}},"contentNavData":{"key":"Типизированные хуки","level":0,"index":54,"contentIndex":0,"section":"React","title":"Типизированные хуки","path":"Tipizirovannye_huki","elementId":"Tipizirovannye_huki","children":[{"key":"Типизированные хуки_0","index":0,"contentIndex":1,"level":1,"section":"React","title":"Предопределенные хуки - useState<T>()","path":"Predopredelennye_huki_-_useState<T>()","elementId":"Predopredelennye_huki_-_useState<T>()"},{"key":"Типизированные хуки_1","index":1,"contentIndex":2,"level":1,"section":"React","title":"Предопределенные хуки - useEffect() и useLayoutEffect()","path":"Predopredelennye_huki_-_useEffect()_i_useLayoutEffect()","elementId":"Predopredelennye_huki_-_useEffect()_i_useLayoutEffect()"},{"key":"Типизированные хуки_2","index":2,"contentIndex":3,"level":1,"section":"React","title":"Предопределенные хуки - useContext<T>()","path":"Predopredelennye_huki_-_useContext<T>()","elementId":"Predopredelennye_huki_-_useContext<T>()"},{"key":"Типизированные хуки_3","index":3,"contentIndex":4,"level":1,"section":"React","title":"Предопределенные хуки - useReducer<R>()","path":"Predopredelennye_huki_-_useReducer<R>()","elementId":"Predopredelennye_huki_-_useReducer<R>()"},{"key":"Типизированные хуки_4","index":4,"contentIndex":5,"level":1,"section":"React","title":"Предопределенные хуки - useCallback<T>()","path":"Predopredelennye_huki_-_useCallback<T>()","elementId":"Predopredelennye_huki_-_useCallback<T>()"},{"key":"Типизированные хуки_5","index":5,"contentIndex":6,"level":1,"section":"React","title":"Предопределенные хуки - useRef<T>()","path":"Predopredelennye_huki_-_useRef<T>()","elementId":"Predopredelennye_huki_-_useRef<T>()"},{"key":"Типизированные хуки_6","index":6,"contentIndex":7,"level":1,"section":"React","title":"Предопределенные хуки - useImperativeHandle<T, R>()","path":"Predopredelennye_huki_-_useImperativeHandle<T,R>()","elementId":"Predopredelennye_huki_-_useImperativeHandle<T,R>()"},{"key":"Типизированные хуки_7","index":7,"contentIndex":8,"level":1,"section":"React","title":"Предопределенные хуки - useMemo<T>()","path":"Predopredelennye_huki_-_useMemo<T>()","elementId":"Predopredelennye_huki_-_useMemo<T>()"},{"key":"Типизированные хуки_8","index":8,"contentIndex":9,"level":1,"section":"React","title":"Предопределенные хуки - useDebugValue<T>()","path":"Predopredelennye_huki_-_useDebugValue<T>()","elementId":"Predopredelennye_huki_-_useDebugValue<T>()"},{"key":"Типизированные хуки_9","index":9,"contentIndex":10,"level":1,"section":"React","title":"Пользовательский хук","path":"Polzovatelskii_huk","elementId":"Polzovatelskii_huk"}]},"pageDescription":"Типизированные хуки"},"__N_SSG":true}