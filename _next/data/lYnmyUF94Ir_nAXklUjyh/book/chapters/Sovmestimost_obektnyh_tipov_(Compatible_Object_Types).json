{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/040.(Типизация) Совместимость объектных типов (Compatible Object Types)/images/"},"sectionInfoAll":[{"key":"Совместимость объектных типов (Compatible Object Types)","elementId":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)","markdown":"# Совместимость объектных типов (Compatible Object Types)\n\nНа практике очень много недопониманий связано с темой совместимости объектных типов, постижение которой возможно лишь путем последовательного рассмотрения каждого отдельного случая в разных ситуациях. Именно этому и будет посвящена текущая глава, которая также уделит немало внимания другим сопутствующим нюансам."},{"key":"Совместимость объектных типов (Compatible Object Types)_0","elementId":"Vajno","markdown":"## Важно\n\nПришло время более подробно разобраться как компилятор определяет совместимость объектных типов. Как всегда, вначале, стоит напомнить, что в текущей главе, будет использоваться шаблон (`: Target = Source`), о котором более подробно шла речь в самом начале.\n\nНо, прежде чем начать погружение в тему _совместимости типов_ (_compatible types_), будет не лишним заметить, что подобный термин не определен спецификацией _TypeScript_. Тем не менее, в _TypeScript_ описано два типа совместимости. Помимо привычной _совместимости подтипов_ (_assignment subtype_), также существует _совместимость при присваивании_ (_assignment compatibility_). Они отличаются только тем, что правила совместимости при присваивании расширяют правила совместимости подтипов. Сделано это по нескольким причинам.\n\nПрежде всего поведение типа `any` не укладывается в рамки, определяемые стандартными правилами. Нестандартное поведение заключается в том, что помимо совместимости всех типов на основе обычных правил совместимости с типом `any`, сам тип `any` также совместим со всеми не являясь их подтипом.\n\n`````ts\nclass Animal {\n    public name: string;\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nlet animal: Animal = new Bird(); // Ok\nlet bird: Bird = new Animal(); // Ошибка, присваивание подтипа\n\nlet any: any = 0; // Ok\nlet number: number = any; // Ok -> any совместим с number\n`````\n\nКроме того, поведением двухсторонней совместимости наделен и числовой `enum`.\n\n`````ts\nenum NumberEnum {\n    A = 1\n}\n\nlet v1: number = NumberEnum.A;\nlet v2: NumberEnum.A = 0;\n`````"},{"key":"Совместимость объектных типов (Compatible Object Types)_1","elementId":"Sovmestimost_obektnyh_tipov_v_TypeScript","markdown":"## Совместимость объектных типов в TypeScript\n\nНачать тему о совместимости объектных типов стоит с повторения определения структурной типизации, которая лежит в основе _TypeScript_. Итак, _структурная типизация_ — это механизм сопоставления двух типов на основе их признаков. Под признаками понимаются идентификаторы типа и типы, которые с ними связаны (ассоциированы).\n\nПростыми словами, два типа будут считаться совместимыми не потому, что они связаны иерархическим деревом (наследование), а по тому, что в типе `S` (`: Target = Source`) присутствуют все идентификаторы, присутствующие в типе `T`. При этом, типы, с которыми они ассоциированы, должны быть совместимы.\n\n`````ts\nclass Bird {\n    public name: string;\n}\n\nclass Fish {\n    public name: string;\n}\n\nlet bird: Bird;\nlet fish: Fish;\n\nlet v1: Bird = fish; // Ok\nlet v2: Fish = bird; // Ok\n`````\n\nВ случаях, когда один тип, помимо всех признаков второго типа, также имеет любые другие, то он будет совместим со вторым типом, но не наоборот. Для обратной совместимости потребуется операция явного преобразования (приведения) типов.\n\n`````ts\nclass Bird {\n    public name: string;\n    public age: number;\n}\n\nclass Fish {\n    public name: string;\n}\n\nvar bird: Bird = new Fish(); // Error\nvar bird: Bird = new Fish() as Bird; // Ok\nlet fish: Fish = new Bird(); // Ok\n`````\n\nКроме того, два типа, совместимые по признакам идентификаторов, будут совместимы только в том случае, если типы, ассоциированные с идентификаторами, также совместимы.\n\n`````ts\nclass Bird {\n    public name: string;\n    public age: number;\n}\n\nclass Fish {\n    public name: string;\n}\n\nclass BirdProvider {\n    public data: Bird;\n}\n\nclass FishProvider {\n    data: Fish;\n}\n\nlet birdProvider: BirdProvider = new FishProvider(); // Error\nlet birdProvider: BirdProvider = new FishProvider() as FishProvider; // Error\nlet fishProvider: FishProvider = new BirdProvider(); // Ok\n`````\n\nСтоит заметить, что методы, объявленные в объектном типе, сравниваются не по правилам совместимости объектных типов данных. Про правила проверки функциональных типов речь пойдет немного позднее (глава [“Типизация - Совместимость функций”](../039.(Типизация)%20Совместимость%20функциональных%20типов%20(Compatible%20Function%20Types))). Поэтому комментарии к коду будут опущены.\n\n`````ts\nclass Bird {\n    public voice(repeat: number): void {}\n}\n\nclass Fish {\n    public voice(repeat: number, volume: number): void {}\n}\n\nlet v1: Bird;\nlet v2: Fish;\n\nlet v3: Bird = v2; // Error\nlet v4: Fish = v1; // Ok\n`````\n\nПо этой же причине без подробного рассмотрения останется и следующий пример, в котором происходит проверка типов, содержащих перегруженные методы, поскольку их совместимость идентична совместимости функциональных типов, рассматриваемых в следующей главе. Сейчас стоит только упомянуть, что в случаях, когда функция перегружена, проверка на совместимость происходит для каждой из сигнатур. Если существует несколько вариантов перегруженных сигнатур, с которыми может быть совместим тип источник, то выбрана будет та, что объявлена раньше.\n\n`````ts\nclass Bird {\n    public voice(repeat: number, volume: number): void;\n    public voice(repeat: number): void {}\n}\n\nclass Fish {\n    public voice(repeat: number, volume: number): void {}\n}\n\nlet v1: Bird\nlet v2: Fish\n\nlet v3: Bird = v2; // Ok\nlet v4: Fish = v1; // Ok\n`````\n\nТипы, которые различаются только _необязательными членами_, также считаются совместимыми.\n\n`````ts\nclass Bird {\n    public name: string;\n    public age?: number;\n    \n    public fly?(): void {}\n}\n\nclass Fish {\n    public name: string;\n    public arial?: string;\n    \n    public swim?(): void {}\n}\n\nlet bird: Bird;\nlet fish: Fish;\n\n// class Bird {name: string} === class Fish {name: string}\n\nlet v1: Bird = fish; // Ok\nlet v2: Fish = bird; // Ok\n`````\n\nДело в том, что необязательные параметры в объектных типах не берутся в расчет при проверке на совместимость. Однако это правило действует только в одну сторону. Тип содержащий обязательный член, несовместим с типом, у которого идентичный член является необязательным. Такое поведение логично, ведь в случае, когда необязательный член будет отсутствовать, тип, содержащий его, не будет удовлетворять условиям, заданным типом с обязательным членом.\n\n`````ts\nclass Bird {\n    public name: string;\n    public age?: number;\n}\n\nclass Fish {\n    public name: string;\n    public age:  number;\n}\n\nlet bird: Bird;\nlet fish: Fish;\n/**\n* Bird -> name -> поиск в Fish -> член найден -> Fish['name'] -> Ok\n* Bird -> age -> age опциональный член -> пропуск\n*/\nlet v1: Bird = fish; // Ok\n/**\n* Fish -> name -> поиск в Bird -> член найден -> Bird['name'] -> Ok\n* Fish -> age -> поиск в Bird -> член найден -> Bird['age'] не является опциональным -> Ошибка\n*/\nlet v2: Fish = bird; // Error\nlet v3: Fish = bird as Fish; // Ok\n`````\n\nСуществует еще одна неочевидность, связанная с необязательными членами. Если в целевом типе все члены объявлены как необязательные, он будет совместим с любым типом, который частично описывает его, при этом тип-источник может описывать любые другие члены. Помимо этого он будет совместим с типом, у которого описание отсутствует вовсе. Но он не будет совместим с типом, у которого описаны только отсутствующие в целевом типе члены. Такое поведение в _TypeScript_ называется _Weak Type Detection_ (_обнаружение слабого типа_). Типы, описание которых состоит только из необязательных членов, считаются слабыми типами.\n\n`````ts\nclass IAnimal {\n    name?: string;\n    age?: number;\n}\n\nclass Animal {}\nclass Bird { name: string; }\nclass Fish { age: number; }\nclass Insect { name: string; isAlive: boolean; }\nclass Reptile { age: number; isAlive: boolean; }\nclass Worm { isAlive: boolean; }\n\nlet animal: Animal;\nlet bird: Bird;\nlet fish: Fish;\nlet insect: Insect;\nlet reptile: Reptile;\nlet worm: Worm;\n\nlet v1: IAnimal = animal; // Ok\nlet v2: IAnimal = bird; // Ok\nlet v3: IAnimal = fish; // Ok\nlet v4: IAnimal = insect; // Ok\nlet v5: IAnimal = reptile; // Ok\nlet v6: IAnimal = worm; // Error\n`````\n\nОбобщенные типы, закрытые частично или полностью, участвуют в проверке на совместимость по характерным для _TypeScript_ правилам.\n\n`````ts\nclass Bird<T> {\n    public name: T;\n}\n\nclass Fish<T, S> {\n    public name: T;\n    public age: S;\n}\n\nlet v1: Bird<string>;\nlet v2: Bird<number>;\n\nlet v3: Bird<string> = v2; // Error\nlet v4: Bird<number> = v1; // Error\n\nlet v5: Bird<string>;\nlet v6: Fish<string, number>;\n\nlet v7: Bird<string> = v6; // Ok\nlet v8: Fish<string, number> = v5; // Error\n`````\n\nВ случаях, когда на совместимость проверяются типы, содержащие обобщенные методы, то их сравнение ничем не отличается от сравнения типов, содержащих необобщенные методы.\n\n`````ts\nclass Bird {\n    public voice<T>(repeat: T): void {}\n}\n\nclass Fish {\n    public voice<T, S>(repeat: T, volume: S): void {}\n}\n\nlet v1: Bird\nlet v2: Fish\n\nlet v3: Bird = v2; // Error\nlet v4: Fish = v1; // Ok\n`````\n\nНа фоне структурной типизации самое неоднозначное поведение возникает, когда описание типов полностью идентично, за исключением их модификаторов доступа. Если в типе описан хоть один член с отличным от `public` модификатором доступа, он не будет совместим ни с одним схожим типом, независимо от того, какие модификаторы доступа применены к его описанию.\n\n`````ts\nclass Bird {\n    private name: string;\n}\n\nclass Fish {\n    private name: string;\n}\n\nclass Insect {\n    protected name: string;\n}\n\nclass Reptile {\n    public name: string;\n}\n\nlet v1: Bird;\nlet v2: Fish;\nlet v3: Insect;\nlet v4: Reptile;\n\nlet v5: Bird = v2; // Error\nlet v6: Fish = v1; // Error\nlet v7: Insect = v1; // Error\nlet v8: Reptile = v1; // Error\n`````\n\nК счастью, разногласия, возникающие в структурной типизации при совместимости типов, представляемых классами, к членам которых применены модификаторы доступа, отличные от `public`, не распространяются на номинативную типизацию (глава [“Экскурс в типизацию - Совместимость типов на основе вида типизации”](../009.(Экскурс%20в%20типизацию)%20Совместимость%20типов%20на%20основе%20вида%20типизации)). Номинативная типизация может указывать на принадлежность к типу через иерархию наследования. Простыми словами, потомки будут совместимы с предками, у которых члены объявлены с помощью модификаторов доступа, отличных от `public`.\n\n`````ts\nclass Bird {\n    protected name: string;\n}\n\nclass Owl extends Bird {\n    protected name: string;\n}\n\nlet bird: Bird;\nlet owl: Owl;\n\nlet v1: Bird = owl; // Ok\nlet v2: Owl = bird; // Error\nlet v3: Owl = bird as Owl; // Ok\n`````\n\nВ типах, определяемых классами, при проверке на совместимость не учитываются конструкторы и статические члены (члены класса).\n\n`````ts\nclass Bird {\n    public static readonly DEFAULT_NAME: string = 'bird';\n    \n    constructor(name: string) {}\n}\n\nclass Fish {\n    public static toStringDecor(target: string): string {\n        return `[object ${target}]`;\n    }\n    \n    constructor(age: number) {}\n}\n\nlet v1: Bird\nlet v2: Fish\n\nlet v3: Bird = v2; // Ok\nlet v4: Fish = v1; // Ok\n`````\n\nКогда в качестве присваиваемого типа выступает экземпляр класса, то для того, что бы он считался совместим с типом, указанным в аннотации, в нем как минимум должны присутствовать все признаки этого типа. Также он может обладать дополнительными признаками, которые отсутствуют в типе указанном в аннотации.\n\n`````ts\nclass Bird {\n    public name: string;\n}\n\nclass Fish {\n    public name: string;\n    public age: number;\n}\n\nclass Insect {}\n\nlet equal: Bird = new Bird();\nlet more: Fish = new Fish();\nlet less: Insect = new Insect();\n\ninterface IAnimal {\n    name: string;\n}\n\nlet v1: IAnimal = new Bird(); // Ok -> одинаковые поля\nlet v2: IAnimal = new Fish(); // Ok -> в Fish полей больше\nlet v3: IAnimal = new Insect(); // Ошибка -> обязательные поля отсутствуют\nlet v4: IAnimal = equal; // Ok -> одинаковые поля\nlet v5: IAnimal = more; // Ok -> в Fish полей больше\nlet v6: IAnimal = less; // Ошибка -> обязательные поля отсутствуют\n\nfunction f1(p1: IAnimal): void {}\n\nf1(new Bird()); // Ok -> одинаковые поля\nf1(new Fish()); // Ok -> в Fish полей больше\nf1(new Insect()); // обязательные поля отсутствуют\n\nf1(equal); // Ok -> одинаковые поля\nf1(more); // Ok -> в Fish полей больше\nf1(less); // обязательные поля отсутствуют\n`````\n\nОднако, когда в качестве значения выступает объектный тип, созданный с помощью объектного литерала, поведение в некоторых случаях отличается от поведения присвоения экземпляров класса. В тех случаях, в которых объект объявляется непосредственно в операции присвоения, он будет совместим с типом, указанным в аннотации только, если он полностью ему соответствует. Другими словами, создаваемый с помощью литерала объект не должен содержать ни меньше ни больше членов, чем описано в типе указанном в аннотации (данное поведение можно изменить с помощью опции компилятора `--suppressExcessPropertyErrors`, глава [“Опции компилятора”](../060.(Компилятор)%20Опции%20компилятора)).\n\n`````ts\ninterface IAnimal {\n    name: string;\n}\n\nfunction f1(p1: IAnimal): void {}\n\nlet equal = { name: '' };\nlet more = { name: '', age: 0 };\nlet less = {};\n\nvar v1: IAnimal = { name: '' }; // Ok -> одинаковые поля\nlet v2: IAnimal = { name: '', age: 0 }; // Ошибка-> полей больше\nlet v3: IAnimal = {}; // Ошибка -> полей меньше\n\nlet v4: IAnimal = equal; // Ok -> одинаковые поля\nlet v5: IAnimal = more; // Ok -> полей больше\nlet v6: IAnimal = less; // Ошибка -> полей меньше\n\nf1({ name: '' }); // Ok -> одинаковые поля\nf1({ name: '', age: 0 }); // Ошибка -> больше полей\nf1({}); // Ошибка -> полей меньше\n\nf1(equal); // Ok -> одинаковые поля\nf1(more); // Ok -> полей больше\nf1(less); // Ошибка -> полей меньше\n`````\n\nОстается только добавить, что выбор в сторону структурной типизации был сделан по причине того, что подобное поведение очень схоже с поведением самого _JavaScript_, который реализует _утиную типизацию_. Можно представить удивление _Java_ или _C#_ разработчиков, которые впервые увидят структурную типизацию на примере _TypeScript_. Сложно представить выражение лица заядлых теоретиков, когда они увидят, что сущность птицы совместима с сущностью рыбы. Но не стоит угнетать ситуацию, выдумывая нереальные примеры, которые из-за структурной типизации приведут к немыслимым последствиям, поскольку вероятность того, что хотя бы один из них найдет олицетворение в реальных проектах настолько мала, что не стоит сил затраченных на их выдумывание."}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Вывод типов","path":"Vyvod_tipov"},"nextPage":{"title":"Совместимость функциональных типов (Compatible Function Types)","path":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)"}},"contentNavData":{"key":"Совместимость объектных типов (Compatible Object Types)","level":0,"index":40,"contentIndex":0,"section":"Типизация","title":"Совместимость объектных типов (Compatible Object Types)","path":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)","elementId":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)","children":[{"key":"Совместимость объектных типов (Compatible Object Types)_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Важно","path":"Vajno","elementId":"Vajno"},{"key":"Совместимость объектных типов (Compatible Object Types)_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Совместимость объектных типов в TypeScript","path":"Sovmestimost_obektnyh_tipov_v_TypeScript","elementId":"Sovmestimost_obektnyh_tipov_v_TypeScript"}]},"pageDescription":"Совместимость объектных типов (Compatible Object Types)"},"__N_SSG":true}