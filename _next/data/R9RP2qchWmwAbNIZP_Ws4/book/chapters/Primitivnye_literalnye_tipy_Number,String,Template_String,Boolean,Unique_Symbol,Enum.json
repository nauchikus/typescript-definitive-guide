{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/018.(Типы) Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum/images/"},"sectionInfoAll":[{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","elementId":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum","markdown":"# Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum\n\nПомимо обычных примитивных типов перешедших их _JavaScript_, в _TypeScript_ существуют так называемые _литеральные типы_, которые, как можно понять из названия, представляют литералы обычных примитивных типов. Число `5`, строка `“apple”`, логическое значение `true` или константа перечисления `Fruits.Apple` может выступать в качестве самостоятельного типа. Не сложно догадаться, что в качестве значений в таком случае могут выступать только литеральные эквиваленты самих типов, а также `null` и `undefined` (при `--strictNullChecks` со значением `false`).\n\nЛитеральные типы были созданы для того, что бы на этапе компиляции выявлять ошибки, возникающие из-за несоответствия значений заранее объявленных констант, как, например, номер порта или идентификатор динамического типа. Ранее такие ошибки можно было выявить только на этапе выполнения."},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_0","elementId":"Literalnyi_tip_Number_(Numeric_Literal_Types)","markdown":"## Литеральный тип Number (Numeric Literal Types)\n\nЛитеральный тип `number` должен состоять из литеральных значений, входящих в допустимый диапазон чисел от `Number.MIN_VALUE` (-9007199254740992) до `Number.MAX_VALUE` (9007199254740992), и может записываться в любой системе счисления (двоичной, восьмеричной, десятичной, шестнадцатеричной).\n\nОчень часто в программе фигурируют константные значения, ограничить которые одним типом недостаточно. Здесь на помощь и приходят литеральные типы данных. Сервер, конфигурацией которого разрешено запускаться на `80` или `42` порту, мог бы иметь метод, вызываемый с аргументами, включающими номер порта. Поскольку значение принадлежало бы к типу `number`, то единственный способ его проверки был возможен при помощи условия расположенном в блоке `if`, с последующим выбрасыванием исключения. Но подобное решение выявило бы несоответствие только на этапе выполнения. Помощь статической типизации в данном случае выражалась лишь в ограничении по типу `number`.\n\n`````ts\nconst port80: number = 80;\nconst port42: number = 42;\n\n// параметры ограничены лишь типом данных\nfunction start(port: number): void {\n    // блок if сообщит об ошибке только во время выполнения\n    if (port !== port80 || port !== port42) {\n        throw new Error(`port #${port} is not valid.`);\n    }\n}\n\nstart(81); // вызов с неправильным значением\n`````\n\nИменно для таких случаев и были введены литеральные типы данных. Благодаря литеральному типу `number` стало возможно выявлять ошибки не дожидаясь выполнения программы. В данном случае значение допустимых портов можно указать в качестве типа параметров функции.\n\n`````ts\nconst port80: number = 80;\nconst port42: number = 42;\n\nfunction start(port: 80 | 42): void {\n    // блок if сообщит об ошибке только во время выполнения\n    if (port !== port80 || port !== port42) {\n        throw new Error(`port #${port} is not valid.`);\n    }\n}\n\nstart(81); // ошибка выявлена на этапе компиляции!\n`````\n\nДля повышения семантики кода литеральные типы, представляющие номера порта, можно сокрыть за псевдонимом типа.\n\n`````ts\ntype ValidPortValue = 80 | 42;\n\nconst port80: number = 80;\nconst port42: number = 42;\n\nfunction start(port: ValidPortValue): void {\n    // блок if сообщит об ошибке только во время выполнения\n    if (port !== port80 || port !== port42) {\n        throw new Error(`port #${port} is not valid.`);\n    }\n}\n\nstart(81); // ошибка выявлена на этапе компиляции!\n`````\n\nКак уже было сказано ранее, литеральный тип `number` можно указывать в любой системе счисления.\n\n`````ts\ntype NumberLiteralType = 0b101 | 0o5 | 5 | 0x5;\n`````\n\nПримитивный литеральный тип `number` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_1","elementId":"Literalnyi_tip_String_(String_Literal_Types)","markdown":"## Литеральный тип String (String Literal Types)\n\nЛитеральный тип `string` может быть указан только строковыми литералами, заключенными в одинарные (`' '`) или двойные (`\" \"`) кавычки. Так называемые шаблонные строки, заключенные в обратные кавычки (`` ` ` ``), не могут быть использованы в качестве строкового литерального типа.\n\nВ ходе разработки, конвенциями проекта могут быть наложены ограничения на типы используемой анимации. Чтобы не допустить ошибочных идентификационных значений, их тип можно ограничить литеральным строковым типом.\n\n`````ts\nfunction animate(name: \"ease-in\" | \"ease-out\"): void {\n\n}\n\nanimate('ease-in'); // Ok\nanimate('ease-in-out'); // Error\n`````\n\nПримитивный литеральный тип `string` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_2","elementId":"Shablonnyi_literalnyi_tip_String_(Template_String_Literal_Types)","markdown":"## Шаблонный литеральный тип String (Template String Literal Types)\n\n_Шаблонный литеральный строковый тип_ — это тип, позволяющий на основе литеральных строковых типов динамически определять новый литеральный строковый тип. Простыми словами, это известный по _JavaScript_ механизм создания шаблонных строк только для типов.\n\n`````ts\ntype Type = \"Type\";\ntype Script = \"Script\";\n\n/**\n * type Message = \"I ❤️ TypeScript\"\n */\ntype Message = `I ❤️ ${Type}${Script}`;\n`````\n\nНо вся мощь данного типа раскрывается в момент определение нового типа на основе объединения (`union`). В подобных случаях новый тип будет также представлять объединение, элементы которого представляют все возможные варианты, полученные на основе исходного объединения. \n\n`````ts\ntype Sides = \"top\" | \"right\" | \"bottom\" | \"left\";\n\n/**\n * type PaddingSides = \"padding-top\" | \"padding-right\" | \"padding-bottom\" | \"padding-left\"\n */\ntype PaddingSides = `padding-${Sides}`;\n`````\n\nАналогичное поведение будет справедливо и для нескольких типов объединения.\n\n`````ts\ntype AxisX = \"top\" | \"bottom\";\ntype AxisY = \"left\" | \"right\";\n\n\n/**\n * type Sides = \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\n */\ntype Sides = `${AxisX}-${AxisY}`;\n\n/**\n * type BorderRadius = \"border-top-left-radius\" | \"border-top-right-radius\" | \"border-bottom-left-radius\" | \"border-bottom-right-radius\"\n */\ntype BorderRadius = `border-${Sides}-radius`;\n`````\n\nПоскольку с высокой долей вероятности в подобных операциях потребуется трансформация регистра строк, создателями данного механизма также были добавлены новые утилитарные алиасы типов - `Uppercase`, `Lowercase`, `Capitalize` и `Uncapitalize`.\n\n`````ts\ntype A = `${Uppercase<\"AbCd\">}`; // type A = \"ABCD\"\ntype B = `${Lowercase<\"AbCd\">}`; // type B = \"abcd\"\ntype C = `${Capitalize<\"abcd\">}`; // type C = \"Abcd\"\ntype D = `${Uncapitalize<\"Abcd\">}`; // type D = \"abcd\"\n`````\n\nПомимо этого, компилятор _TypeScript _ умеет понимать, что строка объявленная с помощью косых кавычек и сформированная при помощи значения ассоциированного с переменной, совместима с шаблонным строковым литеральным типом.\n\n`````ts\n/**\n * [*] Ok!\n */\nfunction f(param: string): `Hello ${string}` {\n  return `Hello ${param}`; // [*]\n}\n`````"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_3","elementId":"Literalnyi_Tip_Boolean_(Boolean_Literal_Types)","markdown":"## Литеральный Тип Boolean (Boolean Literal Types)\n\nЛитеральный тип `boolean` ограничен всего двумя литеральными значениями `true` и `false`.\n\nТак как литеральный тип `boolean` состоит всего из двух литеральных значений `true` и `false`, то детально разбирать, собственно, и нечего. Зато это прекрасный повод, что бы ещё раз повторить определение. Каждый раз, когда встречается часть кода, работа которого зависит от заранее определенного значения-константы, стоит подумать, можно ли ограничивать тип литеральным типом, сможет ли это повысить типобезопасность и семантику кода.\n\n`````ts\nfunction setFlag(flag: true | \"true\"): void {\n\n}\n`````\n\nПримитивный литеральный тип `boolean` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_4","elementId":"Literalnyi_Tip_Unique_Symbol_(unique_symbol)_unikalnyi_simvolnyi_tip","markdown":"## Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип\n\nНесмотря на то, что тип данных `symbol` является уникальным для программы, с точки зрения системы типов, он не может гарантировать типобезопасность.\n\n`````ts\nfunction f(key: symbol) {\n  // для успешного выполнения программы предполагается, что параметр key будет принадлежать к типу Symbol.for('key')...\n}\n\nf(Symbol.for('bad key')); // ... тем не менее функцию f() можно вызвать с любым другим символом\n`````\n\nДля того, что бы избежать подобного сценария, _TypeScript_ добавил новый примитивный литеральный тип `unique symbol`. `unique symbol` является подтипом `symbol` и указывается в аннотации с помощью литерального представления `unique symbol`.\n\nЭкземпляр `unique symbol` создается теми же способами, что и обычный `symbol` при помощи прямого вызова конструктора `Symbol()` или статического метода `Symbol.for()`. Но, в отличие от обычного `symbol`, `unique symbol` может быть указан только в аннотации константы (`const`) и поля класса (`static`) объявленного с модификатором `readonly`.\n\n`````ts\nconst v0: unique symbol = Symbol.for('key'); // Ok\nlet v1: unique symbol = Symbol.for('key'); // Error\nvar v2: unique symbol = Symbol.for('key'); // Error\n\nclass Identifier {\n    public static readonly f0: unique symbol = Symbol.for('key'); // Ok\n    \n    public static f1: unique symbol = Symbol.for('key'); // Error\n    public f2: unique symbol = Symbol.for('key'); // Error\n}\n`````\n\nКроме того, что бы ограничить значение до значения принадлежащего к типу `unique symbol`, требуется прибегать к механизму запроса типа, который подробно был рассмотрен  в главе [“Типы - Type Queries (запросы типа), Alias (псевдонимы типа)”](../017.(Типы)%20Type%20Queries%20(запросы%20типа),%20Alias%20(псевдонимы%20типа)).\n\n`````ts\nconst KEY: unique symbol = Symbol.for('key');\n\n// аннотация параметра и возвращаемого из функции типа при помощи механизма запросов типа\nfunction f(key: typeof KEY): typeof KEY {\n    return key;\n}\n\nf(KEY); // Ok\nf(Symbol('key')); // Error\nf(Symbol.for('key')); // Error\n`````\n\nПоскольку каждый `unique symbol` имеет собственное представление в системе типов, совместимыми могут считаться только символы, имеющие идентичную ссылку на объявление.\n\n`````ts\nconst KEY: unique symbol = Symbol.for('key');\nconst OTHER_KEY: unique symbol = Symbol.for('key');\n\nif (KEY === OTHER_KEY) { // Ошибка, unique symbol не равно unique symbol\n\n}\n\nfunction f(key: typeof KEY): typeof KEY {\n    return key;\n}\n\nlet key = KEY; // let key: symbol; // symbol !== unique symbol\n\nf(key); // Error\n`````\n\nТип `unique symbol` предназначен для аннотирования уникальных символьных литералов. С его помощью реализуется задуманное для _JavaScript_ поведение в типизированной среде _TypeScript_."},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_5","elementId":"Literalnyi_tip_Enum_(Enum_Literal_Types)","markdown":"## Литеральный тип Enum (Enum Literal Types)\n\nЛитеральный тип `enum` ограничивается литеральными значениями его констант. Это утверждение верно с одной оговоркой: правило совместимости типов для перечисления, у которого имеются константы с числовым значением, распространяется и на литеральный тип `enum`.\n\nНапомним, если перечисление составляют только строковые константы, то в качестве значения может быть присвоено только константы перечисления.\n\n`````ts\nenum Berries {\n    Strawberry = \"strawberry\",\n    Raspberry = \"raspberry\",\n    Blueberry = \"blueberry\"\n}\n\ntype RedBerry = Berries.Raspberry | Berries.Strawberry;\n\nvar berry: RedBerry = Berries.Strawberry; // Ok\nvar berry: RedBerry = Berries.Raspberry; // Ok\nvar berry: RedBerry = Berries.Blueberry; // Error\nvar berry: RedBerry = 123; // Error\nvar berry: RedBerry = \"strawberry\"; // Error\n`````\n\nВ том же случае, если в перечислении присутствует константа с числовым значением, в качестве значения может быть присвоено любое число.\n\n`````ts\nenum Fruits {\n    Apple,\n    Pear,\n    Banana = \"banana\"\n}\n\ntype FruitGrowOnTree = Fruits.Apple | Fruits.Pear;\n\nvar fruit: FruitGrowOnTree = Fruits.Apple; // Ok\nvar fruit: FruitGrowOnTree = Fruits.Pear; // Ok\nvar fruit: FruitGrowOnTree = Fruits.Banana; // Error\nvar fruit: FruitGrowOnTree = 123; // Ok!\nvar fruit: FruitGrowOnTree = \"apple\"; // Error\n`````\n\nПравила литеральных типов `enum` распространяются и на перечисления объявленных с помощью ключевого слова `const`.\n\nПримитивный литеральный тип `enum` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."}],"githubFileInfo":{"lastUpdate":1643269367000,"contributorAll":[{"name":"Romanov Yuri","avatar":"https://avatars.githubusercontent.com/u/31193144?v=4","bio":"","githubUrl":"https://github.com/darteil"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)"},"nextPage":{"title":"Object, Array, Tuple","path":"Object,Array,Tuple"}},"contentNavData":{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","level":0,"index":18,"contentIndex":0,"section":"Типы","title":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum","elementId":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum","children":[{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Литеральный тип Number (Numeric Literal Types)","path":"Literalnyi_tip_Number_(Numeric_Literal_Types)","elementId":"Literalnyi_tip_Number_(Numeric_Literal_Types)"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Литеральный тип String (String Literal Types)","path":"Literalnyi_tip_String_(String_Literal_Types)","elementId":"Literalnyi_tip_String_(String_Literal_Types)"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Шаблонный литеральный тип String (Template String Literal Types)","path":"Shablonnyi_literalnyi_tip_String_(Template_String_Literal_Types)","elementId":"Shablonnyi_literalnyi_tip_String_(Template_String_Literal_Types)"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_3","index":3,"contentIndex":4,"level":1,"section":"Типы","title":"Литеральный Тип Boolean (Boolean Literal Types)","path":"Literalnyi_Tip_Boolean_(Boolean_Literal_Types)","elementId":"Literalnyi_Tip_Boolean_(Boolean_Literal_Types)"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_4","index":4,"contentIndex":5,"level":1,"section":"Типы","title":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"Literalnyi_Tip_Unique_Symbol_(unique_symbol)_unikalnyi_simvolnyi_tip","elementId":"Literalnyi_Tip_Unique_Symbol_(unique_symbol)_unikalnyi_simvolnyi_tip"},{"key":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum_5","index":5,"contentIndex":6,"level":1,"section":"Типы","title":"Литеральный тип Enum (Enum Literal Types)","path":"Literalnyi_tip_Enum_(Enum_Literal_Types)","elementId":"Literalnyi_tip_Enum_(Enum_Literal_Types)"}]},"pageDescription":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum"},"__N_SSG":true}