{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/045.(Работа с типами) Условные типы (Conditional Types)/images/"},"sectionInfoAll":[{"key":"Условные типы (Conditional Types)","elementId":"Uslovnye_tipy_(Conditional_Types)","markdown":"# Условные типы (Conditional Types)\n\nОпределение динамических типов при помощи условных выражений, очень важный момент описания сложных типизированных сценариев, на примере которых, в данной главе будет рассмотрен механизм определения _условных типов_."},{"key":"Условные типы (Conditional Types)_0","elementId":"Uslovnye_tipy_na_praktike","markdown":"## Условные типы на практике\n\n_Условные типы_ (Conditional Types) — это типы, способные принимать одно из двух значений, основываясь на принадлежности одного типу к другому. Условные типы семантически схожи с тернарным оператором. \n\n`````ts\nT extends U ? T1 : T2\n`````\n\nВ блоке выражения с помощью ключевого слова `extends` устанавливается принадлежность к заданному типу. Если тип, указанный слева от ключевого слова `extends`, совместим с типом, указанным по правую сторону, то условный тип будет принадлежать к типу `T1`, иначе — к типу `T2`. Стоит заметить, что в качестве типов `T1` и `T2` могут выступать, в том числе и другие условные типы, что в свою очередь создаст цепочку условий определения типа.\n\nПомимо того, что невозможно переоценить пользу от условных типов, очень сложно придумать минимальный пример, который бы эту пользу проиллюстрировал. Поэтому в этой главе будут приведены лишь бессмысленные примеры, демонстрирующие принцип их работы.\n\n`````ts\ntype T0<T> = T extends number ? string : boolean;\n\nlet v0: T0<5>; // let v0: string\nlet v1: T0<'text'>; // let v1: boolean\n\ntype T1<T> = T extends number | string ? object : never;\n\nlet v2: T1<5>; // let v2: object\nlet v3: T1<'text'>; // let v3: object\nlet v4: T1<true>; // let v2: never\n\ntype T2<T> = T extends number ? \"Ok\" : \"Oops\";\n\nlet v5: T2<5>; // let v5: \"Ok\"\nlet v6: T2<'text'>; // let v6: \"oops\"\n\n// вложенные условные типы\n\ntype T3<T> =\n    T extends number ? \"IsNumber\" :\n    T extends string ? \"IsString\" :\n    \"Oops\";\n\nlet v7: T3<5>; // let v7: \"IsNumber\"   \nlet v8: T3<'text'>; // let v8: \"IsString\"\nlet v9: T3<true>; // let v9: \"Oops\"\n`````\n\nНужно быть внимательным, когда в условиях вложенных условных типов проверяются совместимые типы, так как порядок условий может повлиять на результат.\n\n`````ts\ntype T0<T> =\n    T extends IAnimal ? \"animal\" :\n    T extends IBird ? \"bird\" :\n    T extends IRaven ? \"raven\" :\n    \"no animal\";\n\ntype T1<T> =\n    T extends IRaven ? \"raven\" :\n    T extends IBird ? \"bird\" :\n    T extends IAnimal ? \"animal\" :\n    \"no animal\";\n\n// всегда \"animal\"\nlet v0:T0<IAnimal>; // let v0: \"animal\"\nlet v1: T0<IBird>; // let v1: \"animal\"\nlet v2: T0<IRaven>; // let v2: \"animal\"\n\n// никогда \"bird\"\nlet v3:T1<IRaven>; // let v3: \"raven\"\nlet v4: T1<IBird>; // let v4: \"raven\"\nlet v5: T1<IAnimal>; // let v5: \"animal\"\n`````\n\nЕсли в качестве аргумента условного типа выступает тип объединение (`Union`, глава [“Типы - Union, Intersection”](../016.(Типы)%20Типы%20-%20Union,%20Intersection)), то условия будут выполняться для каждого типа, составляющего объединенный тип.\n\n`````ts\ninterface IAnimal { type: string; }\ninterface IBird extends IAnimal { fly(): void; }\ninterface IRaven extends IBird {}\n\ntype T0<T> =\n    T extends IAnimal ? \"animal\" :\n    T extends IBird ? \"bird\" :\n    T extends IRaven ? \"raven\" :\n    \"no animal\";\n\ntype T1<T> =\n    T extends IRaven ? \"raven\" :\n    T extends IBird ? \"bird\" :\n    T extends IAnimal ? \"animal\" :\n    \"no animal\";\n\n// всегда \"animal\"\nlet v0:T0<IAnimal | IBird>; // let v0: \"animal\"\nlet v1: T0<IBird>; // let v1: \"animal\"\nlet v2: T0<IRaven>; // let v2: \"animal\"\n\n// никогда \"bird\"\nlet v3:T1<IAnimal | IRaven>; // let v3: \"raven\"\nlet v4: T1<IBird>; // let v4: \"raven\"\nlet v5: T1<IAnimal | IBird>; // let v5: \"animal\"\n`````\n\nПомимо конкретного типа, в качестве правого (от ключевого слова `extends`) операнда также может выступать другой параметр типа. \n\n`````ts\ntype T0<T, U> = T extends U ? \"Ok\" : \"Oops\";\n\nlet v0: T0<number, any>; // Ok\nlet v1:T0<number, string>; // Oops\n`````"},{"key":"Условные типы (Conditional Types)_1","elementId":"Raspredelitelnye_uslovnye_tipy_(Distributive_Conditional_Types)","markdown":"## Распределительные условные типы (Distributive Conditional Types)\n\nУсловные типы, которым в качестве аргумента типа устанавливается объединенный тип (`Union Type`, глава [“Типы - Union, Intersection”](../016.(Типы)%20Типы%20-%20Union,%20Intersection)), называются _распределительные условные типы_ (`Distributive Conditional Types`). Называются они так, потому, что каждый тип, составляющий объединенный тип, будет распределен таким образом, что бы выражение условного типа было выполнено для каждого. Это, в свою очередь может определить условный тип, как тип объединение.\n\n`````ts\ntype T0<T> =\n    T extends number ? \"numeric\" :\n    T extends string ? \"text\" :\n    \"other\";\n\nlet v0: T0<string | number>; // let v0: \"numeric\" | \"text\"\nlet v1: T0<string | boolean>; // let v1: \"text\" | \"other\"\n`````\n\nДля лучшего понимания процесса происходящего при определении условного типа в случае, когда аргумент типа принадлежит к объединению, стоит рассмотреть следующий минимальный пример, в котором будет проиллюстрирован условный тип так, как его видит компилятор.\n\n`````ts\n// так видит разработчик\n\ntype T0<T> =\n    T extends number ? \"numeric\" :\n    T extends string ? \"text\" :\n    \"other\";\n\nlet v0: T0<string | number>; // let v0: \"numeric\" | \"text\"\nlet v1: T0<string | boolean>; // let v1: \"text\" | \"other\"\n\n// так видит компилятор\n\ntype T0<T> =\n  // получаем первый тип, составляющий union тип (в данном случае number) и начинаем подставлять его на место T\n\n  number extends number ? \"numeric\" : // number соответствует number? Да! Определяем \"numeric\"\n  T extends string ? \"text\" :\n  \"other\"\n\n  | // закончили определять один тип, приступаем к другому, в данном случае string\n\n  string extends number ? \"numeric\" : // string соответствует number? Нет! Продолжаем.\n  string extends string ? \"text\" : // string соответствует string? Да! Определяем \"text\".\n  \"other\"\n\n  // Итого: условный тип T0<string | number> определен, как \"numeric\" | \"text\"\n`````"},{"key":"Условные типы (Conditional Types)_2","elementId":"Vyvod_tipov_v_uslovnom_tipe","markdown":"## Вывод типов в условном типе\n\nУсловные типы позволяют в блоке выражения объявлять переменные, тип которых будет устанавливать вывод типов. Переменная типа объявляется с помощью ключевого слова `infer` и, как уже говорилось, может быть объявлена исключительно в типе, указанном в блоке выражения расположенном правее оператора `extends`.\n\nЭто очень простой механизм, который проще сразу рассмотреть на примере.\n\nПредположим, что нужно установить, к какому типу принадлежит единственный параметр функции.\n\n`````ts\nfunction f(param: string): void {}\n`````\n\nДля этого нужно создать условный тип, в условии которого происходит проверка на принадлежность к типу-функции. Кроме того, аннотация типа единственного параметра этой функции, вместо конкретного типа, будет содержать объявление переменной типа.\n\n`````ts\ntype ParamType<T> = T extends (p: infer U) => void ? U : undefined;\n\nfunction f0(param: number): void {}\nfunction f1(param: string): void {}\nfunction f2(): void {}\nfunction f3(p0: number, p1: string): void {}\nfunction f4(param: number[]): void {}\n\nlet v0: ParamType<typeof f0>; // let v0: number\nlet v1: ParamType<typeof f1>; // let v1: string\nlet v2: ParamType<typeof f2>; // let v2: {}\nlet v3: ParamType<typeof f3>; // let v3: undefined\nlet v4: ParamType<typeof f4>; // let v4: number[]. Oops, ожидалось тип number вместо number[]\n\n// определяем новый тип, что бы разрешить последний случай\n\ntype WithoutArrayParamType<T> =\n    T extends (p: (infer U)[]) => void ? U :\n    T extends (p: infer U) => void ? U :\n    undefined;\n\n \nlet v5: WithoutArrayParamType<typeof f4>; // let v5: number. Ok\n`````\n\nПринципы определения переменных в условных типах продемонстрированные на примере функционального типа, идентичны и для объектных типов.\n\n`````ts\ntype ParamType<T> = T extends { a: infer A, b: infer B } ? A | B : undefined;\n\nlet v: ParamType<{ a: number, b:string }>; // let v: string | number\n`````"},{"key":"Условные типы (Conditional Types)_3","elementId":"Ogranichenie_infer_s_pomoshchu_extends","markdown":"## Ограничение infer с помощью extends\n\nУсловные типы позволяют творить настоящие чудеса, но иногда бывают немного громоздки. Для примера представьте сценарий при котором необходимо получить тип первого элемента кортежа, но только тогда, когда этот тип совместим со `string`.\n\n`````ts\ntype FirstNumberItem<T> =\n    T extends [infer S, ...unknown[]]\n        ? S extends number ? S : never\n        : never;\n\n// type A = number\ntype A = FirstNumberItem<[number, boolean, string]>;\n\n// type B = 100\ntype B = FirstNumberItem<[100, boolean, string]>;\n\n// type C = 100 | 500\ntype C = FirstNumberItem<[100 | 500, boolean]>;\n\n// type D = never\ntype D = FirstNumberItem<[boolean, number, number]>;\n`````\n\nНесмотря на то, что данный код решает возложенную на него задачу, вложенные условные выражения затрудняют его читаемость. исправить эту ситуацию призван механизма позволяющий ограничивать переменные типа `infer` конкретным типом при помощи ключевого слова `extends`.\n\n`````ts\ntype FirstNumberItem<T> =\n    T extends [infer S extends number, ...unknown[]] ? S : never;\n\n/**\n * ..здесь располагается код аналогичный предыдущему.\n */\n`````"}],"githubFileInfo":{"lastUpdate":1650966028000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-"},"nextPage":{"title":"Readonly, Partial, Required, Pick, Record","path":"Readonly,Partial,Required,Pick,Record"}},"contentNavData":{"key":"Условные типы (Conditional Types)","level":0,"index":45,"contentIndex":0,"section":"Работа с типами","title":"Условные типы (Conditional Types)","path":"Uslovnye_tipy_(Conditional_Types)","elementId":"Uslovnye_tipy_(Conditional_Types)","children":[{"key":"Условные типы (Conditional Types)_0","index":0,"contentIndex":1,"level":1,"section":"Работа с типами","title":"Условные типы на практике","path":"Uslovnye_tipy_na_praktike","elementId":"Uslovnye_tipy_na_praktike"},{"key":"Условные типы (Conditional Types)_1","index":1,"contentIndex":2,"level":1,"section":"Работа с типами","title":"Распределительные условные типы (Distributive Conditional Types)","path":"Raspredelitelnye_uslovnye_tipy_(Distributive_Conditional_Types)","elementId":"Raspredelitelnye_uslovnye_tipy_(Distributive_Conditional_Types)"},{"key":"Условные типы (Conditional Types)_2","index":2,"contentIndex":3,"level":1,"section":"Работа с типами","title":"Вывод типов в условном типе","path":"Vyvod_tipov_v_uslovnom_tipe","elementId":"Vyvod_tipov_v_uslovnom_tipe"},{"key":"Условные типы (Conditional Types)_3","index":3,"contentIndex":4,"level":1,"section":"Работа с типами","title":"Ограничение infer с помощью extends","path":"Ogranichenie_infer_s_pomoshchu_extends","elementId":"Ogranichenie_infer_s_pomoshchu_extends"}]},"pageDescription":"Условные типы (Conditional Types)"},"__N_SSG":true}