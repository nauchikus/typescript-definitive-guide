{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/043.(Типизация) Типизация в TypeScript/images/"},"sectionInfoAll":[{"key":"Типизация в TypeScript","elementId":"Tipizaciya_v_TypeScript","markdown":"# Типизация в TypeScript\n\nДанная глава поможет разработчикам не просто писать типизированный код, а делать это в полной мере осмысленно. Для этого необходимо ещё раз повторить все концепции нашедшие свое применение в языке _TypeScript_."},{"key":"Типизация в TypeScript_0","elementId":"Obshchie_svedeniya","markdown":"## Общие сведения\n\nСамое время взять паузу и рассмотреть типизацию в _TypeScript_ более детально через призму полученных знаний.\n\nИтак, что известно о _TypeScript_? _TypeScript_ это язык:\n\n1. Статически типизированный с возможностью динамического связывания\n2. Сильно типизированный\n3. Явно типизированный с возможностью вывода типов\n4. Совместимость типов в _TypeScript_ проходит по правилам структурной типизации \n5. Совместимость типов зависит от вариантности, чей конкретный вид определяется конкретным случаем\n\nКроме этого, существуют понятия являющиеся частью перечисленных, но в _TypeScript_, выделенные в отдельные определения. По этой причине они будут рассматриваться отдельно. Такими понятиями являются: \n\n1. Наилучший общий тип\n2. Контекстный тип\n\nНачнем с повторения определений в том порядке, в котором они были перечислены."},{"key":"Типизация в TypeScript_1","elementId":"Staticheskaya_tipizaciya_(static_typing)","markdown":"## Статическая типизация (static typing)\n\n_Статическая типизация_ обуславливается тем, что связывание с типом данных происходит на этапе компиляции и при этом тип не может изменится на протяжении всего своего существования.\n\nСтатическая типизация в _TypeScript_ проявляется в том, что к моменту окончания компиляции компилятору известно к какому конкретному типу принадлежат конструкции нуждающиеся в аннотации типа."},{"key":"Типизация в TypeScript_2","elementId":"Silnaya_tipizaciya_(strongly_typed)","markdown":"## Сильная типизация (strongly typed)\n\nЯзык с _сильной типизацией_ не позволяет операции с несовместимыми типами, а также не выполняет явного преобразования типов.\n\nСильная типизация в _TypeScript_ проявляет себя в случаях схожих с операцией сложения числа с массивом. В этом случае компилятор выбрасывает ошибки.\n\n`````ts\nconst value = 5 + []; // Error\n`````"},{"key":"Типизация в TypeScript_3","elementId":"Yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)","markdown":"## Явно типизированный (explicit typing) с выводом типов (type inference)\n\nЯзык с _явной типизацией_ предполагает, что указание типов будет выполнено разработчиком. Но современные языки с явной типизацией имеют возможность указывать типы неявно. Это становится возможным за счет механизма _вывода типов_.\n\nВывод типов — это возможность компилятора (интерпретатора) самостоятельно выводить-указывать тип данных на основе анализа выражения.\n\nВ _TypeScript_, если тип не указывается явно, компилятор с помощью вывода типов выводит и указывает тип самостоятельно.\n\n`````ts\nvar animal: Animal = new Animal(); // animal: Animal\nvar animal = new Animal(); // animal: Animal\n`````"},{"key":"Типизация в TypeScript_4","elementId":"Sovmestimost_tipov_(Type_Compatibility),strukturnaya_tipizaciya_(structural_typing)","markdown":"## Совместимость типов (Type Compatibility), структурная типизация (structural typing)\n\n_Совместимость типов_ — это механизм по которому происходит сравнение типов.\n\nПростыми словами, совместимость типов — это совокупность правил, на основе которых программа анализируя два типа данных, выясняет, производить над ними операции считая их совместимыми, либо для этого требуется преобразование. Правила совместимости типов делятся на три вида, один из которых имеет название структурная типизация.\n\n_Структурная Типизация_ — это принцип определяющий совместимость типов основываясь не на иерархии наследования или явной реализации интерфейсов, а на их описании.\n\nНесмотря на то, что `Bird` и `Fish` не имеют явно заданного общего предка, _TypeScript_ разрешает присваивать экземпляр класса `Fish` переменной с типом `Bird` (и наоборот).\n\n`````ts\nclass Bird { name; }\nclass Fish { name; }\n\nvar bird: Bird = new Fish();\nvar fish: Fish = new Bird();\n`````\n\nВ таких языках, как _Java_ или _C#_, подобное поведение недопустимо. В _TypeScript_ это становится возможно из-за структурной типизации.\n\nТак как совместимость типов происходит на основе их описания, в первом случае компилятор запоминает все члены типа `Fish`, и если он находит аналогичные члены в типе `Bird`, то они считаются совместимыми. То же самое компилятор проделывает тогда, когда во втором случае присваивает экземпляр класса `Bird` переменной с типом `Fish`. Так как оба типа имеют по одному полю, с одинаковым типом и идентификатором, то они считаются совместимыми.\n\nЕсли добавить классу `Bird` поле `wings`, то при попытке присвоить его экземпляр переменной с типом `Fish` возникнет ошибка, так как в типе `Fish` отсутствует после `wings`. Обратное действие, то есть присвоение экземпляра класса `Bird` переменной с типом `Fish`, ошибки не вызовет, так как в типе `Bird` будут найдены все члены объявленные в типе `Fish`.\n\n`````ts\nclass Bird { name; wings; }\nclass Fish { name; }\n\nvar bird: Bird = new Fish(); // Error\nvar fish: Fish = new Bird();\n`````\n\nСтоит добавить, что правилам структурной типизации подчиняются все объекты в _TypeScript_. А, как известно, в _JavaScript_ все, кроме примитивных типов, объекты. Это же утверждение верно и для _TypeScript_."},{"key":"Типизация в TypeScript_5","elementId":"Variantnost_(variance)","markdown":"## Вариантность (variance)\n\nПростыми словами, _вариантность_ — это механизм, определяющий правила на основе которых принимается решение о совместимости двух типов. Правила зависят от конкретного вида вариантности — _ковариантность_, _контравариантность_, _бивариантность_ и _инвариантность_. В случае с _TypeScript_ нас интересуют первые три.\n\nКовариантность позволяет большему типу быть совместимым с меньшим типом.\n\n`````ts\ninterface IAnimal { \n    type: string;\n}\n\ninterface IBird extends IAnimal { \n    fly(): void; \n}\n\nfunction f0(): IAnimal {\n    const v: IAnimal = { \n        type: 'animal' \n    };\n    \n    return v;\n}\n\nfunction f1(): IBird {\n    const v: IBird = { \n        type: 'bird', \n        fly() {\n        \n        } \n    };\n    \n    return v;\n}\n\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\n\nlet v0: T0 = f1; // Ok\nlet v1: T1 = f0; // Error\n`````\n\nКонтравариантность позволяет меньшему типу быть совместимым с большим типом.\n\n`````ts\ninterface IAnimal { \n    type: string; \n}\n\ninterface IBird extends IAnimal { \n    fly(): void; \n}\n\nfunction f0(p: IAnimal): void {}\nfunction f1(p: IBird): void {}\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Error\nlet v1: T1 = f0; // Ok\n`````\n\nБивариантность, доступная исключительно для параметров функций при условии, что флаг `--strictFunctionTypes` установлен в значение `false`, делает возможной совместимость как большего типа с меньшим, так и наоборот — меньшего с большим.\n\n`````ts\ninterface IAnimal { \n    type: string;\n}\n\ninterface IBird extends IAnimal { \n    fly(): void; \n}\n\nfunction f0(p: IAnimal): void {}\nfunction f1(p: IBird): void {}\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Ok, (--strictFunctionTypes === false)\nlet v1: T1 = f0; // Ok\n`````\n\nНе будет лишним упомянуть, что бивариантность снижает уровень типобезопасности программы и поэтому рекомендуется вести разработку с флагом `--strictFunctionTypes` установленным в значение `true`."},{"key":"Типизация в TypeScript_6","elementId":"Nailuchshii_obshchii_tip_(Best_common_type)","markdown":"## Наилучший общий тип (Best common type)\n\nС выводом типов в _TypeScript_ связано такое понятие, как наилучший общий тип. Это очень простое правило, название которого в большей мере раскрывает его суть. \n\nКак уже было сказано, _TypeScript_ — статически типизированный язык, и поэтому он пытается всему указать типы. В случаях, когда тип не был указан явно, в работу включается вывод типов. Предположим, что существует массив ссылка на который присваивается переменной объявленной без явного указания типа. Для того, что бы вывод типов смог вывести тип для переменной, ему нужно проанализировать данные хранящиеся в массиве (если они хранятся).\n\nДля примера представьте массив хранящий экземпляры классов `Animal`, `Elephant` и `Lion`, последние два из которых расширяют первый. И, кроме того, ссылка на данный массив присваивается переменной.\n\n`````ts\nclass Animal {}\nclass Elephant extends Animal {}\nclass Lion extends Animal {}\n\nconst animalAll = [\n    new Elephant(),\n    new Lion(),\n    new Animal()\n]; // animalAll: Animal[]\n`````\n\nТак как _TypeScript_ проверяет совместимость типов по правилам структурной типизации и все три типа идентичны с точки зрения их описания, то с точки зрения вывода типов все они идентичны. Поэтому он выберет в качестве типа тот который является более общим, то есть тип `Animal`.\n\nЕсли типу `Elephant` будет добавлено поле, например, хобот (`trunk`), что сделает его отличным от всех, то вывод типов будет вынужден указать массиву базовый для всех типов тип `Animal`.\n\n`````ts\nclass Animal {}\nclass Elephant extends Animal { trunk; }\nclass Lion extends Animal {}\n\nconst animalAll = [\n    new Elephant(),\n    new Lion (),\n    new Animal()\n]; // animalAll: Animal[]\n`````\n\nВ случае, если в массиве не будет присутствовать базовый для всех типов тип `Animal`, то вывод типов будет расценивать массив как принадлежащий к типу объединение `Elephant | Lion`.\n\n`````ts\nclass Animal {}\nclass Elephant extends Animal { trunk; }\nclass Lion extends Animal {}\n\nlet animalAll = [\n    new Elephant(),\n    new Lion()\n]; // animalAll: (Elephant | Lion)[]\n`````\n\n\nКак видно, ничего неожиданного или сложного в теме наилучшего общего типа совершенно нет."},{"key":"Типизация в TypeScript_7","elementId":"Kontekstnyi_tip_(Contextual_Type)","markdown":"## Контекстный тип (Contextual Type)\n\nКонтекстным называется тип, который при не явном объявлении указывается за счет декларации контекста, а не с помощью вывода типов.\n\nЛучшим примером контекстного типа может служить подписка `document` на событие мыши `mousedown`. Так как у слушателя события тип параметра `event` не указан явно, а также ему в момент объявления не было присвоено значение, то вывод типов должен был указать тип `any`. Но в данном случае компилятор указывает тип `MouseEvent`, потому, что именно он указан в декларации типа слушателя событий. В случае подписания `document` на событие `keydown`, компилятор указывает тип как `KeyboardEvent`.\n\n`````ts\ndocument.addEventListener('mousedown', (event) => { }); // event: MouseEvent\ndocument.addEventListener('keydown', (event) => { }); // event: KeyboardEvent\n`````\n\nДля того, что бы понять, как это работает, опишем случай из жизни зоопарка — представление с морским львом. Для этого создадим класс морской лев `SeaLion` и объявим в нем два метода: вращаться (`rotate`) и голос (`voice`).\n\n`````ts\nclass SeaLion {\n    rotate(): void { }\n    voice(): void { }\n}\n`````\n\nДалее, создадим класс дрессировщик `Trainer` и объявим в нем метод `addEventListener` с двумя параметрами: `type` с типом `string` и `handler` с типом `Function`. \n\n`````ts\nclass Trainer {\n    addEventListener(type: string, handler: Function) {}\n}\n`````\n\nЗатем объявим два класса события, выражающие команды дрессировщика `RotateTrainerEvent` и `VoiceTrainerEvent`. \n\n`````ts\nclass RotateTrainerEvent {}\nclass VoiceTrainerEvent {}\n`````\n\nПосле объявим два псевдонима (`type`) для литеральных типов `string`. Первому зададим имя `RotateEventType` и в качестве значения присвоим строковой литерал `\"rotate\"`. Второму зададим имя `VoiceEventType` и в качестве значения присвоим строковой литерал `\"voice\"`.\n\n`````ts\ntype RotateEventType = \"rotate\";\ntype VoiceEventType = \"voice\";\n`````\n\nТеперь осталось только задекларировать ещё два псевдонима типов для функциональных типов у обоих из которых будет один параметр `event` и отсутствовать возвращаемое значение. Первому псевдониму зададим имя `RotateTrainerHandler`, а его параметру установим тип `RotateTrainerEvent`. Второму псевдониму зададим имя `VoiceTrainerHandler`, а его параметру установим тип `VoiceTrainerEvent`.\n\n`````ts\ntype RotateTrainerHandler = (event: RotateTrainerEvent) => void;\ntype VoiceTrainerHandler = (event: VoiceTrainerEvent) => void;\n`````\n\nСоберём части воедино. Для этого в классе дрессировщик `Trainer` перегрузим метод `addEventListener`. У первого перегруженного метода параметр `type` будет иметь тип `RotateEventType`, а параметру `handler` укажем тип `RotateTrainerHandler`. Второму перегруженному методу в качестве типа параметра `type` укажем `VoiceEventType`, а параметру `handler` укажем тип `VoiceTrainerHandler`.\n\n`````ts\nclass Trainer {\n  addEventListener(type: RotateEventType, handler: RotateTrainerHandler);\n  addEventListener(type: VoiceEventType, handler: VoiceTrainerHandler);\n  addEventListener(type: string, handler: Function) {}\n}\n`````\n\nОсталось только убедиться, что все работает правильно. Для этого создадим экземпляр класса `Trainer` и подпишемся на события. Сразу можно увидеть подтверждение того, что цель достигнута. У слушателя события `RotateTrainerEvent` параметру `event` указан контекстный тип `RotateTrainerEvent`. А слушателю события `VoiceTrainerEvent` параметру `event` указан контекстный тип `VoiceTrainerEvent`.\n\n`````ts\ntype RotateTrainerHandler = (event: RotateTrainerEvent) => void;\ntype VoiceTrainerHandler = (event: VoiceTrainerEvent) => void;\n\ntype RotateEventType = \"rotate\";\ntype VoiceEventType = \"voice\";\n\nclass RotateTrainerEvent {}\nclass VoiceTrainerEvent {}\n\nclass SeaLion {\n    rotate(): void {}\n    voice(): void {}\n}\n\nclass Trainer {\n    addEventListener(type: RotateEventType, handler: RotateTrainerHandler);\n    addEventListener(type: VoiceEventType, handler: VoiceTrainerHandler);\n    addEventListener(type: string, handler: Function) {}\n}\n\nlet seaLion: SeaLion = new SeaLion();\n\nlet trainer: Trainer = new Trainer();\ntrainer.addEventListener('rotate', (event) => seaLion.rotate());\ntrainer.addEventListener('voice', (event) => seaLion.voice());\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Совместимость объединений (Union Types)","path":"Sovmestimost_obedinenii_(Union_Types)"},"nextPage":{"title":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-"}},"contentNavData":{"key":"Типизация в TypeScript","level":0,"index":43,"contentIndex":0,"section":"Типизация","title":"Типизация в TypeScript","path":"Tipizaciya_v_TypeScript","elementId":"Tipizaciya_v_TypeScript","children":[{"key":"Типизация в TypeScript_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Общие сведения","path":"Obshchie_svedeniya","elementId":"Obshchie_svedeniya"},{"key":"Типизация в TypeScript_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Статическая типизация (static typing)","path":"Staticheskaya_tipizaciya_(static_typing)","elementId":"Staticheskaya_tipizaciya_(static_typing)"},{"key":"Типизация в TypeScript_2","index":2,"contentIndex":3,"level":1,"section":"Типизация","title":"Сильная типизация (strongly typed)","path":"Silnaya_tipizaciya_(strongly_typed)","elementId":"Silnaya_tipizaciya_(strongly_typed)"},{"key":"Типизация в TypeScript_3","index":3,"contentIndex":4,"level":1,"section":"Типизация","title":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"Yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)","elementId":"Yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)"},{"key":"Типизация в TypeScript_4","index":4,"contentIndex":5,"level":1,"section":"Типизация","title":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"Sovmestimost_tipov_(Type_Compatibility),strukturnaya_tipizaciya_(structural_typing)","elementId":"Sovmestimost_tipov_(Type_Compatibility),strukturnaya_tipizaciya_(structural_typing)"},{"key":"Типизация в TypeScript_5","index":5,"contentIndex":6,"level":1,"section":"Типизация","title":"Вариантность (variance)","path":"Variantnost_(variance)","elementId":"Variantnost_(variance)"},{"key":"Типизация в TypeScript_6","index":6,"contentIndex":7,"level":1,"section":"Типизация","title":"Наилучший общий тип (Best common type)","path":"Nailuchshii_obshchii_tip_(Best_common_type)","elementId":"Nailuchshii_obshchii_tip_(Best_common_type)"},{"key":"Типизация в TypeScript_7","index":7,"contentIndex":8,"level":1,"section":"Типизация","title":"Контекстный тип (Contextual Type)","path":"Kontekstnyi_tip_(Contextual_Type)","elementId":"Kontekstnyi_tip_(Contextual_Type)"}]},"pageDescription":"Типизация в TypeScript"},"__N_SSG":true}