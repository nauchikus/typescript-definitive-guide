{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/044.(Работа с типами) Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -/images/"},"sectionInfoAll":[{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","elementId":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-","markdown":"# Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -\n\nДля того, что бы повысить уровень выявления ошибок и при этом сократить время разработки программы, создатели _TypeScript_ не прекращают радовать разработчиков добавлением новых возможностей для взаимодействия с типами данных. Благодаря усилиям разработчиков со всего земного шара, стало осуществимо получать тип объединение, полученный на основе как ключей конкретного типа, так и ассоциированных с ними типами. Кроме этого, возможность определять новый тип в процессе итерации другого типа, используя при этом различные выражения, превращает типизированный мир в фантастическую страну. Единственное, что требуется от разработчика, понимание этих процессов, которым и будет посвящена текущая глава."},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_0","elementId":"Zapros_kluchei_keyof","markdown":"## Запрос ключей keyof\n\nВ _TypeScript_ существует возможность выводить все публичные, не статические, принадлежащие типу ключи и на их основе создавать литеральный объединенный тип (`Union`). Для получения ключей нужно указать оператор `keyof`, после которого указывается тип, чьи ключи будут объединены в тип объединение `keyof Type`.\n\nОператор `keyof` может применяться к любому типу данных.\n\n`````ts\ntype AliasType = { f1: number, f2: string };\n\ninterface IInterfaceType {\n  f1: number;\n  f2: string;\n}\n\nclass ClassType {\n  f1: number;\n  f2: string;\n}\n\nlet v1: keyof AliasType; // v1: \"f1\" | \"f2\"\nlet v2: keyof IInterfaceType; // v2: \"f1\" | \"f2\"\nlet v3: keyof ClassType; // v3: \"f1\" | \"f2\"\nlet v4: keyof number; // v4: \"toString\" | \"toFixed\" | \"toExponential\" | \"toPrecision\" | \"valueOf\" | \"toLocaleString\"\n`````\n\nКак уже было замечено, оператор `keyof` выводит только публичные не статические ключи типа.\n\n`````ts\nclass Type {\n    public static fieldClass: number;\n    public static methodClass(): void {}\n    \n    private privateField: number;\n    protected protectedField: string;\n    public publicField: boolean;\n\n    public constructor() {}\n\n    public get property(): number { return NaN; }\n    public set property(value: number) {}\n    public instanceMethod(): void {}\n}\n\nlet v1: keyof Type; // a: \"publicField\" | \"property\" | \"instanceMethod\"\n`````\n\nВ случае, если тип данных не содержит публичных ключей, оператор `keyof` выведет тип `never`.\n\n`````ts\ntype AliasType = {};\n\ninterface IInterfaceType {}\n\nclass ClassType {\n    private f1: number;\n    protected f2: string;\n}\n\nlet v1: keyof AliasType; // v1: never\nlet v2: keyof IInterfaceType; // v2: never\nlet v3: keyof ClassType; // v3: never\nlet v4: keyof object; // v4: never\n`````\n\nОператор `keyof` также может использоваться в объявлении обобщенного типа данных. Точнее, с помощью оператора `keyof` можно получить тип, а затем расширить его параметром типа. Важно понимать, что в качестве значения по умолчанию может выступать только тип, совместимый с объединенным типом, полученным на основе ключей.\n\n`````ts\nfunction f1<T, U extends keyof T = keyof T>(): void {}\n`````\n\nНапоследок стоит упомянуть об одном не очевидном моменте: оператор `keyof` можно совмещать с оператором `typeof` (_Type Queries_).\n\n`````ts\nclass Animal {\n    public name: string;\n    public age: number;\n}\n\nlet animal = new Animal();\n\nlet type: typeof animal; // type: { name: string; age: number; }\nlet union: keyof typeof animal; // union: \"name\" | \"age\"\n`````"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_1","elementId":"Poisk_tipov_(Lookup_Types)","markdown":"## Поиск типов (Lookup Types)\n\nЕсли оператор `keyof` выбирает все доступные ключи, то с помощью поиска типов можно получить заданные типы по известным ключам. Получить связанный с ключом тип можно с помощью скобочной нотации, в которой через оператор вертикальная черта `|` будут перечислены от одного и более ключа, существующего в типе. В качестве типа данных могут выступать только интерфейсы, классы и в ограниченных случаях операторы типа.\n\nВ случаях, когда в качестве типа данных выступает интерфейс, то получить можно все типы, без исключения. При попытке получить тип несуществующего ключа возникнет ошибка.\n\n`````ts\ninterface IInterfaceType {\n    p1: number;\n    p2: string;\n}\n\nlet v1: IInterfaceType['p1']; // v1: number\nlet v2: IInterfaceType['p2']; // v2: string\nlet union: IInterfaceType['p1' | 'p2']; // union: number | string\nlet notExist: IInterfaceType['notExist']; // Error -> Property 'notExist' does not exist on type 'IAnimal'\n`````\n\nЕсли в качестве типа выступает класс, то получить типы можно только у членов его экземпляра. При попытке получить тип несуществующего члена возникнет ошибка.\n\n`````ts\nclass ClassType {\n    public static publicFieldClass: number;\n    \n    public publicInstanceField: number;\n    protected protectedInstanceField: string;\n    private privateInstanceField: boolean;\n    \n    public get propertyInstance(): number { return NaN; }\n    public set propertyInstance(value: number) {}\n    \n    public methodInstance(): void {}\n}\n\nlet publicFieldClass: ClassType['publicFieldClass']; // Error\n\nlet publicFieldInstance: ClassType['publicInstanceField']; // publicFieldInstance: number\nlet protectedFieldInstance: ClassType['protectedInstanceField']; // protectedFieldInstance: string\nlet privateFieldInstance: ClassType['privateInstanceField']; // privateFieldInstance: boolean\nlet propertyInstance: ClassType['propertyInstance']; // propertyInstance: number\nlet methodInstance: ClassType['methodInstance']; // methodInstance: () => void\n\nlet notExist: ClassType['notExist']; // Error\n`````\n\nНельзя переоценить вклад возможностей поиска типов, которые пришлись на динамическую часть типизированного мира _TypeScript_. Благодаря поиску типов в паре с оператором `keyof` появилась возможность, позволяющая выводу типов устанавливать связь между динамическими ключами и их типами. Это в свою очередь позволяет производить дополнительные проверки, которые повышают типобезопасность кода.\n\n`````ts\nclass Model<T> {\n    constructor(private entity: T) {}\n    \n    public getValueByName<U extends keyof T>(key: U): T[U] {\n        return this.entity[key];\n    }\n}\n\ninterface IAnimalModel {\n    id: string;\n    age: number;\n}\n\nlet json = '\"{\"id\": \"animal\", \"age\": 0}\"';\nlet entity: IAnimalModel = JSON.parse(json);\n\nlet userModel: Model<IAnimalModel> = new Model(entity);\n\nlet id = userModel.getValueByName('id'); // id: string\nlet age = userModel.getValueByName('age'); // age: number\n`````"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_2","elementId":"Sopostavlenie_tipov_(Mapped_Types)","markdown":"## Сопоставление типов (Mapped Types)\n\nСопоставленные типы — это типы данных, которые при помощи механизма итерации модифицируют лежащие в основе конкретные типы данных.\n\nВ _TypeScript_ существует возможность определения типа, источником ключей которого выступает множество определяемое литеральными строковыми типами. Подобные типы обозначаются как _сопоставленные типы_ (`Mapped Types`) и определяются исключительно на основе псевдонимов типов (`Type Alias`), объявление которых осуществляется при помощи ключевого слова `type`. Тело сопоставимого типа, заключенное в фигурные скобки `{}`, включает в себя одно единственное выражение, состоящие из двух частей разделенных двоеточием. \n\n`````ts\ntype СопоставимыйТип = {\n    ЛеваяЧастьВыражения: ПраваяЧастьВыражения;\n}\n`````\n\nВ левой части выражения располагается обрамленное в квадратные скобки `[]` выражение, предназначенное для работы с множеством, а в правой части определяется произвольный тип данных.\n\n`````ts\ntype СопоставимыйТип = {\n    [ВыражениеДляРаботыСМножеством]: ПроизвольныйТипДанных;\n}\n`````\n\nВыражение описывающее итерацию элементов представляющих ключи, также состоит из двух частей, разделяемых оператором `in` (`[ЛевыйОперанд in ПравыйОперанд]`). В качестве левого операнда указывается произвольный идентификатор, который в процессе итерации, последовательно будет ассоциирован со значениями множества указанного в правой части (`[ПроизвольныйИдентификатор in Множество]`).\n\n\n`````ts\ntype СопоставимыйТип = {\n    [ПроизвольныйИдентификатор in Множество]: ПроизвольныйТипДанных;\n}\n`````\n\nКак уже было сказано, в роли идентификатора может выступать любой идентификатор.\n\n`````ts\ntype СопоставимыйТип = {\n    [Key in Множество]: ПроизвольныйТипДанных;\n}\n\n// или\n\ntype СопоставимыйТип = {\n    [K in Множество]: ПроизвольныйТипДанных;\n}\n`````\n\nМножество может быть определенно как единственным литеральным строковым типом (`ElementLiteralStringType`), так и его множеством, составляющим тип объединение (`Union Type`) (`FirstElementLiteralStringType | SecondElementLiteralStringType`).\n\n`````ts\n// множество с одним элементом\ntype СопоставимыйТип = {\n    [K in \"FirstLiteralStringType\"]: ПроизвольныйТипДанных;\n}\n\n// или \n\n// множество с несколькими элементами\ntype СопоставимыйТип = {\n    [K in \"FirstLiteralStringType\" | \"SecondLiteralStringType\"] : ПроизвольныйТипДанных;\n}\n\n// или \n\ntype LiteralStringType = \"FirstLiteralStringType\" | \"SecondLiteralStringType\";\n\n// множество с несколькими элементами вынесенных в тип Union\ntype СопоставимыйТип = {\n    [K in LiteralStringType]: ПроизвольныйТипДанных;\n}\n`````\n\nРезультатом определения сопоставленного типа является новый объектный тип, состоящий из ключей ассоциированных с произвольным типом.\n\n`````ts\ntype ABC = \"a\" | \"b\" | \"c\";\n\ntype ABCWithString = {\n    [K in ABC]: string;\n}\n\n// или\n\ntype ABCWithNumber = {\n    [K in ABC]: number;\n}\n\ndeclare function abcWithString(params: ABCWithString): void;\n\nabcWithString({a: '', b: '', c: ''}); // Ok\nabcWithString({}); // Error, missing properties 'a', 'b', 'c'\nabcWithString({a: '', b: ''}); // Error, missing property 'c'\nabcWithString({a: '', b: '', c: 5}); // Error, type number is not type string\n\ndeclare function abcWithNumber(params: ABCWithNumber): void;\n\nabcWithNumber({a: 0, b: 0, c: 0}); // Ok\nabcWithNumber({}); // Error, missing properties 'a', 'b', 'c'\nabcWithNumber({a: 0, b: 0}); // Error, missing property 'c'\nabcWithNumber({a: 0, b: 0, c: ''}); // Error, type string is not type number\n`````\n\nОт статического указания итерируемого типа мало пользы, поэтому `Mapped Types` лучше всего раскрывают свой потенциал при совместной работе с известными к этому моменту запросом ключей (`keyof`) и поиском типов (`Lookup Types`), оперирующих параметрами типа (`Generics`).\n\n`````ts\ntype MappedType<T> = {\n    [K in keyof T]: T[K];\n}\n\n// или\n\ntype MappedType<T, U extends keyof T> = {\n    [K in U]: T[K];\n}\n`````\n\nВ первом случае в выражении `[P in keyof T]: T[P];` первым действием выполняется вычисление оператора `keyof` над параметром типа `T`. В его результате ключи произвольного типа преобразуются во множество, то есть в тип `Union`, элементы которого принадлежат к литеральному строковому типу данных. Простыми словами операция `keyof T` заменяется на только, что полученный тип `Union` `[P in Union]: T[P];`, над которым на следующим действии выполняется итерация.\n\nВо втором случае `MappedType<T, U extends keyof T>` оператор `keyof` также преобразует параметр типа `T` в тип `Union`, который затем расширяет параметр типа `U`, тем самым получая все его признаки, необходимые для итерации в выражении `[K in U]`.\n\nС полученным в итерации `[K in U]` ключом `K` ассоциируется тип ассоциированный с ним в исходном типе и полученный с помощью механизма поиска типов `T[K]`. \n\nСовокупность описанных механизмов позволяет определять не только новый тип, но и создавать модифицирующие типы, которые будут способны добавлять модификаторы, как например `readonly` или `?:`.\n\n`````ts\ntype ReadonlyMember<T> = {\n    readonly [P in keyof T]: T[P];\n}\n\ninterface IAnimal {\n    name: string;\n    age: number;\n}\n\nlet animal: ReadonlyMember<IAnimal>;  // animal: { readonly name: string; readonly age: number; }\n`````\n\nКак уже было замечено, в правой части выражения можно указать любой тип данных, в том числе и объединение, включающего тип полученный при помощи механизма поиска типов.\n\n`````ts\ntype Nullable<T> = {\n    [P in keyof T]: T[P] | null;\n}\n\ntype Stringify<T> = {\n    [P in keyof T]: string;\n}\n\ninterface IAnimal {\n    name: string;\n    age: number;\n}\n\nlet nullable: Nullable<IAnimal>; // { name: string | null; age: number | null; }\nlet stringify: Stringify<IAnimal>; // { name: string; age: string; }\n`````\n\nСопоставленные типы не могут содержать более одной итерации в типе, а также не могут содержать объявление других членов.\n\n`````ts\ntype AliasType<T, U> = {\n    [P in keyof T]: T[P]; // Ok\n    [V in keyof U]: U[V]; // Error\n    f1: number; // Error\n}\n`````\n\nК тому же в *TypeScript* существует несколько готовых типов, таких как `Readonly<T>`, `Partial<T>`, `Record<K, T>` и `Pick<T, K>` (глава [“Расширенные типы - Readonly, Partial, Required, Pick, Record”](../044.(Расширенные%20типы)%20Readonly,%20Partial,%20Required,%20Pick,%20Record)).\n\n\nКроме того, сопоставленные типы вместе с _шаблонными литеральными строковыми типами_ способны переопределить исходные ключи при помощи ключевого слова `as` указываемого после строкового перечисления.\n\n`````ts\ntype T = {\n    [K in STRING_VALUES as NEW_KEY]: K // K преобразованный\n}\n`````\n\nТаким образом совмещая данный механизм с _шаблонными литеральными строковыми типами_ можно добиться переопределения исходных ключей.\n\n`````ts\ntype ToGetter<T> = `get${capitalize T}`;\ntype Getters<T> = {\n    [K in keyof T as ToGetter<K>]: () => T[K];\n}\n\ntype Person = {\n    name: string;\n    age: number;\n}\n\n/**\n * type T = {\n *  getName: () => string;\n *  getAge: () => number;\n * }\n */\ntype T = Getters<Person>\n`````"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_3","elementId":"Prefiksy_+_i_-_v_sopostavlennyh_tipah","markdown":"## Префиксы + и - в сопоставленных типах\n\nСопоставленные типы позволяют добавлять модификаторы, но не позволяют их удалять, что в свою очередь имеет большое значение в случае с гомоморфными типами, которые по умолчанию сохраняют модификаторы своего базового типа (гомоморфные типы будут рассмотрены в главе [“Расширенные типы - Readonly, Partial, Required, Pick, Record”](../044.(Расширенные%20типы)%20Readonly,%20Partial,%20Required,%20Pick,%20Record)).\n\nДля разрешения данной проблемы, к модификаторам в типах сопоставления, были добавлены префиксы `+` и `-`, с помощью которых реализуется поведение модификатора — добавить (`+`) или удалить (`-`).\n\n`````ts\ntype AddModifier<T> = { \n    +readonly [P in keyof T]+?: T[P]; // добавит модификаторы readonly и ? (optional)\n}; \ntype RemoveModifier<T> = { \n    -readonly [P in keyof T]-?: T[P]; // удалит модификаторы readonly и ? (optional)\n}; \n\ninterface IWithoutModifier { field: string; }\ninterface IWithModifier { readonly field?: string; }\n\n/**\n * Добавление модификаторов\n * было { field: string; }\n * стало { readonly field?: string; }\n */\nlet addingModifier: AddModifier<IWithoutModifier> = { field: '' };\nlet withoutModifier: IWithoutModifier = { field: '' };\n\naddingModifier.field = ''; // Error\nwithoutModifier.field = ''; // Ok\n\n/**\n * Удаление модификаторов\n * было { readonly field?: string; }\n * стало { field: string; }\n */\nlet removingModifier: RemoveModifier<IWithModifier> = { field: '' };\nlet withModifier: IWithModifier = { field: '' };\n\nremovingModifier.field = ''; // Ok\nwithModifier.field = ''; // Error\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Типизация в TypeScript","path":"Tipizaciya_v_TypeScript"},"nextPage":{"title":"Условные типы (Conditional Types)","path":"Uslovnye_tipy_(Conditional_Types)"}},"contentNavData":{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","level":0,"index":44,"contentIndex":0,"section":"Работа с типами","title":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-","elementId":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-","children":[{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_0","index":0,"contentIndex":1,"level":1,"section":"Работа с типами","title":"Запрос ключей keyof","path":"Zapros_kluchei_keyof","elementId":"Zapros_kluchei_keyof"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_1","index":1,"contentIndex":2,"level":1,"section":"Работа с типами","title":"Поиск типов (Lookup Types)","path":"Poisk_tipov_(Lookup_Types)","elementId":"Poisk_tipov_(Lookup_Types)"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_2","index":2,"contentIndex":3,"level":1,"section":"Работа с типами","title":"Сопоставление типов (Mapped Types)","path":"Sopostavlenie_tipov_(Mapped_Types)","elementId":"Sopostavlenie_tipov_(Mapped_Types)"},{"key":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -_3","index":3,"contentIndex":4,"level":1,"section":"Работа с типами","title":"Префиксы + и - в сопоставленных типах","path":"Prefiksy_+_i_-_v_sopostavlennyh_tipah","elementId":"Prefiksy_+_i_-_v_sopostavlennyh_tipah"}]},"pageDescription":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -"},"__N_SSG":true}