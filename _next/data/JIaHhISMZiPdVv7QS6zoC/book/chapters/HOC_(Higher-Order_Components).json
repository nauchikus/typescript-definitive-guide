{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/056.(React) HOC (Higher-Order Components)/images/"},"sectionInfoAll":[{"key":"HOC (Higher-Order Components)","elementId":"HOC_(Higher-Order_Components)","markdown":"# HOC (Higher-Order Components)\n\nНастало время рассмотреть со всех сторон механизм предназначенный для расширения функциональных возможностей компонента с помощью компонента-обертки обозначаемого как _Higher-Order Components_ или сокращенно _HOC_."},{"key":"HOC (Higher-Order Components)_0","elementId":"Opredelenie_hoc","markdown":"## Определение hoc\n\nРаньше, при разработке _React_ приложений разработчикам часто приходилось создавать конструкцию, известную в _react_ сообществе, как _HOC_ (_Higher-Order Components_).\n\n_HOC_ — это функция, которая на входе принимает один компонент, а на выходе возвращает новый с более расширенным функционалом. Другими словами, _hoc_ — это функция, ожидающая в качестве параметров компонент (назовем его входным), который оборачивается в другой, объявленный в теле функции, компонент, выступающий в роли возвращаемого из функции значения (назовем его выходным). Слово “оборачивание”, применимое относительно компонентов, означает, что один компонент отрисовывает (рендерит) другой компонент, со всеми вытекающими из этого процесса (проксирования). За счет того, что входной компонент оборачивается в выходной, достигается расширение его и/или общего функционала. Кроме того, это позволяет устанавливать входному компоненту как зависимости, так и данные, полученные из внешних сервисов."},{"key":"HOC (Higher-Order Components)_1","elementId":"Opredelenie_hoc_na_osnove_funkcionalnogo_komponenta","markdown":"## Определение hoc на основе функционального компонента\n\nВ качестве примера реализуем сценарий при котором пропсы _компонента обертки_ определяемого в теле _hoc_ разделяются на две категории. Первая необходима исключительно самому компоненту-обертке для генерации новых пропсов, которые в дальнейшем будут объединены с пропсами относящихся ко второй категории и установлены _оборачиваемому компоненту_. \n\nНачать стоит с детального рассмотрения сигнатуры универсальной функции, ожидающей в качестве единственного параметра типа тип `WrappedProps` представляющий пропсы предназначенные исключительно оборачиваемому-компоненту ссылка на который доступна через единственный параметр `WrappedComponent`. `WrappedComponent` может принадлежать, как к функциональному `FC<T>`, так и классовому типу `ComponentClass<T>`, поэтому указываем ему в аннотации обобщенный тип `Component<P>` пропсы которого, помимо типа представленного аргументом типа `WrappedProps`, должны принадлежать ещё и к типу `WrapperForWrappedProps` описывающего значения создаваемые и устанавливаемые компонентом-оберткой.\n\nСтоит упомянуть, что тип`Component<P>` является типом объединением представляющим классовые и функциональные _React_ компоненты.\n\nПоскольку в нашем конкретном примере _функция hoc_ в качестве компонента-обертки определяет функциональный компонент, тип возвращаемого значения указан соответствующим образом `FC<T>`. Пропсы компонента-обертки должны принадлежать к нескольким типам одновременно поскольку для его работы требуются не только пропсы необходимые исключительно ему (`WrapperProps`), но и пропсы которые он лишь пробрасывает оборачиваемому-компоненту (`WrappedProps`). Поэтому аргумент типа представляющего возвращаемое значение является типом пересечение `WrappedProps & WrapperProps`.\n\n\n`````ts\n                /**[0] */\nimport React, {ComponentType} from \"react\";\n\n\n/**[1] */\nexport interface WrapperProps {\n    a: number;\n    b: string;\n}\n/**[2] */\nexport interface WrapperForWrappedProps {\n    c: boolean;\n}\n\n/**\n * [0] Импортируем обобщенный тип Component<P> представляющий\n * объединение классового и функционального React компонента.\n * [1] WrapperProps описывает данные необходимые\n * исключительно компоненту-обертке определяемому\n * внутри функции hoc, который генерирует\n * и устанавливает данные принадлежащие к типу \n * WrapperForWrappedProps [2] обертываемому-компоненту.\n */\n\n\n                /**[3]      [4] */\nexport function withHoc<WrappedProps>(\n        /**[5]              [6]         [7]                 [8] */\n    WrappedComponent: ComponentType<WrappedProps & WrapperForWrappedProps>)\n       /**[9]    [10]           [11] */\n        : FC<WrappedProps & WrapperProps>\n\n/**\n * [3] определение универсальной функции hoc\n * чей единственный параметр типа WrappedProps [4]\n * представляет часть пропсов обертываемого-компонента, а их оставшаяся часть, генерируемая\n * компонентом-оберткой определенным в теле hoc, к типу WrapperForWrappedProps.\n * \n * Единственный параметр hoc WrappedComponent [5] принадлежит\n * к обобщенному типу Component<P> [6], которому в качестве аргумента типа установлен\n * тип пересечение определяемый типами WrappedProps [7] и WrapperForWrappedProps [8].\n * \n * Тип возвращаемого hoc значения обозначен как функциональный компонент [9] который по мимо пропсов\n * устанавливаемых разработчиком и прокидываемых компонентом-оберткой WrappedProps [10] ожидает ещё и пропсы\n * генерируемые и устанавливаемые компонентом-оберткой [11].\n * \n * [!] принадлежность возвращаемого hoc значения к функциональному типу указана лишь по причине того\n *, что в нашем пример hoc возвращает именно его, а не классовый компонент. \n */\n`````\n\nПоскольку пример является минималистическим реализация тела _hoc_ будет включать в себя лишь определение компонента-обертки выступающего в качестве возвращаемого значение. Тип компонента-обертки принадлежит к функциональному компоненту пропсы которого должны соответствовать типам описывающих как пропсы необходимые исключительно самому компоненту-обертке, так и оборачиваемому-компоненту. В теле компонента-обертки происходит разделение полученных пропсов на две части. Одна предназначается исключительно самому компоненту-обертке и служит для определения значений предназначенных для объединения со второй частью. Объединенные значения устанавливаются в качестве пропсов оборачиваемому-компоненту ссылка на который доступна через единственный параметр функции _hoc_. Стоит обратить внимание, что поскольку вторая часть пропсов образуется как остаточные параметры полученные при деструктуризации, то их тип принадлежит к типу `Pick<T, K>`, который для совместимости с типом описывающим прокидываемые компонентом-оберткой пропсы необходимо сначала привести к типу `unknown`, а уже затем к конкретному типу `WrappedProps`.\n\n\n`````ts\nimport React, {ComponentType} from \"react\";\n\n\nexport interface WrapperProps {\n    a: number;\n    b: string;\n}\nexport interface WrapperForWrappedProps {\n    c: boolean;\n}\n\nexport function withHoc<WrappedProps>(\n    WrappedComponent: ComponentType<WrappedProps & WrapperForWrappedProps>)\n        : FC<WrappedProps & WrapperProps> {\n\n                    /**[0]         [1]    [2]             [3] */\n            const WrapperComponent:FC<WrappedProps & WrapperProps> = props => {\n                  /**[4]            [5] */\n                let {a, b, ...wrappedOnlyProps} = props;\n                        /**[6] */\n                let wrapperToWrappedProps = {\n                    c: true\n                };\n                       /**[7]                      [8]                     [9]            [10]         [11] */\n                let wrappedFullProps = {...wrapperToWrappedProps, ...wrappedOnlyProps as unknown as WrappedProps};\n\n                            /**[12]               [13] */\n                return <WrappedComponent {...wrappedFullProps} />\n            }\n\n                    /**[14] */\n            return WrapperComponent;\n}\n\n/**\n * [0] определение компонента-обертки принадлежащего\n * к типу функционального компонента [1] пропсы которого\n * одновременно принадлежат к типам описывающих пропсы предназначаемые\n * исключительно обертываемому-компоненту WrappedProps [2] и исключительно\n * компоненту-обертке WrapperProps [3]. В теле компонента-обертки общие пропсы\n * разделяются с помощью механизма деструктуризации на две категории, первая из\n * которых предназначается самому компоненту-обертке [4], а вторая оборачиваемому-компоненту [5].\n * Поскольку пропсы предназначенные оборачиваемому-компоненту [5] представляют из себя остаточные значения\n * полученные при деструктуризации, они принадлежат к типу Pick<T, K>, что требует перед объединением их [9]\n * с пропсами созданными компонентом-оберткой [8] сначала к типу unknown [10], а затем уже к необходимому \n * WrappedProps [11]. После этого слитые воедино пропсы можно устанавливать [13] компоненту [12] ссылка на который\n * доступна в качестве единственного параметра hoc.\n * \n * [14] возвращаем из hoc компонент-обертку.\n */\n`````\n\nТеперь необходимо определить компонент, пропсы которого будут принадлежать к типам описывающих значения, чья установка разделена между разработчиком и компонентом-оберткой. Далее этот компонент необходимо передать в качестве аргумента созданному нами _hoc_, чьё возвращаемое значение является компонентом-оберткой, с которым и будет взаимодействовать разработчик. Осталось создать экземпляр компонента-обертки и убедится как сила типизации позволяет установить в качестве пропсов только необходимые значения.\n\n`````ts\n/**[0] */\nexport interface CustomComponentProps {\n    d: number;\n    e: string;\n}\n\n                /**[1]                  [2]                     [3]                [4] [5][5] */\nexport const CustomComponent: FC<CustomComponentProps & WrapperForWrappedProps> = ({c, d, e}) => {\n    return null;\n} \n\n                    /**[6]              [7]         [8] */\nexport const CustomComponentWrapped = withHoc(CustomComponent);\n\n/**\n * [0] объявление типа CustomComponentProps представляющего пропсы предназначенные\n * для обертываемого-компонента [1] и установка которых является\n * задачей разработчика. Пропсы компонента-обертки представленного\n * функциональным компонентом помимо типа CustomComponentProps [2]\n * описывающего значения устанавливаемые разработчиком [5]\n * также принадлежат к типу WrapperForWrappedProps [3] описывающего\n * значения устанавливаемые компонентом-оберткой [4].\n * \n * Ссылка на оборачиваемый-компонент передается в качестве аргумента [8]\n * функции hoc [7], а результат вызова сохраняется в переменную представляющую\n * компонент-обертку [8].\n */\n\n\n                     /**[9]   [9]    [10]  [10] */\n<CustomComponentWrapped a={0} b={``} d={1} e={``} />; // Ok\n                     /**[9]   [9]    [11]     [10]  [10] */\n<CustomComponentWrapped a={0} b={``} c={true} d={1} e={``} />; // Error -> Property 'c' does not exist on type CustomComponentProps & WrapperProps'\n\n/**\n * При создании экземпляра компонента-обертки будет необходимо установить\n * параметры описываемые как типом WrapperProps [9] и так и CustomComponentProps [10].\n * При попытке установить иные значения возникнет ошибка. \n */\n `````"},{"key":"HOC (Higher-Order Components)_2","elementId":"Opredelenie_hoc_na_osnove_klassovogo_komponenta","markdown":"## Определение hoc на основе классового компонента\n\nПоскольку пример для _hoc_, возвращающего в качестве компонента-обертки классовый компонент, отличается от предыдущего лишь заменой функции на класс и объявлением для него двух дополнительных типов `*State` и `*Snapshot`, в повторном комментировании происходящего попросту нет смысла.\n\n`````ts\nimport React, {ComponentType, Component} from \"react\";\n\n\nexport interface WrapperProps {\n    a: number;\n    b: string;\n}\n\n/**[0] */\ninterface WrapperState {}\n/**[1] */\ninterface WrapperSnapshot {}\n\nexport interface WrapperForWrappedProps {\n    c: boolean;\n}\n\n\n/**\n * Поскольку компонент-обертка будет представлен\n * классовым компонентом помимо описания его *Props\n * также появляется необходимость в объявлении типов\n * описывающих его *State [0] и *Snapshot [1].\n */\n\n/**\n * [!] Стоит обратить внимание, что по причине\n * упрощенности примера отсутствуют более компактные\n * псевдонимы для менее компактных типов.\n */\n\nexport function withHoc<WrappedProps>(\n    WrappedComponent: ComponentType<WrappedProps & WrapperForWrappedProps>)\n        : ComponentClass<WrappedProps & WrapperProps> {\n\n                    /**[2] */\n            class WrapperComponent extends Component<WrapperProps & WrappedProps, WrapperState, WrapperSnapshot> {\n                render() {\n                    let {a, b, ...wrappedOnlyProps} = this.props;\n                    let wrapperToWrappedProps = {\n                        c: true\n                    };\n                    let wrappedFullProps = {...wrapperToWrappedProps, ...wrappedOnlyProps as unknown as WrappedProps};\n\n\n                    return <WrappedComponent {...wrappedFullProps} />\n                }\n            }\n\n\n            return WrapperComponent;\n}\n\n/**\n * [2] определение компонента-обертки в виде классового компонента.\n */\n\nexport interface CustomComponentProps {\n    d: number;\n    e: string;\n}\n\nexport const CustomComponent: FC<CustomComponentProps & WrapperForWrappedProps> = ({c, d, e}) => {\n    return null;\n} \n\nexport const CustomComponentWrapped = withHoc(CustomComponent);\n\n\n<CustomComponentWrapped a={0} b={``} d={1} e={``} />; // Ok\n<CustomComponentWrapped a={0} b={``} c={true} d={1} e={``} />; // Error -> Property 'c' does not exist on type CustomComponentProps & WrapperProps'\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Контекст (Context)","path":"Kontekst_(Context)"},"nextPage":{"title":"Пространства имен (namespace) и модули (module)","path":"Prostranstva_imen_(namespace)_i_moduli_(module)"}},"contentNavData":{"key":"HOC (Higher-Order Components)","level":0,"index":56,"contentIndex":0,"section":"React","title":"HOC (Higher-Order Components)","path":"HOC_(Higher-Order_Components)","elementId":"HOC_(Higher-Order_Components)","children":[{"key":"HOC (Higher-Order Components)_0","index":0,"contentIndex":1,"level":1,"section":"React","title":"Определение hoc","path":"Opredelenie_hoc","elementId":"Opredelenie_hoc"},{"key":"HOC (Higher-Order Components)_1","index":1,"contentIndex":2,"level":1,"section":"React","title":"Определение hoc на основе функционального компонента","path":"Opredelenie_hoc_na_osnove_funkcionalnogo_komponenta","elementId":"Opredelenie_hoc_na_osnove_funkcionalnogo_komponenta"},{"key":"HOC (Higher-Order Components)_2","index":2,"contentIndex":3,"level":1,"section":"React","title":"Определение hoc на основе классового компонента","path":"Opredelenie_hoc_na_osnove_klassovogo_komponenta","elementId":"Opredelenie_hoc_na_osnove_klassovogo_komponenta"}]},"pageDescription":"HOC (Higher-Order Components)"},"__N_SSG":true}