{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/047.(Расширенные типы) Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited/images/"},"sectionInfoAll":[{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited","elementId":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit,Awaited","markdown":"# Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited\n\nЧтобы сэкономить время разработчиков, в систему типов _TypeScript_ были включены несколько часто требующихся условных типов, каждый из которых будут подробно рассмотрен в этой главе."},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_0","elementId":"Exclude<T,U>_(iskluchaet_iz_T_priznaki_prisushchie_U)","markdown":"## Exclude<T, U> (исключает из T признаки присущие U)\n\nВ результате разрешения условный тип `Exclude<T, U>` будет представлять разницу типа `T` относительно типа `U`. Параметры типа `T` и `U` могут быть представлены как единичным типом, так и множеством `union`.\n\n`````ts\n// @filename: lib.d.ts\n\ntype Exclude<T, U> = T extends U ? never : T;\n`````\n\nПростыми словами из типа `T` будут исключены признаки (ключи) присущие также и типу `U`.\n\n`````ts\nlet v0: Exclude<number|string, number|boolean>; // let v0: string\nlet v1: Exclude<number|string, boolean|object>; // let v1: string|number\nlet v2: Exclude<\"a\" | \"b\", \"a\" | \"c\">; // let v2: \"b\"\n`````\n\nВ случае, если оба аргумента типа принадлежат к одному и тому же типу данных, `Exclude<T, U>` будет представлен типом `never`.\n\n`````ts\nlet v4: Exclude<number|string, number|string>; // let v4: never\n`````\n\nЕго реальную пользу лучше всего продемонстрировать на реализации функции, которая на входе получает два разных объекта, а на выходе возвращает новый объект, состоящий из членов присутствующих в первом объекте, но отсутствующих во втором. Аналог функции `difference` из широко известной библиотеки _lodash_.\n\n`````ts\ndeclare function difference<T, U>(a: T, b: U): Pick<T, Exclude<keyof T, keyof U>>\n\n\ninterface IA { a: number; b: string; }\ninterface IB { a: number; c: boolean; }\n\n\nlet a: IA = { a: 5, b: '' };\nlet b: IB = { a: 10, c: true };\n\n\ninterface IDifference { b: string; }\n\n\nlet v0: IDifference = difference(a, b); // Ok\nlet v1: IA = difference(a, b); // Error -> Property 'a' is missing in type 'Pick<IA, \"b\">' but required in type 'IA'.\nlet v2: IB = difference(a, b); // Error -> Type 'Pick ' is missing the following properties from type 'IB': a, c\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_1","elementId":"Extract<T,U>_(obshchie_dlya_dvuh_tipov_priznaki)","markdown":"## Extract<T, U> (общие для двух типов признаки)\n\nВ результате разрешения условный тип `Extract<T, U>` будет представлять пересечение типа `T` относительно типа `U`. Оба параметра типа могут быть представлены как обычным типом, так `union`.\n\n`````ts\n// @filename: lib.d.ts\n\ntype Extract<T, U> = T extends U ? T : never;\n`````\n\nПростыми словами, после разрешения `Extract<T, U>` будет принадлежать к типу определяемого признаками (ключами) присущих обоим типам. То есть, тип `Extract<T, U>` является противоположностью типа `Exclude<T, U>`.\n\n`````ts\nlet v0 :Extract<number|string, number|string>; // let v0: string | number\nlet v1 :Extract<number|string, number|boolean>; // let v1: number\nlet v2 :Extract<\"a\" | \"b\", \"a\" | \"c\">; // let v2: \"a\"\n`````\n\nВ случае, когда общие признаки отсутствуют, тип `Extract<T, U>` будет представлять тип `never`.\n\n`````ts\nlet v3 :Extract<number|string, boolean|object>; // let v3: never\n`````\n\nУсловный тип `Extract<T, U>` стоит рассмотреть на примере реализации функции принимающей два объекта и возвращающей новый объект, состоящий из членов первого объекта, которые также присутствуют и во втором объекте.\n\n`````ts\ndeclare function intersection<T, U>(a: T, b: U): Pick<T, Extract<keyof T, keyof U>>\n\n\ninterface IA { a: number; b: string; }\ninterface IB { a: number; c: boolean; }\n\n\nlet a: IA = { a: 5, b: '' };\nlet b: IB = { a: 10, c: true };\n\n\ninterface IIntersection { a: number; }\n\n\nlet v0: IIntersection = intersection(a, b); // Ok\nlet v1: IA = intersection(a, b); // Error -> Property 'b' is missing in type 'Pick<IA, \"a\">' but required in type 'IA'.\nlet v2: IB = intersection(a, b); // Error -> Property 'c' is missing in type 'Pick<IA, \"a\">' but required in type 'IB'.\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_2","elementId":"NonNullable<T>_(udalyaet_tipy_null_i_undefined)","markdown":"## NonNullable<T> (удаляет типы null и undefined)\n\nУсловный тип `NonNullable<T>` служит для исключения из типа признаков типов `null` и `undefined`. Единственный параметр типа может принадлежать как к обычному типу, так и множеству определяемого тип `union`.\n\n`````ts\n// @filename: lib.d.ts\n\ntype NonNullable<T> = T & {};\n`````\n\nПростыми словами, данный тип удаляет из аннотации типа такие типы, как `null` и `undefined`.\n\n`````ts\nlet v0: NonNullable<string | number | null>; // let v0: string | number\nlet v1: NonNullable<string | undefined | null>; // let v1: string\nlet v2: NonNullable<string | number | undefined | null>; // let v2: string | number\n`````\n\nВ случае, когда тип, выступающий в роли единственного аргумента типа, принадлежит только к типам `null` и\\или `undefined`, `NonNullable<T>` представляет тип `never`.\n\n`````ts\nlet v3: NonNullable<undefined | null>; // let v3: never\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_3","elementId":"ReturnType<T>_(poluchit_tip_znacheniya_vozvrashchaemogo_funkciei)","markdown":"## ReturnType<T> (получить тип значения возвращаемого функцией)\n\nУсловный тип `ReturnType<T>` служит для установления возвращаемого из функции типа. В качестве параметра типа должен обязательно выступать _функциональный тип_.\n\n`````ts\n// @filename: lib.d.ts\n\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n`````\n\nНа практике очень часто требуется получить тип к которому принадлежит значение возвращаемое из функции. Единственное на, что стоит обратить внимание, что в случаях, когда тип возвращаемого из функции значения является параметром типа, у которого отсутствуют хоть какие-то признаки, то тип `ReturnType<T>` будет представлен пустым объектным типом `{}`.\n\n`````ts\nlet v0: ReturnType<() => void>; // let v0: void\nlet v1: ReturnType<() => number | string>; // let v1: string|number\nlet v2: ReturnType<<T>() => T>; // let v2: {}\nlet v3: ReturnType<<T extends U, U extends string[]>() => T>; // let v3: string[]\nlet v4: ReturnType<any>; // let v4: any\nlet v5: ReturnType<never>; // let v5: never\nlet v6: ReturnType<Function>; // Error\nlet v7: ReturnType<number>; // Error\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_4","elementId":"InstanceType<T>_(poluchit_cherez_tip_klassa_tip_ego_ekzemplyara)","markdown":"## InstanceType<T> (получить через тип класса тип его экземпляра)\n\nУсловный тип `InstanceType<T>` предназначен для получения типа экземпляра на основе типа представляющего класс. Параметр типа `T` должен обязательно принадлежать к _типу класса_.\n\n`````ts\n// @filename: lib.d.ts\n\ntype InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\n`````\n\nВ большинстве случаев идентификатор класса задействован в приложении в качестве типа его экземпляра.\n\n`````ts\nclass Animal {\n  move(): void {}\n}\n\n/**\n * Тип Animal представляет объект класса,\n *, то есть его экземпляр полученный при \n * помощи оператора new.\n */\nfunction f(animal: Animal){\n  type Param = typeof Animal;\n\n  // здесь Param представляет экземпляр типа Animal\n}\n`````\n\nНо сложные приложения часто требуют динамического создания своих компонентов. В таких случаях фабричные функции работают не с экземплярами классов, а непосредственно с самими классами. \n\nСтоит напомнить, что в _JavaScript_ классы, это всего-лишь _синтаксический сахар_ над старой, доброй _функцией конструктором_. И как известно объект функции конструктора представляет объект класса содержащего ссылку на прототип, который и представляет экземпляр. Другими словами, в _TypeScript_ идентификатор класса указанный в аннотации типа, представляет описание прототипа. Чтобы получить тип самого класса, необходимо выполнить над идентификатором класса _запрос типа_.\n\n`````ts\nclass Animal {\n  move(): void {}\n}\n\ntype Instance = Animal;\ntype Class = typeof Animal;\n\ntype MoveFromInstance = Instance[\"move\"]; // Ok ->() => void\ntype MoveFromClass = Class[\"move\"]; // Error -> Property 'move' does not exist on type 'typeof Animal'.\n\n`````\n\nТаким образом, грамотно вычислить тип экземпляра в фабричной функции можно при помощи типа `InstanceType<T>`.\n\n`````ts\nclass Animal {\n  move(): void {}\n}\n\nfunction factory(Class: typeof Animal){\n  type Instance = InstanceType<Class>;\n  \n  let instance: Instance = new Class(); // Ok -> let instance: Animal\n}\n`````\n\nХотя можно прибегнуть и к менее декларативному способу к запросу типа свойства класса `prototype`.\n\n`````ts\nfunction factory(Class: typeof Animal){\n  type Instance = Class[\"prototype\"];\n  \n  let instance: Instance = new Class(); // Ok -> let instance: Animal\n}\n`````\n\nИ последнее о чем стоит упомянуть, что результат получение типа непосредственно через `any` и `never` будет представлен ими же. Остальные случаи приведут к возникновению ошибки.\n\n`````ts\nclass Animal {}\n\nlet v0: InstanceType<any>; // let v0: any\nlet v1: InstanceType<never>; // let v1: never\nlet v2: InstanceType<number>; // Error\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_5","elementId":"Parameters<T>_(poluchit_tip_razmechennogo_korteja_opisyvaushchii_parametry_funkcionalnogo_tipa)","markdown":"## Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)\n\nРасширенный тип `Parameters<T>` предназначен для получения типов указанных в аннотации параметров функции. В качестве аргумента типа ожидается _функциональный тип_, на основе которого будет получен размеченный кортеж описывающий параметры этого функционального типа.\n\n`````ts\ntype Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n`````\n\n`Parameters<T>` возвращает типы параметров в виде кортежа.\n\n`````ts\nfunction f<T>(p0: T, p1: number, p2: string, p3?: boolean, p4: object = {}) {\n  \n}\n\n/**\n * type FunctionParams = [p0: unknown, p1: number, p2: string, p3?: boolean, p4?: object]\n */\ntype FunctionParams = Parameters<typeof f>;\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_6","elementId":"ConstructorParameters<T>_(poluchit_cherez_tip_klassa_razmechennyi_kortej_opisyvaushchii_parametry_ego_konstruktora)","markdown":"## ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)\n\nРасширенный тип `ConstructorParameters<T>` предназначен для получения типов указанных в аннотации параметров конструктора.\n\n`````ts\ntype ConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ? P : never;\n`````\n\nВ качестве единственного параметра типа `ConstructorParameters<T>` ожидает тип самого класса, на основе конструктора которого будет получен размеченный кортеж описывающий параметры этого конструктора.\n\n`````ts\nclass Class<T> {\n    constructor(p0: T, p1: number, p2: string, p3?: boolean, p4: object = {}) {}\n}\n\n/**\n * type ClassParams = [p0: unknown, p1: number, p2: string, p3?: boolean, p4?: object]\n */\ntype ClassParams = ConstructorParameters<typeof Class>;\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_7","elementId":"Omit<T,K>_(iskluchit_iz_T_priznaki_associirovannymi_s_kluchami_perechislennyh_mnojestvom_K)","markdown":"## Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)\n\nРасширенный тип `Omit<T, K>`предназначен для определения нового типа путем исключения заданных признаков из существующего тип.\n\n`````ts\n// lib.d.ts\n\ntype Omit<T, K extends string | number | symbol> = { \n    [P in Exclude<keyof T, K>]: T[P];\n}\n`````\n\nВ качестве первого аргумента типа тип `Omit<T, K>` ожидает тип данных, из которого будут исключены признаки, связанные с ключами, переданными в качестве второго аргумента типа.\n\nПростыми словами, к помощи `Omit<T, K>` следует прибегать в случаях необходимости определения типа, представляющего некоторую часть уже существующего типа.\n\n`````ts\ntype Person = {\n  firstName: string;\n  lastName: string;\n\n  age: number;\n};\n\n/**\n * Тип PersonName представляет только часть типа Person\n *\n * type PersonName = {\n *  firstName: string;\n *  lastName: string;\n * }\n */\ntype PersonName = Omit<Person, 'age'>; // исключение признаков связанных с полем age из типа Person\n`````"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_8","elementId":"Awaited<T>_(rekursivnoe_razvertyvaniya_promisov)","markdown":"## Awaited<T> (рекурсивное развертывания промисов)\n\nРасширенный тип `Awaited<T>` предназначен для рекурсивного развертывания промисов, что в повседневной работе с асинхронными операциями является незаменимым помощником.\n\n`````ts\n// A = string\ntype A = Awaited<Promise<string>>;\n\n// B = string\ntype B = Awaited<Promise<Promise<string>>>;\n\n// C = string | number\ntype C = Awaited<string | Promise<number>>;\n`````"}],"githubFileInfo":{"lastUpdate":1657623352000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Readonly, Partial, Required, Pick, Record","path":"Readonly,Partial,Required,Pick,Record"},"nextPage":{"title":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Massivopodobnye_readonly_tipy,ReadonlyArray,ReadonlyMap,ReadonlySet"}},"contentNavData":{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited","level":0,"index":47,"contentIndex":0,"section":"Расширенные типы","title":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited","path":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit,Awaited","elementId":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit,Awaited","children":[{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_0","index":0,"contentIndex":1,"level":1,"section":"Расширенные типы","title":"Exclude<T, U> (исключает из T признаки присущие U)","path":"Exclude<T,U>_(iskluchaet_iz_T_priznaki_prisushchie_U)","elementId":"Exclude<T,U>_(iskluchaet_iz_T_priznaki_prisushchie_U)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_1","index":1,"contentIndex":2,"level":1,"section":"Расширенные типы","title":"Extract<T, U> (общие для двух типов признаки)","path":"Extract<T,U>_(obshchie_dlya_dvuh_tipov_priznaki)","elementId":"Extract<T,U>_(obshchie_dlya_dvuh_tipov_priznaki)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_2","index":2,"contentIndex":3,"level":1,"section":"Расширенные типы","title":"NonNullable<T> (удаляет типы null и undefined)","path":"NonNullable<T>_(udalyaet_tipy_null_i_undefined)","elementId":"NonNullable<T>_(udalyaet_tipy_null_i_undefined)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_3","index":3,"contentIndex":4,"level":1,"section":"Расширенные типы","title":"ReturnType<T> (получить тип значения возвращаемого функцией)","path":"ReturnType<T>_(poluchit_tip_znacheniya_vozvrashchaemogo_funkciei)","elementId":"ReturnType<T>_(poluchit_tip_znacheniya_vozvrashchaemogo_funkciei)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_4","index":4,"contentIndex":5,"level":1,"section":"Расширенные типы","title":"InstanceType<T> (получить через тип класса тип его экземпляра)","path":"InstanceType<T>_(poluchit_cherez_tip_klassa_tip_ego_ekzemplyara)","elementId":"InstanceType<T>_(poluchit_cherez_tip_klassa_tip_ego_ekzemplyara)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_5","index":5,"contentIndex":6,"level":1,"section":"Расширенные типы","title":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)","path":"Parameters<T>_(poluchit_tip_razmechennogo_korteja_opisyvaushchii_parametry_funkcionalnogo_tipa)","elementId":"Parameters<T>_(poluchit_tip_razmechennogo_korteja_opisyvaushchii_parametry_funkcionalnogo_tipa)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_6","index":6,"contentIndex":7,"level":1,"section":"Расширенные типы","title":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)","path":"ConstructorParameters<T>_(poluchit_cherez_tip_klassa_razmechennyi_kortej_opisyvaushchii_parametry_ego_konstruktora)","elementId":"ConstructorParameters<T>_(poluchit_cherez_tip_klassa_razmechennyi_kortej_opisyvaushchii_parametry_ego_konstruktora)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_7","index":7,"contentIndex":8,"level":1,"section":"Расширенные типы","title":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)","path":"Omit<T,K>_(iskluchit_iz_T_priznaki_associirovannymi_s_kluchami_perechislennyh_mnojestvom_K)","elementId":"Omit<T,K>_(iskluchit_iz_T_priznaki_associirovannymi_s_kluchami_perechislennyh_mnojestvom_K)"},{"key":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited_8","index":8,"contentIndex":9,"level":1,"section":"Расширенные типы","title":"Awaited<T> (рекурсивное развертывания промисов)","path":"Awaited<T>_(rekursivnoe_razvertyvaniya_promisov)","elementId":"Awaited<T>_(rekursivnoe_razvertyvaniya_promisov)"}]},"pageDescription":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit, Awaited"},"__N_SSG":true}