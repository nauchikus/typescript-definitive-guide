{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/052.(React) Классовые компоненты/images/"},"sectionInfoAll":[{"key":"Классовые компоненты","elementId":"Klassovye_komponenty","markdown":"# Классовые компоненты\n\nПомимо компонентов на основе функций, _React_ позволяет определять компоненты на основе классов, которые, как в случае реализации _ловушки для ошибок_ просто не заменимы. Кроме этого, с ними необходимо познакомиться, так как они являются частью _React_. Именно поэтому текущая глава полностью посвящена старым добрым классовым компонентам."},{"key":"Классовые компоненты_0","elementId":"Proizvodnye_ot_Component<P,S,SS>","markdown":"## Производные от Component<P, S, SS>\n\nПользовательские компоненты построенные на основе классов обязаны расширять базовый обобщенный класс `Component<Props, State, Snapshot>` имеющего три необязательных параметра типа.\n\n`````ts\nimport React, {Component} from \"react\";\n\n\nclass Timer extends Component {\n    render(){\n        return null;\n    }\n}\n\nexport default Timer;\n`````\n\nПервым делом стоит обратить внимание на первую строку, а именно импорт пространства имен _React_. Не зависимо используете вы его напрямую или нет, оно обязательно должно быть импортировано, в противном случаи компилятор напомнит об этом с помощью ошибки.\n\n`````ts\n/**\n * [0] Забыт импорт пространства\n * имен React в следствии чего в\n * точке [1] возникнет ошибка - \n * \n * 'React' refers to a UMD global,\n * but the current file is a module.\n * Consider adding an import instead.ts(2686)\n */\n\nimport {Component} from \"react\"; // [0]\n\n\nclass Timer extends Component {\n    render(){\n        return null; // [1]\n    }\n}\n\nexport default Timer;\n`````\n\nКроме того, в нашем примере у метода `render` отсутствует аннотация возвращаемого типа, что на практике даже приветствуется. Но с образовательной точки зрения её указание не принесет никакого вреда.\n\n`````ts\nimport React, {Component, ReactNode} from \"react\";\n\n\nclass Timer extends Component {\n    render(): ReactNode {\n        return null;\n    }\n}\n\nexport default Timer;\n`````\n\nПри переопределении производным классом метода `render` в качестве типа возвращаемого значения необходимо указывать тип совместимый с указанным в базовом классе, то есть с типом `ReactNode` поведение и нюансы которого были подробно рассмотрены в главе посвященной функциональным компонентам.\n\nКак говорилось ранее, тип от которого должны наследоваться пользовательские классовые компоненты является обобщенным и имеет три необязательных параметра типа, что и иллюстрирует наш минималистический пример.\n\n`````ts\n/**\n * [0] отсутствует передача аргументов типа\n * определенных как Component<Props, State, Snapshot>\n *, что указывает на их необязательность.\n */\nclass Timer extends Component /** [0] */ {\n    \n}\n`````\n\nВ реальных проектах подобное встречается редко, поэтому следующим шагом разберем логику определения типов описывающих пользовательский компонент. \n\nНачнем по порядку, а именно с `Props`. Несмотря на то, что _пропсы_ делятся на обязательные и необязательные, все они по мере необходимости передаются в качестве аргументов конструктора при создании его экземпляра и доступны по ссылке `this.props` (обозначим их как _общие пропсы_). Тем не менее за инициализацию необязательных пропсов ответственен сам классовый компонент для чего и предусмотренно статическое поле `defaultProps`.\n\n`````ts\n/**\n * Аннотации в ожидании указания\n * типа.\n */\nclass Timer extends Component {\n    public static readonly defaultProps /** [0] */ = {};\n\n    constructor(props /** [1] */){\n        super(props);\n    }\n}\n`````\n\nТот факт, что аннотация `defaultProps` предполагает тип представляющий лишь ассоциированное с этим полем значение вынуждает разделить декларацию общих пропсов на два типа `DefaultProps` и `Props`. Ввиду того, что тип `Props` представляет не только обязательные пропсы, но и необязательные, он должен расширять (`extends`) тип `DefaultProps`.\n \n`````ts\ninterface DefaultProps {}\ninterface Props extends DefaultProps {}\n\n\nclass Timer extends Component {\n    public static readonly defaultProps = {};\n\n    constructor(props: Props){\n        super(props);\n    }\n}\n`````\n\nНе будет лишним упомянуть, что в реальных проектах интерфейс `Props`, помимо `DefaultProps`, очень часто расширяет множество других интерфейсов. В их число входят типы, предоставляемые библиотеками _ui_, _hoc обертками_ и обычными библиотеками, как например _react-router_ и его тип `RouteComponentProps<T>`.\n\nПоскольку в описании базового класса поле (`this.props`) принадлежит к типу определенного в качестве первого параметра типа, то есть `Component<Props>`, то `Props` необходимо указать в аннотации не только первого параметра конструктора, но и в качестве первого аргумента базового типа. Иначе `this.props` так и останется принадлежать к простому объектному типу `{}` заданному по умолчанию.\n\n`````ts\ninterface DefaultProps {\n    message: string;\n}\ninterface Props extends DefaultProps {\n    duration: number;\n}\n\n/**\n * Если не передавать Props в качестве\n * аргумента типа в точке [0], то в точке\n * [1] возникнет ошибка ->\n * Property 'message' does not exist on type\n * 'Readonly<{}> & Readonly<{ children?: ReactNode; }>'\n */\nclass Timer extends Component<Props /**[0] */> {\n    public static readonly defaultProps = {\n        message: `Done!`\n    };\n\n    constructor(props: Props){\n        super(props);\n\n        props.message; // Ok\n        this.props.message; // Ok [1]\n    }\n}\n`````\n\nКак было сказано в теме посвященной функциональным компонентам, что если взять за правило именовать типы пропсов как `DefaultProps` и `Props`, то при необходимости в их импорте непременно возникнет коллизия из-за одинаковых имен. Поэтому принято добавлять к названиям названия самих компонентов `*DefaultProps` и `*Props`. Но поскольку эти типы повсеместно указываются в аннотациях расположенных в теле классового компонента, то подобные имена попросту усложняют понимание кода. Поэтому для исчерпывающих имен необходимо создавать более компактные псевдонимы типа `type`.\n\nТакже стоит сразу сказать, что все три типа выступающих в качестве аргументов базового типа нуждаются в более компактных идентификаторах определяемых с помощью псевдонимов. Но, кроме того, все они описывают объекты, мутация которых не предполагается. Простыми словами типы `Props`, `State` и `Snapshot` используются исключительно в аннотациях `readonly` полей класса, параметрах его методов и возвращаемых ими значениях. Поскольку секрет здорового приложения кроется в типобезопасности, всю упомянутую троицу необходимо сделать неизменяемой. Для этого существует специальный тип `Readonly<T>`. Но так как преобразование типов в каждой отдельной аннотации приведет к чрезмерному увеличению кода, необходимо проделать это единожды в определении их псевдонимов.\n\nПосмотрим как новая информация преобразит наш основной пример.\n\n`````ts\nimport React, {Component, ReactNode} from \"react\";\n\n/**\n * Имена интерфейсов получили префикс\n * в виде названия компонента.\n */\ninterface TimerDefaultProps {\n    message: string;\n}\ninterface TimerProps extends TimerDefaultProps {\n    duration: number;\n}\n\n/**\n * Для конкретных типов преобразованных\n * в типы только для чтения\n * определен псевдоним.\n */\ntype DefaultProps = Readonly<TimerDefaultProps>;\ntype Props = Readonly<TimerProps>;\n\nclass Timer extends Component<Props> {\n    public static readonly defaultProps: DefaultProps = {\n        message: `Done!`\n    };\n\n    constructor(props: Props){\n        super(props);\n    }\n}\n\n/**\n * Добавлен экспорт не только самого\n * компонента, но и типа представляющего\n * его основные пропсы.\n */\nexport default Timer;\nexport {TimerProps}; // экспортируем типа *Props\n`````\n\nТакже стоит упомянуть, что пропсы всех компонентов по умолчанию имеют определение необязательного (объявленного с модификатором `?:`) поля `children` принадлежащего к оговоренному ранее типу `ReactNode`. Простыми словами можно вообще не передавать аргументы базовому типу и компилятор не выдаст ошибку при обращении к полю `this.props.children`;\n\n`````ts\nclass Label extends Component {\n    render(){\n        return (\n                    /**[0] */\n            <h1>{this.props.children}</h1>\n        );\n    }\n}\n\n/**\n * [0] несмотря на то, что базовому\n * типу не были установлены аргумента типа\n * обращение к свойству children не вызывает\n * ошибки поскольку данное свойство определенно\n * в базовом типе.\n */\n\n<Label>{\"label\"}</Label>; // string as children -> Ok [1]\n<Label>{1000}</Label>; // number as children -> Ok [2]\n<Label></Label>; // undefined as children -> Ok [3]\n\n /**\n  * При создании экземпляров компонента Label\n  * допустимо указывать в качестве children\n  * как строку [1], так и числа [2] и кроме\n  * того не указывать значения вовсе [3]\n  */\n`````\n\nВ остальном `children` имеют, то же поведение и недостатки подробно описанные в главе посвященной функциональным компонентам. Поэтому оставим их и приступим к рассмотрению второго параметра базового типа `Component`, а именно к типу представляющего состояние компонента `Component<Props, State>`.\n\nНесмотря на то, что состояние является закрытым от внешнего мира, тип представляющий его также принято называть с префиксом в роли которого выступает название самого компонента. Причина кроется не только в соблюдении общего стиля кода относительно именования типов пропсов. На практике могут возникнуть коллизии имен при создании вложенных классовых компонентов, что является обычным делом при создании _hoc_. Поэтому для типа описывающего состояние компонента так же необходимо определить ещё и псевдоним и не забыть передать его в качестве второго аргумента базового типа и указать в аннотации поля `state`.\n\n\n`````ts\nimport React, {Component, ReactNode} from \"react\";\n\ninterface TimerDefaultProps {\n    message: string;\n}\ninterface TimerProps extends TimerDefaultProps {\n    duration: number;\n}\n\n// определение State\ninterface TimerState {\n    time: number;\n}\n\ntype DefaultProps = Readonly<TimerDefaultProps>;\ntype Props = Readonly<TimerProps>;\ntype State = Readonly<TimerState>; // создание псевдонима для типа \n\n/**\n * [0] передача псевдонима State\n * в качестве второго аргумента\n * базового типа.\n */\nclass Timer extends Component<Props, State /** [0] */> { \n    public static readonly defaultProps: DefaultProps = {\n        message: `DOne!`\n    };\n\n    // определение поля state\n    public readonly state: State = {\n        time: 0\n    };\n\n    constructor(props: Props){\n        super(props);\n    }\n}\n\nexport default Timer;\nexport {TimerProps};\n`````\n\nПора обратить внимание на момент связанный с объявлением `defaultProps` и `state`, которым необходимо указывать (или не указывать вовсе) модификатор доступа `public`, так как к ним должен быть доступ извне. Кроме того, не будет лишним добавить этим полям модификатор `readonly`, который поможет избежать случайных изменений.\n\nГоворя о состоянии нельзя обойти стороной такой метод как `setState` необходимый для его изменения, о котором известно, что в качестве аргумента он может принимать как непосредственно объект представляющий новое состояние, так и функцию возвращающую его. Но поскольку первый случай ничего, что нас могло бы заинтересовать, из себя не представляет, рассмотрен будет лишь второй вариант с функцией. Поэтому продолжим наш основной пример и внесем в него изменения касающиеся изменения состояния. Создадим скрытый метод `reset` который будет сбрасывать значение пройденного времени.\n\n`````ts\ninterface TimerState {\n    time: number;\n}\n\ntype State = Readonly<TimerState>;\n\n\nclass Timer extends Component<Props, State> { \n    public static readonly defaultProps: DefaultProps = {\n        message: `DOne!`\n    };\n\n    public readonly state: State = {\n        time: 0\n    };\n\n    constructor(props: Props){\n        super(props);\n    }\n\n    // определение скрытого метода reset\n    private reset(){\n        /**\n         * Вызываем метод setState с функцией\n         * асинхронного изменения состояния\n         * в качестве первого аргумента.\n         */\n        this.setState( (prevState: Readonly<State>, props: Readonly<Props>) => {\n            return {time: 0}; // возвращаем новое состояние\n        } )\n    }\n}\n`````\n\nИз того кода, что был добавлен в наш пример стоит обратить внимание на несколько моментов. Прежде всего это использование псевдонимов `Props` и `State` в аннотациях параметров функции переданной в метод `setState`. Обозначим её как `updater`. Как было сказано ранее, типы описывающие состояние и пропсы используются повсеместно в коде компонента. Кроме того, стоит сказать, что описание сигнатуры функции `updater` подобным образом излишне и имеет место быт лишь в образовательных целях. Достаточно просто определить необходимые параметры и вывод типов самостоятельно определит их принадлежность.\n\n`````ts\nclass Timer extends Component<Props, State> { \n    private reset(){\n        /**\n         * Вывод типов в состоянии определить\n         * принадлежность параметров, поэтому\n         * самостоятельное аннотирование излишне.\n         * \n         * (parameter) prevState: Readonly<TimerState>\n         * (parameter) props: Readonly<TimerProps>\n         */\n        this.setState( (prevState, props) => {\n            return {time: 0};\n        } )\n    }\n}\n`````\n\nВ добавок к этому стоит возложить определение возвращаемого значения из функции `updater` на вывод типов, поскольку это не просто излишне, но и в большинстве случаев может являться причиной избыточного кода. Все дело в том, что когда состояние содержит множество полей, обновление которых не производится одновременно, при указании возвращаемого типа как `State` будет невозможно частичное обновление, поскольку лишь часть типа `State` не совместимо с целым `State`.\n\n`````ts\ninterface Props{}\ninterface State{ /**[0] */\n  yesCount: number;\n  noCount: number;\n}\nclass Counter extends Component<Props,State>{\n  state = {\n    yesCount:0,\n    noCount:0\n  }\n\n  buttonA_clickHandler = () => {\n      // инкрементируем yesCount\n    this.setState((prevState): State => {\n      return {yesCount: prevState.yesCount + 1}; /**1 */\n    });\n  };\n  buttonB_clickHandler = () => {\n      // инкрементируем noCount\n    this.setState((prevState): State => {\n        return {noCount: prevState.noCount + 1}; /**[2] */\n    });\n  };\n\n\n  render(){\n    return (\n      <div>\n          <p>Yes: {this.state.yesCount}</p>\n          <p>No: {this.state.noCount}</p>\n          <button onClick={this.buttonA_clickHandler}>yes++</button>\n          <button onClick={this.buttonB_clickHandler}>no++</button>\n      </div>\n    );\n  }\n}\n\n/**\n * [0] описание состояния с двумя полями.\n * [1] Error -> поскольку {yesCount: number} не совместим\n * с {yesCount: Number; noCount: number}\n * [2] Error -> поскольку {noCount: number} не совместим\n * с {yesCount: Number; noCount: number}\n */\n`````\nВ случае когда функция `updater` выполняет частичное обновление состояния и при этом тип возвращаемого значения указан явно, необходимо воспользоваться механизмом распространения (`spread`) дополнив отсутствующую часть в новом состоянии старым.\n\n`````ts\nclass Counter extends Component<Props,State>{\n  buttonA_clickHandler = () => {\n    this.setState((prevState): State => {\n                /**[0] */\n      return {...prevState, yesCount: prevState.yesCount + 1};\n    });\n  };\n  buttonB_clickHandler = () => {\n    this.setState((prevState): State => {\n                    /**[1] */\n        return {...prevState, noCount: prevState.noCount + 1};\n    });\n  };\n}\n\n/**\n * [0] В обоих случаях ошибки не возникает\n * поскольку недостающая часть состояния\n * дополняется из предыдущего состояния,\n *, что делает тип возвращаемого объекта\n * совместимым с типом State.\n */\n `````\nНесмотря на то, что механизм распространения помогает обойти трудности связанные с совместимостью типов, лучшим вариантом будет вообще не указывать возвращаемый функцией `updater` тип, а возложить эту обязанность на вывод типов.\n\nИ последнее о чем ещё не упомянули, что метод `setState`, в качестве второго параметра принимает функцию обратного вызова, декларация которой очень проста и будет рассмотрена в самом конце данной главы, когда весь код будет собран в одном месте.\n\nИ на этом рассмотрение состояния завершено, поэтому можно приступить к рассмотрению третьего и последнего параметра базового типа `Component<Props, State, Snapshot>`.\n\nПринципы применяемые для описания типа представляющего `Snapshot` ничем не отличаются от описания `Props` и `State`, поэтому пояснения будут опущены.\n\n`````ts\nimport React, {Component, ReactNode} from \"react\";\n\ninterface TimerDefaultProps {\n    message: string;\n}\ninterface TimerProps extends TimerDefaultProps {\n    duration: number;\n}\n\ninterface TimerState {\n    time: number;\n}\n\n// определение Snapshot\ninterface TimerSnapshot {}\n\n\ntype DefaultProps = Readonly<TimerDefaultProps>;\ntype Props = Readonly<TimerProps>;\ntype State = Readonly<TimerState>;\ntype Snapshot = Readonly<TimerSnapshot>; // создание псевдонима для типа \n\n/**\n * [0] передача псевдонима Snapshot\n * в качестве третьего аргумента\n * базового типа.\n */\nclass Timer extends Component<Props, State, Snapshot /** [0] */> { \n    /**\n     * Поскольку Snapshot используется\n     * в тех конструкциях очередь до которых\n     * ещё не дошла, тело класса будет опущено.\n     */\n}\n\nexport default Timer;\nexport {TimerProps};\n`````\n\nНичего особенного на, что стоило бы обратить внимание нет. Поэтому без лишних комментариев продолжим знакомство с внутренним устройством компонента — его жизненного цикла.\n\nПогружение в типизированный жизненный цикл классовых компонентов необходимо начать с его разделения на две части — _актуальный жизненный цикл_ и _устаревший жизненный цикл_, который будет исключён из рассмотрения. Поскольку в аннотации методов жизненного цикла не содержится ничего, что было бы непонятно к этому моменту, пояснение каждого отдельного случая будет опущено. Обратить внимание стоит лишь на импорт впервые встречающегося типа `ErrorInfo` необходимость в котором появляется при определении необязательно метода `componentDidCatch`. Кроме того, не будет лишнем напомнить, что в строгом, рекомендуемом режиме, при котором все элементы без аннотации неявно принадлежат к типу `any`, аннотация сигнатур методов является обязательной. И по этому случаю ещё раз стоит упомянуть о пользе коротких псевдонимов заменяющих огромные идентификаторы типов `*Props`, `*State` и `*Snapshot`.\n\n`````ts\nimport React, {Component, ReactNode, ErrorInfo} from \"react\"; // необходимость в импорте типа ErrorInfo\n\nclass Timer extends Component<Props, State, Snapshot> {\n    getDerivedStateFromProps?:(nextProps: Readonly<Props>, prevState: State) => Partial<State> | null;\n    getDerivedStateFromError?: (error: any) => Partial<State> | null;\n    \n    componentDidMount?(): void\n    shouldComponentUpdate?(nextProps: Readonly<Props>, nextState: Readonly<State>, nextContext: any): boolean;\n    componentWillUnmount?(): void;\n    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    getSnapshotBeforeUpdate?(prevProps: Readonly<Props>, prevState: Readonly<State>): Snapshot | null;\n    componentDidUpdate?(prevProps: Readonly<Props>, prevState: Readonly<State>, snapshot?: Snapshot): void;\n\n}\n`````\n\nВдобавок необходимо заметить, что код иллюстрирующий жизненный цикл компонента взят из декларации, устанавливаемой из репозитория `@types/react`, и именно поэтому она изобилует излишними преобразованиями в `Readonly<T>` тип. Но как было отмечено ранее, в этом нет нужны поскольку все типы составляющие троицу аргументов базового типа уже прошли преобразование при определении представляющих их псевдонимов. Учитывая этот факт предыдущий код будет выглядеть следующим образом.\n\n`````ts\n/**\n * Более компактная запись\n * без изменения поведения.\n */\nclass Timer extends Component<Props, State, Snapshot> {\n    getDerivedStateFromProps?:(nextProps: Props, prevState: State) => Partial<State> | null;\n    getDerivedStateFromError?: (error: any) => Partial<State> | null;\n    \n    componentDidMount?(): void\n    shouldComponentUpdate?(nextProps: Props, nextState: State, nextContext: any): boolean;\n    componentWillUnmount?(): void;\n    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    getSnapshotBeforeUpdate?(prevProps: Props, prevState: State): Snapshot | null;\n    componentDidUpdate?(prevProps: Props, prevState: State, snapshot?: Snapshot): void;\n\n}\n`````\n\nСледующий в очереди на рассмотрение механизм, получение ссылок на нативные _dom элементы_ и _React компоненты_, обозначаемый как _рефы_ (_refs_). \n\nПредположим, что существует форма, которую по событию `submit` необходимо очистить при помощи нативного метода `reset`, доступного лишь через нативный _dom элемент_, ссылку на который можно получить с помощью механизма рефов, применение которого возможно осуществить двумя способами. Первый способ заключается в создании объекта реф с помощью статического метода `React.createRef()`, а второй в самостоятельном сохранении ссылки на нативный _dom элемент_ с помощью функции обратного вызова.\n\n`````ts\n/**\n * задача заключается в\n * получении ссылки на\n * нативный dom елемент формы [0]. \n */\nclass CheckList extends Component {\n    render(){\n        return (\n            /**[0] */\n            <form></form>\n        );\n    }\n}\n`````\n\nНачнем по порядку. Первым делом необходимо определить поле (в нашем случае это `formRef`) необходимое для сохранения объекта реф и желательно, что бы оно было закрытое (`private`) и только для чтения (`readonly`). В примере поле `formRef` определен вместе с аннотацией в которой указан импортированный тип `RefObject<T>`, где параметр типа принимает тип нативного _dom элемента_, в нашем случае `HTMLFormElement`. Но в конкретном примере аннотация излишня поскольку мы указали выводу типов принадлежность нативного _dom элемента_ передав его в качестве аргумента типа функции `React.createRef<T>()`.\n\n`````ts\nimport React, {Component, RefObject} from \"react\";\n\nclass CheckList extends Component {\n                                    /**[1] */                                   /**[2] */\n    private readonly formRef: RefObject<HTMLFormElement> = React.createRef<HTMLFormElement>();\n\n}\n\n/**\n * [0] импорт типа RefObject<T>\n * который в аннотации [1] поля\n * formRef является излишним,\n * так как тип нативного dom элемента\n * был уточнен с помощь передачи его\n * в качестве аргумента типа функции [2]\n */\n`````\n\nНа следующим шаге устанавливаем объект реф _react элементу_ `<form>` и определяем закрытый метод `reset` в котором происходит вызов метода `reset` нативной формы. Не будет лишним обратить внимание, что вызов непосредственно метода `reset` осуществляется при помощи _оператора опциональной последовательности_ (`?.`). Сделано это по причине возможного отсутствия ссылки на нативный элемент.\n\n`````ts\nimport React, {Component, RefObject} from \"react\";\n\n\nclass CheckList extends Component {\n    private readonly formRef: RefObject<HTMLFormElement> = React.createRef<HTMLFormElement>();\n\n    /**[4] */\n    private resetForm(){\n                        /**[5] */\n        this.formRef.current?.reset();\n    }\n\n    render(){\n        return (\n                        /**[3] */\n            <form ref={this.formRef}></form>\n        );\n    }\n}\n\n/**\n * [3] установка рефа react элементу.\n * [4] определение закрытого метода.\n * [5] необходимость применения оператора\n * опциональной последовательности по причине\n * возможного отсутствия ссылки на нативный элемент.\n */\n`````\n\nВторой способ получения ссылки на нативный элемент заключается в определении функции принимающей в качестве единственного параметра нативный _dom элемент_, сохранение ссылки на который перекладывается на разработчика.\n\nДля иллюстрации сказанного повторим предыдущий пример. Первым делом импортируем обобщенный тип `RefCallback<T>` описывающий функцию и принимающий в качестве аргумента типа тип нативного _dom элемента_, который будет передан в функцию в качестве единственного аргумента. Затем определим поле `formNativeElement` с типом `union`, множество которого включат не только тип нативного элемента, но и `null`. Это необходимо поскольку при инициализации требуется установить значение принадлежащие к типу `null`. Это необходимо при активном флаге `--strictPropertyInitialization` входящим в группировку определяющую рекомендуемый строгий режим компилятора.\n\nСледующим шагом происходит определение закрытого только для чтения поля `formRefCallback` которому в качестве значения присвоена стрелочная функция. Единственный параметр данной функции лишен аннотации тпа, поскольку вывод типов определит его как принадлежащего к переданному в качестве аргумента типа `RefCallback<T>`. В теле данной функции происходит присваивание её параметра полю `formNativeElement` определенному на предыдущем шаге.\n\n`````ts\n                            /**[0] */\nimport React, {Component, RefCallback} from \"react\";\n\n\nclass CheckList extends Component {\n                /**[1] */               /**[2] */     /**[3] */\n    private formNativeElement: HTMLFormElement | null = null;\n                        /**[4] */                    /**[5] */      /**[6] */                       /**[7] */\n    private readonly formRefCallback: RefCallback<HTMLFormElement> = element => this.formNativeElement = element;\n\n}\n\n/**\n * [0] импорт типа RefCallback<T> который в качестве аргумента\n * типа ожидает тип нативного элемента.\n * [1] определение поля formNativeElement\n * и присвоение ему значения null [3], что приводит\n * к необходимости объединенного типа включающего\n * тип null [2]. [4] определение поля formRefCallback\n * значением которого служит стрелочная функция принимающая в\n * качестве единственного параметра нативный элемент [6] который затем\n * присваивается полю formNativeElement [7]. Тип этого параметра\n * будет принадлежать к типу переданному в качестве аргумента типа RefCallback<T> [5]\n * \n */\n`````\n\nСтоит заметить, что, то же самое можно реализовать и без помощи типа импортированного `RefCallback<T>`. Для этого лишь потребуется самостоятельно добавить аннотацию типа для параметра функции обратного вызова.\n\n`````ts\nimport React, {Component} from \"react\";\n\n\nclass CheckList extends Component {\n    private formNativeElement: HTMLFormElement | null = null;\n    private readonly formRefCallback = (element: HTMLFormElement) => this.formNativeElement = element;\n\n}\n\n/**\n * [0] определение поля formNativeElement\n * и присвоение ему значения null [2], что приводит\n * к необходимости объединенного типа включающего\n * тип null [1]. [3] определение поля formRefCallback\n * значением которого служит стрелочная функция в качестве\n * аргумента которая ожидает нативный элемент [4] который\n * затем присваивается полю formNativeElement [5]\n * \n */\n`````\n\nВыбор того или иного способа зависит лишь от предпочтений самого разработчика.\n\nПродолжим доведение примера до финального состояния и установим созданную в первом случае функцию обратного вызова _react элементу_ `<form>` в качестве реф. Также определим уже известный метод `reset` в теле которого будет происходить вызов метода `reset` у нативного _dom элемента_ ссылка на который будет сохранена в поле класса `formNativeElement`.\n\n`````ts\nimport React, {Component, RefCallback} from \"react\";\n\n\nclass CheckList extends Component {\n    private formNativeElement: HTMLFormElement | null = null;\n    private readonly formRefCallback: RefCallback<HTMLFormElement> = element => this.formNativeElement = element;\n\n\n    /**[1] */\n    private reset(){\n                /**[2] */\n        this.formNativeElement?.reset();\n    }\n\n\n    render(){\n        return (\n                            /**[0] */\n            <form ref={this.formRefCallback}></form>\n        );\n    }\n}\n\n/**\n * [0] устанавливаем callback в качестве значения реф\n * после чего определяем метод reset [1] в теле которого\n * при помощи оператора опциональной последовательности\n * вызываем метод reset у нативного dom элемента сохранённого\n * в поле formNativeElement [2]\n * \n */\n`````\n\nИ раз уж тема дошла до рассмотрения рефов, то необходимо рассмотреть механизм получения с их помощью ссылки на классовый компонент.\n\nПервым делом определим классовый компонент `Slider` реализующий два открытых метода предназначенных для перелистывания контента `prev` и `next`. Далее определим компонент `App` в теле которого определим рефу при помощи функции `createRef`, которой (рефе) в качестве аргумента типа передадим тип классового компонента `Slider`. Таким образом вывод типа определит рефу `sliderRef`, как принадлежащую к типу `RefObject<Slider>`. После этого в методе рендер создадим экземпляр компонента `Slider` и два _react элемента_ `<button>`, в обработчиках событий `click` которых происходит взаимодействие с компонентом `Slider` при помощи ссылки на него доступной через ассоциированную непосредственно с ним рефу.\n\n\n`````ts\nimport React, {Component, createRef} from \"react\";\n\n\nclass Slider extends Component{\n    public prev = () => {}; /**[0] */\n    public next = () => {}; /**[1] */\n    \n}\n\nclass App extends Component {\n                     /**[2]                 [3]*/\n    private readonly sliderRef = createRef<Slider>();\n\n\n    render(){\n        return (\n            <>\n                <button onClick={() => this.sliderRef.current?.prev()}>prev</button> { /**[4] */}\n                <Slider ref={this.sliderRef} /> { /**[5] */}\n                <button onClick={() => this.sliderRef.current?.next()}>next</button> { /**[6] */}\n            </>\n        )\n    }\n}\n\n/**\n * [0] псевдо компонент Slider реализует\n * два доступных метода перелистывания контента\n * назад [0] и вперед [1]. Псевдо компонент App\n * определяет рефу с помощью универсальной функции\n * createRef в качестве аргумента типа которой был\n * установлен тип компонента Slider. В методе render\n * происходит определение двух пользовательских кнопок\n * выполняющих перелистывание по событию click, в обработчиках\n * событий которых происходит вызов доступных методов prev [4]\n * и next [6] через рефу ассоциированную непосредственно с компонентом [5]\n */\n`````\n\n\nНа этом рассмотрение работы с механизмом рефов в типизированном стиле завершено. Но до завершения знакомства с работой классового компонента в основе которого лежит `Component<Props, State, Snapshot>` осталась ещё одна тема, а именно работа с _React событиями_. Кроме того, её освещение будет являться альтернативным решением задачи получения доступа к нативному элементу. Простыми словами реализуем вызов метода `reset` у нативного _dom элемента_ ссылку на который будет получена из объекта события `submit`. Но поскольку данная тема была подробна рассмотрена в главе посвященной функциональным компонентам, здесь подробно будут освещены только моменты присущие исключительно классовым компонентам.\n\nПервым делом возвратим предыдущий пример в первоначальное состояние и добавим кнопку для отправки формы.\n\n`````ts\nimport React, {Component} from \"react\";\n\nclass Form extends Component {\n    render(){\n        return (\n            <form>\n                <button type=\"submit\"></button>\n            </form>\n        );\n    }\n}\n`````\nДалее нам потребуется определить закрытое поле только для чтения в качестве значения которого будет присвоена стрелочная функция способная сохранить контекст текущего экземпляра. В качестве типа данного поля укажем импортированный из пространства имен _React_ ранее рассмотренный обобщенный тип `ReactEventHandler<T>`. \n\n`````ts\n\n                              /**[0] */\nimport React, {Component, ReactEventHandler} from \"react\";\n\nclass Form extends Component {\n                            /**[1] */                         /**[2] */     /**[3] */\n    private readonly form_submitHandler: ReactEventHandler<HTMLFormElement> = event => {\n\n    }\n\n    render(){\n        return (\n                                    /**[4] */\n            <form onSubmit={this.form_submitHandler}>\n                <button type=\"submit\"></button>\n            </form>\n        );\n    }\n}\n\n/**\n * [0] импорт типа ReactEventHandler<T>\n * представляющего слушателя события.\n * [1]  Определение закрытого неизменяемого\n * поля принадлежащего к функциональному \n * типу ReactEventHandler<T>. [2] тип нативного\n * dom элемента определенного стандартной\n * библиотекой. [3] единственный параметр\n * функции не нуждается в аннотации поскольку\n * вывод типа опирается на ReactEventHandler<T>.\n * [4] установка слушателя.\n */\n`````\n\nДля завершения примера осталось всего-навсего написать логику слушателя события `submit`, которая также повторяет пример из главы посвященной функциональным компонентам и поэтому подробных комментариев не будет.\n\n`````ts\nclass Form extends Component {\n    private readonly form_submitHandler: ReactEventHandler<FormEvent<HTMLFormElement>> = event => {\n        event.preventDefault(); // [0]\n        let form = event.target as HTMLFormElement; // [1]\n        form.reset(); // [2]\n    }\n}\n\n/**\n * [0] для предотвращения отправки формы\n * и перезагрузки страницы прерываем стандартное\n * поведение. [1] поскольку доступ к форме можно\n * получить через ссылку свойства target принадлежащего\n * к типу EventTarget, появляется необходимость в\n * приведении к типу HTMLFormElement с при помощи оператора as.\n * [2] вызываем метод reset.\n */\n`````\n\nДанный способ типизирования слушателей событий является предпочтительным поскольку при таком подходе аннотация включает только два типа и, кроме того, стрелочная функция уберегает от неминуемой потери контекста. Случаи требующие определения слушателя как метода класса требуют другого подхода. Отличие заключается в том, что в аннотировании типа нуждается непосредственно параметр слушателя. Но поскольку _React_ делегирует все нативные события, необходимо импортировать тип соответствующего события из его пространства имен. Для событий связанных с формами в _React_ определен обобщенный тип `FormEvent<T>` ожидающий в качестве аргумента типа тип нативного элемента. И поскольку слушатель ничего не возвращает, то тип возвращаемого значения, явное указание которого излишне, определяется как `void`.\n\n\n`````ts\n                            /**[0] */\nimport React, {Component, FormEvent} from \"react\";\n\nclass Form extends Component {\n    /**[1] */                          /**[2] */        /**[3] */\n    form_submitHandler(event: FormEvent<HTMLFormElement>): void {\n    }\n}\n\n/**\n * [0] импортируем тип FormEvent<T> после \n * чего определяем метод form_submitHandler\n * тип единственного параметра которого определен\n * как FormEvent<HTMLFormElement>, а возвращаемое\n * значение [3] которое указанно лишь для того, что бы\n * напомнить об отсутствии необходимости в его явном указании.\n */\n`````\n\nПоскольку установка слушателя представляемого методом класса приведет к неминуемой потери контекста, прибегать к подобному объявлению стоит только при условии, что их тело лишено логики предполагающей обращение к членам через ссылку экземпляра `this`.\n\n`````ts\nclass Form extends Component {\n    form_submitHandler(event: FormEvent<HTMLFormElement>): void {\n        /**\n         * Здесь нельзя обращаться к this\n         * поскольку контекст на текущий экземпляр\n         * был утерян.\n         */\n    }\n\n    render(){\n        return (\n            <form onSubmit={this.form_submitHandler}></form>\n        );\n    }\n\n}\n`````\n\nКонтекст можно было бы сохранить прибегнув к методу `bind` или делегированию события непосредственно с помощью стрелочной функции определенной в месте установки слушателя, но зачем? Для `bind` потребуется определения дополнительного поля.\n\n`````ts\nclass Form extends Component {\n    // дополнительное поле\n    private form_submitHandlerBinded: (event: FormEvent<HTMLFormElement>) => void;\n\n    constructor(props:Props){\n        super(props);\n        \n        // лишняя инициализация\n        this.form_submitHandlerBinded = this.form_submitHandler.bind(this);\n    }\n\n\n    form_submitHandler(event: FormEvent<HTMLFormElement>): void {\n        /**\n         * Теперь здесь можно обращаться к this\n         */\n    }\n\n    render(){\n        return (\n            // в качестве слушателя установлена функция связанная с помощью bind\n            <form onSubmit={this.form_submitHandlerBinded}></form>\n        );\n    }\n\n}\n`````\n\nСтрелочная функция будет пересоздаваться каждую отрисовку.\n\n`````ts\nclass Form extends Component {\n    form_submitHandler(event: FormEvent<HTMLFormElement>): void {\n        /**\n         * Теперь здесь можно обращаться к this\n         */\n    }\n\n    render(){\n        return (\n            // пересоздание функции каждую отрисовку\n            <form onSubmit={event => this.form_submitHandler(event)}></form>\n        );\n    }\n\n}\n`````\n\nКроме того, оба случая затрудняют понимание кода. Поэтому необходимо повторить, что использовать метод класса в качестве слушателя события стоит только при отсутствии необходимости в обращении через ссылку `this`. При возникновении именно такого случая не будет лишним уточнения способа выбора типа события. В приведенном примере это был `FormEvent<T>`, поскольку работа производилась с формой. Для других событий появится необходимость в других соответствующих типа, узнать которые можно с помощью подсказок вашей _ide_. Для чего всего-лишь необходимо навести курсор на определение слушателя события.\n\n`````ts\nclass Clicker extends Component {\n    render(){\n        return (\n                /**[0] */\n            <div onClick={}></div>\n        )\n    }\n\n}\n\n/**\n * [0] при наведении курсором\n * на определение слушателя onClick\n * ide подсказывает тип как MouseEvent<HTMLDivElement>\n */\n`````\n\nТакже не забываем об упомянутом ранее базовом для всех событийных _React_ типов обобщенном типе `SyntheticEvent<T>`, который в качестве аргумента ожидает тип представляющий нативный элемент.\n\nНа этом тему посвященную созданию классового компонента расширяющего `Component<Props, State, Snapshot>` можно заканчивать и переходить к следующей теме. Единственное, что точно не будет лишним, так это собрать весь пройденный материал в одном месте.\n\n`````ts\nimport React, {Component, ReactNode, ReactEventHandler, RefObject, SyntheticEvent, ErrorInfo} from \"react\";\n\ninterface GreeterDefaultProps {} // для декларации свойств по умолчанию\nexport interface GreeterProps extends GreeterDefaultProps {\n    children: ReactNode | ReactNode[]; // указываем, что children могут принадлежать к единичному типу или множеству составляющего тип ReactNode\n} // для декларации обязательных свойств + экспорт интерфейса\ninterface GreeterState {} // для декларации состояния\ninterface GreeterSnapshot {} // для декларации снимка\n\n// создаем псевдонимы для readonly типов представляющих...\ntype DefaultProps = Readonly<GreeterDefaultProps>; // ... статическое поле defaultProps\ntype Props = Readonly<GreeterProps>; // ... поле props\ntype State = Readonly<GreeterState>; // ... поле state\ntype Snapshot = Readonly<GreeterSnapshot>; // ... параметр snapshot определенный в нескольких методах жизненного цикла\n\n\nexport default class Greeter extends Component<Props, State, Snapshot> {\n    public static readonly defaultProps: DefaultProps = {}; // модификатор readonly от случайного изменения статического поля defaultProps которое должно иметь модификатор доступа public\n\n\n    // необязательные методы класса (статические методы)\n    public static getDerivedStateFromProps?:(nextProps: Props, prevState: State) => Partial<State> | null;\n    public static getDerivedStateFromError?: (error: any) => Partial<State> | null;\n\n\n    public readonly state: State = {}; // модификатор readonly от случайного изменения поля state которое должно иметь модификатор доступа public\n\n\n    /** два различных способа получения ссылки на нативный dom элемент */\n    // [0] при помощи контейнера\n    private readonly formRef: RefObject<HTMLFormElement> = React.createRef(); // создание объекта RefObject, с помощью которого будет получена ссылка на dom элемент\n    \n    // [1] при помощи callback\n    private textRef: HTMLSpanElement | null = null; // поле, в которое будет сохранена ссылка на DOM-элемент\n    private readonly textRefCallback = (element: HTMLSpanElement) => this.textRef = element; // определение функции обратного вызова для установления ссылки на DOM-элемент\n\n\n\n    constructor (props: Props) {\n        super(props);\n    }\n\n    \n    // методы жизненного цикла\n    public componentDidMount?(): void\n    public shouldComponentUpdate?(nextProps: Props, nextState: State, nextContext: any): boolean;\n    public componentWillUnmount?(): void;\n    public componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    public getSnapshotBeforeUpdate?(prevProps: Props, prevState: State): Snapshot | null;\n    public componentDidUpdate?(prevProps: Props, prevState: State, snapshot?: Snapshot): void;\n\n\n    /** два варианта определения слушателя событий */\n    // слушатель событий определенный как поле\n    private readonly form_submitHandler: ReactEventHandler<HTMLFormElement> = event => {\n        // изменение состояния\n        this.setState((prevState: State, prevProps: Props) => {\n            return {};\n        });\n    };\n    // слушатель событий определенный как метод\n    private submitButton_clickHandler(event: SyntheticEvent<HTMLButtonElement>): void {\n\n    }\n\n    public render(): ReactNode {\n        return (\n            <form ref={this.formRef} onSubmit={this.form_submitHandler}>\n                <span ref={this.textRefCallback}>Send form?</span>\n                <button type=\"submit\" onClick={this.submitButton_clickHandler}>yes</button>\n            </form>\n        );\n    }\n}\n`````"},{"key":"Классовые компоненты_1","elementId":"Proizvodnye_ot_PureComponent<Props,State,Snapshot>","markdown":"## Производные от PureComponent<Props, State, Snapshot>\n\nПомимо того, что пользовательские компоненты могут быть производными от универсального класс `Component<Props, State, Snapshot>`, они также могут использовать в качестве базового класса универсальный класс `PureComponent<Props, State, Snapshot>`. Но поскольку все, что было сказано относительно `Component` в ста процентах случаев верно и для `PureComponent`, который также ничего нового не привносит, то данная глава будет ограничена лишь кодом иллюстрирующим определение пользовательского компонента.\n\n`````ts\nimport React, { PureComponent } from \"react\";\n\n/**[*] */\n\nexport default class Greeter extends PureComponent<Props, State, Snapshot> {\n    /**[*] */\n}\n\n/**\n * [*] здесь предполагается логика\n * рассмотренная в главе, посвященной\n * производным от Component<P, S, SS>\n */\n`````\n\nТем кто только начал своё знакомство с классовыми компонентами с данной главы необходимо вернутся на шаг назад или даже более разумно в самое начало, поскольку именно там объясняется, что для полного понимания необходимо ознакомиться со всем материалом относящимся к _React_."}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Функциональные компоненты","path":"Funkcionalnye_komponenty"},"nextPage":{"title":"Универсальные компоненты","path":"Universalnye_komponenty"}},"contentNavData":{"key":"Классовые компоненты","level":0,"index":52,"contentIndex":0,"section":"React","title":"Классовые компоненты","path":"Klassovye_komponenty","elementId":"Klassovye_komponenty","children":[{"key":"Классовые компоненты_0","index":0,"contentIndex":1,"level":1,"section":"React","title":"Производные от Component<P, S, SS>","path":"Proizvodnye_ot_Component<P,S,SS>","elementId":"Proizvodnye_ot_Component<P,S,SS>"},{"key":"Классовые компоненты_1","index":1,"contentIndex":2,"level":1,"section":"React","title":"Производные от PureComponent<Props, State, Snapshot>","path":"Proizvodnye_ot_PureComponent<Props,State,Snapshot>","elementId":"Proizvodnye_ot_PureComponent<Props,State,Snapshot>"}]},"pageDescription":"Классовые компоненты"},"__N_SSG":true}