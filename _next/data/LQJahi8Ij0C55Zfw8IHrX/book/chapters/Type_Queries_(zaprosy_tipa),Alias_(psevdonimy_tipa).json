{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/017.(Типы) Type Queries (запросы типа), Alias (псевдонимы типа)/images/"},"sectionInfoAll":[{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)","elementId":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)","markdown":"# Type Queries (запросы типа), Alias (псевдонимы типа)\nКак сначала определить сложное значение, а затем одной строкой описать его тип? Или как конкретизировать более общий идентификатор типа и тем самым увеличить семантическую привлекательность кода? На два этих важных вопроса и поможет ответить текущая глава."},{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)_0","elementId":"Zaprosy_Tipa_(Type_Queries)","markdown":"##  Запросы Типа (Type Queries)\n\nМеханизм _запроса типа_ позволяют получить тип связанный со значением по его идентификатору и в дальнейшим использовать его как обычный тип. Запрос типа осуществляется оператором `typeof` после которого идет идентификатор ссылающийся на значение. Запрос типа также может располагаться в местах указания типа.\n\n`````ts\nlet v1: T1;\nlet v2: typeof v1; // let v2: T1;\n`````\n\nС помощью данного механизма можно получить тип любой конструкции будь, то переменная, параметр функции или метода, а также членов объекта и класса.\n\n`````ts\nclass T {\n    static staticProp: number;\n    \n    field: string;\n    \n    get prop(): boolean {\n        return true;\n    }\n    \n    method(): void {\n    \n    }\n}\n\nlet t: T = new T();\n\nlet v0: typeof t; // let v0: T\nlet v1: typeof T.staticProp; // // let v1: number\nlet v2: typeof t.field; // let v2: string\nlet v3: typeof t.prop; // let v3: boolean\nlet v4: typeof t.method; // let v4: ()=>void\n\nfunction f(param: number): void {\n    let v: typeof param; // let v: number\n}\n`````\n\nЗапрос типа может быть очень полезен сторонникам минимализма достигаемого при помощи вывода типов. К слову я один из них. Тем, кто придерживается консерватизма, возможно придется по душе идея ускорять написание тестов за счет механизма вывода типов. Ведь в тех ситуациях, когда для тестирования требуются не определенные в приложении типы данных, часто не хочется тратить время на их декларацию, но при этом хочется использовать авто дополнение. Например, при тестировании метода класса может понадобиться тип представляющий только его, но поскольку для проекта подобный тип просто бессмыслен, его придется определять в контексте самих тестов, что гораздо проще сделать при помощи механизма запроса типа. Все это вместе в _TypeScript_ становится возможным благодаря выводу типов в паре с оператором запроса типа.\n\nПредставьте значение, присвоенное переменной, тип которой не указан явно. Теперь представьте, что это значение нужно передать в функцию, параметр которой также не имеет явного указания типа. В этом случае в функции будет сложно работать с параметрами, так как вывод типов определит его принадлежность к типу `any`.\n\n`````ts\nconst STANDARD_NORMAL = { x: 0, y: 0 }; // данные, которые нужны только для контролирования точности самих тестов. А это, в свою очередь, означает, что декларация типов для них ещё не определена. Хотя вывод типов в состоянии вывести тип {x: number, y: number} для этой константы.\n\n// здесь вывод типа не в состоянии вывести тип параметров функции\nfunction valid(standard) {\n    let element = document.querySelector('#some-id');\n    let { clientLeft: x, clientTop: y } = element;\n    let position = { x, y };\n\n    // поэтому о параметрах невозможно получить какую-либо информацию \n    let isPositionXValid = position.x === standard. // автодополнение отсутствует\n    let isPositionYValid = position.y === standard. // автодополнение отсутствует\n    \n    // ...\n}\n`````\n\nНе стоит даже рассуждать — оставить так или указать типы, которые, возможно, предварительно нужно ещё задекларировать. Вместо этого нужно прибегнуть к механизму _запроса типа_. Запрос типа позволяет одновременно решить две задачи, одна из которых связана с проблемами сопутствующими типу `any`, а другая — минимализму и расходу времени на декларирование типов.\n\n`````ts\nconst STANDARD_NORMAL = { x: 0, y: 0 };\n\n// получение типа для аннотирования параметров прямо из константы.\nfunction valid(standard: typeof STANDARD_NORMAL) {\n    let element = document.querySelector('#some-id');\n    let { clientLeft: x, clientTop: y } = element;\n    let position = { x, y };\n    \n    // расходовать время на декларацию типа так и не пришлось. Тем не менее автодополнение работает.\n    let isPositionXValid = position.x === standard.x; // выводит .x\n    let isPositionYValid = position.y === standard.y; // выводит .y\n    \n    // ...\n}\n`````"},{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)_1","elementId":"Psevdonimy_Tipov_(Type_Aliases)","markdown":"## Псевдонимы Типов (Type Aliases)\n\nСоздание _псевдонимов типа_ (_types alias_) — ещё одна из множества возможностей _TypeScript_ которые невозможно переоценить. Псевдоним типа объявляется при помощи ключевого слова `type`, после которого следует идентификатор (имя) псевдонима, а за ним идет оператор присваивания `=`, справа от которого находится тип, ассоциирующийся с псевдонимом.\n\n`````ts\ntype Alias = T1;\n`````\n\nОбъявляться псевдоним типа может в контексте модулей, функций и методов.\n\n`````ts\nclass Type {\n    method(): void {\n        type Alias = Type;\n    }\n}\n\ntype Alias = Type;\n\nfunction func(): void {\n    type Alias = Type;\n}\n`````\n\nТак как псевдонимы типов являются лишь псевдонимами для реальных типов, они не оставляют следа в коде после компиляции, к тому же их нельзя было расширять (`extends`) и реализовать (`implements`) в ранних версиях языка (до 2.7). Сейчас псевдоним типа можно реализовать или расширить, только если он представляет объектный тип (`object type`) или пересечение объектных типов со статически известными членами. Кроме того, псевдонимы типов нельзя использовать в таких операциях с типами времени выполнения как `typeof` и `instanceof`. Если псевдоним типа будет создан для объекта, то при попытке создать его экземпляр возникнет ошибка.\n\n`````ts\nclass Class {\n    f1: number;\n    f2: string;\n}\n\ntype ClassAlias = Class;\n\nlet v1: ClassAlias = new Class(); // Ok\nlet v2: ClassAlias = new ClassAlias(); // Error\n`````\n\nПсевдонимы типов можно создавать как для типов объединений, так и для типов пересечений.\n\n`````ts\ntype SomeType = number | string | boolean; // union type\ntype OtherType = number & string & boolean; // intersection type\n`````\n\nДавно доказано, что идентификаторы типов, которые однозначно говорят о своем предназначении, облегчают понимание кода и его поддержку и тем самым сокращая затраты на его написание. По этой причине имена типов могут получаться очень длинными. Создание объединений или пересечений из нескольких типов с длинными именами может привести к ситуации, при которой код не поместится на одной строчке, что приведет к обратному эффекту, то есть затруднит его чтение.\n\n`````ts\nclass BirdSignDataProvider {}\nclass FishSignDataProvider {}\nclass InsectSignDataProvider {}\n\nfunction animalSignValidate(\n    signProvider: BirdSignDataProvider | FishSignDataProvider | InsectSignDataProvider\n): boolean {\n  return true;\n}\n`````\n\nПри работе с типами объединения и пересечения псевдонимы типов позволяют повысить читаемость кода за счет сокрытия множества типов за одним компактным идентификатором.\n\n`````ts\nclass BirdSignDataProvider {};\nclass FishSignDataProvider {};\nclass InsectSignDataProvider {};\n\ntype AnimalSignProvider =\n    BirdSignDataProvider |\n    FishSignDataProvider |\n    InsectSignDataProvider;\n\nfunction animalSignValidate(signProvider: AnimalSignProvider): boolean {\n    return true;\n}\n`````\n\nПсевдонимы типов можно выносить в отдельные модули, а затем импортировать их в места назначения. Если модуль содержащий псевдонимы типов содержит только их, современные сборщики не будут включать такой модуль в сборку. Другими словами, модуль растворится точно так же, как и другие не имеющие место в _JavaScript_ конструкции _TypeScript_.\n\n`````ts\n// aliases.ts\nimport BirdSignDataProvider from './BirdSignDataProvider';\nimport FishSignDataProvider from './FishSignDataProvider';\nimport InsectSignDataProvider from './InsectSignDataProvider';\n\nexport type AnimalSignProvider =\n    BirdSignDataProvider |\n    FishSignDataProvider |\n    InsectSignDataProvider;\n\n\n// index.js\nimport { AnimalSignProvider } from './aliases';\n\nimport BirdSignDataProvider from './BirdSignDataProvider';\nimport FishSignDataProvider from './FishSignDataProvider';\nimport InsectSignDataProvider from './InsectSignDataProvider';\n\nfunction animalSignValidate(signProvider: AnimalSignProvider): boolean {\n    return true;\n}\n\nanimalSignValidate(new BirdSignDataProvider());\nanimalSignValidate(new FishSignDataProvider());\nanimalSignValidate(new InsectSignDataProvider());\n`````\n\nКак было сказано ранее в главе _“Псевдонимы Типов (Type Aliases)”_, в тех редких случаях, когда декларированием типов, требующихся только для тестирования, можно пренебречь, механизм запроса типов помогает получить тип для указания в аннотации типа прямо из значения. Это дает все возможности типизации, за исключением читаемости кода, поскольку выражение запроса не персонализирует полученный тип. Хотя в примере, иллюстрирующим работу механизма запроса типа, константа `STANDARD_NORMAL` имеет вполне говорящий идентификатор, допускаются случаи, при которых подобного будет сложно добиться. При худшем сценарии идентификатор может иметь общий смысл.\n\n`````ts\nlet data = { x: 0, y: 0 };\n\nfunction valid(standard: typeof data) { // data, что это?\n\n} \n`````\n\nВ таких случаях псевдоним типа может оказать неоценимую помощь. Ведь экономия времени затраченного на декларирование типов не лишит код его выразительности и семантики.\n\n`````ts\nconst STANDARD_NORMAL = { x: 0, y: 0 };\n\ntype StandardNormalPoint = typeof STANDARD_NORMAL; // определение \"говорящего типа\" без затраты времени на его декларирование.\n\n\nfunction valid(standard: StandardNormalPoint) {\n    // ...\n    \n    // Расходовать время на декларацию типа не пришлось, при этом работает автодополнение и параметр функции обзавелся типом, в чьем названии заключено его предназначение.\n    let isPositionXValid = position.x === standard.x; // выводит .x\n    let isPositionYValid = position.y === standard.y; // выводит .y\n    \n    // ...\n}\n`````\n\nЕсть ещё пара особенностей псевдонимов, указание которых в данной главе было бы преждевременно, поэтому здесь о них будет лишь упомянуто. Во-первых, вынести объявления кортежа (`Tuple`), речь о котором пойдет далее в главе [“Типы - Object, Array, Tuple”](../019.(Типы)%20Object,%20Array,%20Tuple), можно только в описание псевдонима. Во-вторых, создать тип сопоставления как, например, `Readonly`, `Partial`, `Pick`, `Record` и им подобных, можно исключительно на основе псевдонимов типов. Перечисленные типы будут подробно рассмотрены в главе [“Расширенные типы - Readonly, Partial, Required, Pick, Record”](../044.(Расширенные%20типы)%20Readonly,%20Partial,%20Required,%20Pick,%20Record)."}],"githubFileInfo":{"lastUpdate":1643269367000,"contributorAll":[{"name":"Romanov Yuri","avatar":"https://avatars.githubusercontent.com/u/31193144?v=4","bio":"","githubUrl":"https://github.com/darteil"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Типы - Union, Intersection","path":"Tipy_-_Union,Intersection"},"nextPage":{"title":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum"}},"contentNavData":{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)","level":0,"index":17,"contentIndex":0,"section":"Типы","title":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)","elementId":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)","children":[{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Запросы Типа (Type Queries)","path":"Zaprosy_Tipa_(Type_Queries)","elementId":"Zaprosy_Tipa_(Type_Queries)"},{"key":"Type Queries (запросы типа), Alias (псевдонимы типа)_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Псевдонимы Типов (Type Aliases)","path":"Psevdonimy_Tipov_(Type_Aliases)","elementId":"Psevdonimy_Tipov_(Type_Aliases)"}]},"pageDescription":"Type Queries (запросы типа), Alias (псевдонимы типа)"},"__N_SSG":true}