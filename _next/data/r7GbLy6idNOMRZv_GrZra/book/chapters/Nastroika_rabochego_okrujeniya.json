{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/058.(Сборка) Настройка рабочего окружения/images/"},"sectionInfoAll":[{"key":"Настройка рабочего окружения","elementId":"Nastroika_rabochego_okrujeniya","markdown":"# Настройка рабочего окружения\n\nИногда может потребоваться выполнить компиляцию _TypeScript_ кода с помощью одного компилятор _tsc_. Именно поэтому текущая глава посвящена его установке, конфигурированию и запуску. Кроме того, она расскажет как спрятать длинные команды, изобилующие различными флагами компилятора, за коротенькими, определенными в _package.json_."},{"key":"Настройка рабочего окружения_0","elementId":"Nastroika_rabochego_okrujeniya","markdown":"## Настройка рабочего окружения\n\nВажным фактом является то, что насколько бы ни была продуктивной работа создателей _TypeScript_, им не успеть за развитием всей индустрии, всего сообщества. Простыми словами, насколько бы ни был продвинут компилятор, на практике его возможностей не хватает. Для того, что бы покрыть все потребности, разработчикам приходится прибегать к использованию сторонних библиотек, распространяемых через пакетный менеджер _npm_.\n\nКроме того, _html_ и _css_ используют в чистом виде, по большей части только в образовательных целях. В реальных проектах используют их более продвинутые аналоги, как например _jade_ или _sass_, которые так же, как _TypeScript_, нуждаются в компиляторах. Также приложения не обходятся без шрифтов, иконок и изображений, которые в целях оптимизации принято предварительно обрабатывать. Поэтому современный процесс разработки не представляется возможным без специализированных сборщиков, таких как _webpack_ или _gulp_.\n\n_gulp_ относится к так называемым _task runner’ам_, использование которых требует императивного определения задач для каждого отдельного процесса, самостоятельной настройки отлова ошибок. В свою очередь _webpack_ — это настоящий комбайн, конфигурирование которого больше напоминает декларативный стиль. Но поскольку книга посвящена языку _TypeScript_, текущая глава будет ограниченна рассмотрением сборки проекта при помощи одного компилятора _tsc_."},{"key":"Настройка рабочего окружения_1","elementId":"Sborka_proekta_s_pomoshchu_tsc_(TypeScript_compiler)","markdown":"## Сборка проекта с помощью tsc (TypeScript compiler)\n\nПервым делом нужно создать директорию, в данном случае это будет директория с названием _typescript-with-tsc_ содержащая две поддиректории _src_ и _dest_. В первой будут находиться исходные файлы с расширением _.ts_, которые будут преобразованы в файлы с расширением _.js_ и помещены во вторую директорию. \n\nТеперь нужно открыть консоль в рабочей директории и выполнить инициализацию _npm_, в данном случае — ускоренную.\n\n`````ts\nnpm init -y\n`````\n\nНа этот момент в директории должен появится файл _package.json_. После инициализации _npm_, установим компилятор _TypeScript_, выполнив в консоли следующую команду:\n\n`````ts\nnpm i -D typescript\n`````\n\nПосле успешной установки прежде всего нужно выполнить конфигурирование _TypeScript_. Для этого следовало бы выполнить в консоли:\n\n`````ts\ntsc init\n`````\n\nНо, так как _TypeScript_ установлен только локально, следует указать путь к нему:\n\n`````ts\n./node_modules/.bin/tsc --init\n`````\n\nПосле этого в директории должен появится файл _tsconfig.json_, точную настройку которого можно произвести после прочтения главы, посвященной опциям компилятора (глава [“Опции компилятора”](../060.(Компилятор)%20Опции%20компилятора)), а пока просто укажем нужные настройки. В сгенерированном файле _tsconfig.json_ будет очень много опций, большинство из которых закомментировано, но в итоге должно получиться не, что подобное:\n\n`````ts\n{\n\"compilerOptions\": {\n  \"target\": \"es5\",\n   \"module\": \"system\", \n   \"outFile\": \"./dest/build.js\", \n   \"rootDir\": \"./src\" \n},\n\"exclude\": [\n  \"/node_modules/\"\n]\n}\n`````\n\nТеперь можно приступить к _dev_ сборке. Для этого нужно открыть файл _package.json_ и в поле `script` прописать команды для пакетного менеджера _npm_.\n\n`````ts\n{\n\"name\": \"typescript-with-tsc\",\n\"version\": \"1.0.0\",\n\"description\": \"\",\n\"main\": \"index.js\",\n\"scripts\": {\n  \"build\": \"./node_modules/.bin/tsc --project ./tsconfig.json --watch\",\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n\"author\": \"\",\n\"license\": \"ISC\",\n\"devDependencies\": {\n  \"typescript\": \"^2.5.2\"\n}\n}\n`````\nОсталось только создать в директории _src_ файл _index.ts_ и запустить процесс разработки, выполнив в консоли команду:\n\n`````ts\nnpm run build\n`````\n\nПосле этого в папке _dest_ должен появится скомпилированный _index.js_, а при изменении файлов в директории _src_ преобразование должно запускаться автоматически. Сразу стоит обратить внимание на то, как именно компилятор понимает, какие файлы компилировать. \n\nДля примера, создадим в директории _src_ файл _hello-world.ts_, в котором объявим функцию, возвращающее приветствие.\n\n`````ts\n// Файл hello-world.ts\n\n\nexport function getMassage(): string {\n  return 'Hello World!';\n}\n`````\n\nВажный момент заключается в том, что компилятор не будет обращать на этот файл внимание, пока он не будет задействован в программе, то есть не будет импортировать в `index.js`\n\n`````ts\nimport {getMassage} from './hello-world';\n\nconsole.log(getMassage()); // Hello World!\n`````\n\nТакое поведение называется _Tree Shaking_ и если по каким-либо причинам его нужно переопределить, то для этого нужно поправить конфигурацию компилятора, определив параметр `includes` представляющий массив ссылок на файлы которые необходимо компилировать независимо от их использования проектом.\n\n`````ts\n{\n\"compilerOptions\": {\n  \"target\": \"es5\",\n  \"module\": \"system\",\n  \"outFile\": \"./dest/build.js\",\n  \"rootDir\": \"./src/\"  \n  },\n  \"include\": [\n    \"./src/__/*.ts\"\n  ],\n  \"exclude\": [\n    \"/node_modules/\"\n  ]\n}\n`````\n\nОчень часто бывает так, что при разработке в коде используются библиотеки, которых не должно быть в конечной сборке. Можно было бы каждый раз переписывать конфигурационный файл _tsconfig.json_, но есть способ сделать это элегантнее. Разделение _dev_ сборки от _prod_ осуществляется путем создания ещё одного конфигурационного файла. Назовем его _tsconfig.prod.json_ и поместим в корне проекта. Стоит добавить, что конфигурационные файлы можно размещать где угодно, главное при запуске компилятора указать путь к нужному конфигу с помощью опции `--project`. Если это не сделать, компилятор будет искать файл _tsconfig.json_ в той директории из под которой он был запущен.\n\n`````sh\ntsc -b --project ./tsconfig.json\n`````\n\nИли...\n\n`````sh\ntsc -b ./tsconfig.json\n`````\n\nИли...\n\n`````sh\ntsc -b --project ./tsconfig.props.json\n`````\n\nИли...\n\n`````sh\ntsc -b ./tsconfig.props.json\n`````\n\nПосле того, как конфигурационный файл был создан и отредактирован требуемым образом, остается только создать команду для запуска _prod_ сборки. Для этого снова откройте файл _package.json_ и в свойстве `script` укажите команду запуска компиляции, только на этот раз укажите путь до _tsconfig.prod.json_. Единственное, на, что стоит обратить внимание, при финальной сборке не нужно указывать опцию `--watch`, которая заставляет компилятор отслеживать изменения в файлах и автоматически перезапускать сборку.\n\n`````ts\n{\n\"name\": \"typescript-with-tsc\",\n\"version\": \"1.0.0\",\n\"description\": \"\",\n\"main\": \"index.js\",\n\"scripts\": {\n  \"build\": \"./node_modules/.bin/tsc --project ./tsconfig.json --watch\",\n  \"build:prod\": \"./node_modules/.bin/tsc --project ./tsconfig.prod.json\",\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n\"author\": \"\",\n\"license\": \"ISC\",\n\"devDependencies\": {\n  \"@types/react\": \"^16.0.5\",\n  \"@types/react-dom\": \"^15.5.4\",\n  \"react\": \"^15.6.1\",\n  \"react-dom\": \"^15.6.1\",\n  \"typescript\": \"^2.5.2\"\n}\n}\n`````\n\nЧтобы запустить сборку, нужно, как и прежде, выполнить команду в терминале, только на этот раз указать другое имя.\n\n`````sh\nnpm run build:prod\n`````\n\nТакже не будет лишним упомянуть, что реальные проекты практически всегда изобилуют множеством конфигурационных файлов. Поэтому если у Вас возникает мысль, что один конфигурационный файл не удовлетворяет условиям нескольких сборок, даже не раздумывайте, создавайте отдельный конфигурационный файл. При этом не отбрасывайте вариант с расширением одного конфигурационного файла другим с помощью свойства `extends`, более подробно о котором можно узнать из главы посвященной опциям компилятора."}],"githubFileInfo":{"lastUpdate":1633879471000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Пространства имен (namespace) и модули (module)","path":"Prostranstva_imen_(namespace)_i_moduli_(module)"},"nextPage":{"title":"Сборка с использованием ссылок на проекты","path":"Sborka_s_ispolzovaniem_ssylok_na_proekty"}},"contentNavData":{"key":"Настройка рабочего окружения","level":0,"index":58,"contentIndex":0,"section":"Сборка","title":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya","elementId":"Nastroika_rabochego_okrujeniya","children":[{"key":"Настройка рабочего окружения_0","index":0,"contentIndex":1,"level":1,"section":"Сборка","title":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya","elementId":"Nastroika_rabochego_okrujeniya"},{"key":"Настройка рабочего окружения_1","index":1,"contentIndex":2,"level":1,"section":"Сборка","title":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"Sborka_proekta_s_pomoshchu_tsc_(TypeScript_compiler)","elementId":"Sborka_proekta_s_pomoshchu_tsc_(TypeScript_compiler)"}]},"pageDescription":"Настройка рабочего окружения"},"__N_SSG":true}