{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/041.(Типизация) Совместимость функциональных типов (Compatible Function Types)/images/"},"sectionInfoAll":[{"key":"Совместимость функциональных типов (Compatible Function Types)","elementId":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)","markdown":"# Совместимость функциональных типов (Compatible Function Types)\n\nПосле объектных типов, мир совместимости функциональных типов может показаться перевернутым с ног на голову. Он обладает множеством нюансов, каждый из которых будет детально рассмотрен в текущей главе."},{"key":"Совместимость функциональных типов (Compatible Function Types)_0","elementId":"Vajno","markdown":"## Важно\n\nВажной частью работы с функциями является понимание совместимости функциональных типов. Поверхностное понимание механизма совместимости функциональных типов может сложить ошибочное чувство их постижения, поскольку то, что на первый взгляд может казаться очевидным, не всегда может являться таковым. Для того, что бы понять замысел создателей _TypeScript_, нужно детально разобрать каждый момент. Но прежде стоит уточнить одну деталь. В примерах, которые будут обсуждаться в главе, посвященной типизации функциональных типов, будет использоваться уточняющий шаблон `: Target = Source`. Кроме того, объектные типы, указанные в сигнатуре функции, ведут себя так же, как было описано в главе, посвященной совместимости объектных типов."},{"key":"Совместимость функциональных типов (Compatible Function Types)_1","elementId":"Sovmestimost_parametrov","markdown":"## Совместимость параметров\n\nПервое, на, что стоит обратить внимание, это параметры функции. На параметры функции приходится наибольшее количество неоднозначностей, связанных с совместимостью.\n\nНачать стоит с того, что две сигнатуры считаются совместимыми, если они имеют равное количество параметров с совместимыми типами данных.\n\n`````ts\ntype T1 = (p1: number, p2: string) => void;\n\nlet v1: T1 = (p3: number, p4: string) => {}; // Ok -> разные идентификаторы\nlet v2: T1 = (p1: number, p2: boolean) => {}; // Error\n`````\n\nПри этом стоит заметить, что идентификаторы параметров не участвуют в проверке на совместимость.\n\n`````ts\ntype T1 = (...rest: number[]) => void;\n\nlet v1: T1 = (...numbers: number[]) => {}; // Ok -> разные идентификаторы\n`````\n\nКроме того, параметры, помеченные как необязательные, учитываются только тогда, когда они участвуют в проверке на совместимость по признакам количества параметров.\n\n`````ts\ntype T1 = (p1: number, p2?: string) => void;\n\nlet v1: T1 = (p1: number) => {}; // Ok\nlet v2: T1 = (p1: number, p2: string) => {}; // Ok или Error с включенным флагом --strictNullChecks\nlet v3: T1 = (p1: number, p2: boolean) => {}; // Error\nlet v4: T1 = (p1: number, p2?: boolean) => {}; // Error\n`````\n\nФункция, имеющая определение остаточных параметров, будет совместима в обе стороны с любой функцией, так как остаточные параметры расцениваются способными принадлежать к любому типу и чье количество находится в диапазоне от нуля до бесконечности.\n\n`````ts\ntype T1 = (...rest: any[]) => void;\ntype T2 = (p0: number, p1: string) => void;\n\nlet v0: T1 = (...rest) => {};\nlet v1: T2 = (p0, p1) => {};\n\nlet v2: T1 = v1; // Ok\nlet v3: T2 = v0; // Ok\n`````\n\nВ случае, если перед остаточными параметрами объявлены обязательные параметры, то функция будет совместима с любой другой функцией, которая совместима с обязательной частью.\n\n`````ts\ntype T0 = (p0: number, ...rest: any[]) => void;\ntype T1 = (p0: number, p1: string) => void;\ntype T2 = (p0: string, p1: string) => void;\n\nlet v0: T0 = (p0, ...rest) => {};\nlet v1: T1 = (p0, p1) => {};\nlet v2: T2 = (p0, p1) => {};\n\nlet v3: T0 = v1; // Ok\nlet v4: T1 = v0; // Ok\nlet v5: T2 = v0; // Error\nlet v6: T0 = v2; // Error\n`````\n\nСледующий, один из неочевидных моментов совместимости функциональных типов, заключается в том, что сигнатура с меньшим числом параметров, совместима с сигнатурой, с большим числом параметров, но не наоборот. Это правило верно при условии соблюдения предыдущих правил, относящихся к совместимости типов.\n\n`````ts\ntype T0 = (p0: number, p1: string) => void;\ntype T1 = () => void;\n\nlet v0: T0 = () => {}; // Ok\nlet v1: T0 = (p: number) => {}; // Ok\nlet v3: T1 = (p?: number) => {}; // Ok -> необязательный параметр\nlet v4: T1 = (p: number) => {}; // Error -> обязательных параметров больше чем в типе T1\n`````\n\nНа данный момент уже известно, что два объектных типа (`:T = S`), на основании структурной типизации, считаются совместимыми, если в типе `S` присутствуют все признаки типа `T`. Помимо этого, тип `S` может быть более специфичным, чем тип `T`. Простыми словами, тип `S`, помимо всех признаков, присущих в типе `T`, также может обладать признаками которые в типе `T` отсутствуют, но не наоборот. Если ещё более просто, то больший тип совместим с меньшим типом данных. В случае с параметрами функциональных типов, все с точностью наоборот.\n\n`````ts\ntype T = (p0: number) => void;\n\nlet v0: T = (p0) => {}; // Ok, такое же количество параметров\nlet v1: T = () => {}; // Ok, параметров меньше\nlet v2: T = (p0, p1) => {}; // Error, параметров больше\n`````\n\nТакое поведение проще всего объяснить на примере работы с методами массива. За основу будет взята декларация метода `forEach` из библиотеки `lib.es5.d.ts`.\n\n`````ts\nforEach(callbackFn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n`````\n\nВ данном случае нужно обратить внимание на функциональный тип первого параметра, описывающего три других параметра.\n\n`````ts\ncallbackFn: (value: T, index: number, array: T[]) => void;\n`````\n\nЕсли бы функциональный тип с большим числом параметров не был совместим с функциональным типом с меньшим числом параметров, то при работе с методом `forEach`, при необходимости только в одном, первом параметре, обязательно бы приходилось создавать _callback_ со всеми тремя параметрами, что привело бы к излишнему коду.\n\n`````ts\nclass Animal { name: string; }\nclass Elephant extends Animal {}\nclass Lion extends Animal {}\n\nlet animals: Animal[] = [\n    new Elephant(),\n    new Lion()\n];\n\nlet animalNames: string[] = [];\n\nanimals.forEach((value, index, source) => { // Плохо\n    animalNames.push(value.name);\n});\n\nanimals.forEach(value => { // Хорошо\n    animalNames.push(value.name);\n});\n`````\n\nКроме того, обобщенные функции, чьим параметрам в качестве типа указан параметр типа, проверяются на совместимость по стандартному сценарию.\n\n`````ts\nfunction f0<T>(p0: T): void {}\nfunction f1<T, S>(p0: T, p1: S): void {}\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Error\nlet v1: T1 = f0; // Ok\n`````\n\nТакже стоит знать, что параметры, принадлежащие к конкретным типам, совместимы с параметрами, которым в качестве типов указаны параметры типа, но не наоборот.\n\n`````ts\nfunction f0<T>(p: T): void {}\nfunction f1(p: number): void {}\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Error, параметр типа T не совместим с параметром типа number\nlet v1: T1 = f0; // Ok, параметр типа number совместим с параметром типа T\n`````\n\nПомимо того, что две сигнатуры считаются совместимыми если участвующие в проверке параметры принадлежат к одному типу, они также считаются совместимыми при совместимости типов этих параметров. Но с этим связана ещё одна неочевидность. Как известно, в контексте объектных типов, если тип `T1` не идентичен полностью типу `T2`, и при этом тип `T1` совместим с типом `T2`, то значит тип `T2` будет совместим с типом `T1` через операцию приведения типов.\n\n`````ts\nclass T0 { f0: number; }\nclass T1 { f0: number; f1: string; }\nlet v0: T0 = new T1(); // Ok -> неявное преобразование типов\n\nlet v1: T1 = new T0(); // Error\nlet v2: T1 = new T0() as T1; // Ok -> явное приведение типов\n`````\n\nС типами в аннотации параметров функций все, то же самое, только не требуется явного преобразование типов. Такое поведение называется бивариантностью параметров и создано для того, что бы сохранить совместимость с распространенными в _JavaScript_ практиками. Подробно бивариантность была рассмотрена в главе [“Экскурс в типизацию - Совместимость типов на основе вариантности”](../010.(Экскурс%20в%20типизацию)%20Совместимость%20типов%20на%20основе%20вариантности).\n\n`````ts\nclass T0 { f0: number; }\nclass T1 { f0: number; f1: string; }\n\nfunction f0(p: T1): void {}\nfunction f1(p: T0): void {}\n\ntype FT0 = typeof f0;\ntype FT1 = typeof f1;\n\n// бивариантное поведение\nlet v0: FT0 = f1; // Ok, параметр с типом T1 совместим с параметром принадлежащим к типу T0. Кроме того, тип T1 совместим с типом T0.\nlet v1: FT1 = f0; // Ok, параметр с типом T0 совместим с параметром принадлежащем к типу T1. Но тип T0 не совместим с типом T1  без явного приведения.\n`````\n\nИзменить поведение бивариантного сопоставления параметров можно с помощью опции компилятора `--strictFunctionTypes`. Установив флаг `--strictFunctionTypes` в `true`, сопоставление будет происходить по контрвариантным правилам (глава [“Экскурс в типизацию - Совместимость типов на основе вариантности”](../010.(Экскурс%20в%20типизацию)%20Совместимость%20типов%20на%20основе%20вариантности)).\n\n`````ts\nclass T0 { f0: number; }\nclass T1 { f0: number; f1: string; }\n\nfunction f0(p: T1): void {}\nfunction f1(p: T0): void {}\n\ntype FT0 = typeof f0;\ntype FT1 = typeof f1;\n\n// контрвариантное поведение\nlet v0: FT0 = f1; // Ok\nlet v1: FT1 = f0; // Error\n`````"},{"key":"Совместимость функциональных типов (Compatible Function Types)_2","elementId":"Sovmestimost_vozvrashchaemogo_znacheniya","markdown":"## Совместимость возвращаемого значения\n\nПервое, на, что стоит обратить внимание, это ожидаемое поведение при проверке на совместимость возвращаемых типов. Другими словами, две сигнатуры считаются совместимыми, если их типы, указанные в аннотации возвращаемого значения, совместимы по правилам структурной типизации, которой подчиняются все объекты в _TypeScript_.\n\n`````ts\nclass T0 { f0: number; }\nclass T1 { f0: number; f1: string; }\n\ntype FT0 = () => T0;\ntype FT1 = () => T1;\n\nlet v0: FT0 = () => new T1(); // Ok\nlet v1: FT1 = () => new T0(); // Error\n`````\n\nИсключением из этого правила составляет примитивный тип данных `void`. Как стало известно из главы посвященной типу данных `void`, в обычном режиме он совместим только с типами `null` и `undefined`, так как они являются его подтипами. При активной рекомендуемой опции `--strictNullChecks`, примитивный тип `void` совместим только с типом `undefined`.\n\n`````ts\nlet v0: void = null; // Ok and Error с включенным флагом strictNullChecks\nlet v1: void = undefined; // Ok\n`````\n\nНо это правило неверно, если тип `void` указан в аннотации возвращаемого из функции значения. В случаях, когда примитивный тип `void` указан в качестве возвращаемого из функции типа, он совместим со всеми типами, без исключения.\n\n`````ts\ntype T = () => void;\n\nlet v0: T = () => 0; // Ok\nlet v1: T = () => ''; // Ok\nlet v2: T = () => true; // Ok\nlet v3: T = () => ({}); // Ok\n`````\n\nПричину по которой поведение типа `void` при указании его в аннотации возвращаемого из функции значения было изменено лучше рассмотреть на примере работы с массивом, а точнее его методом `forEach`.\n\nПредположим есть два массива. Первый массив состоит из элементов принадлежащих к объектному типу у которого определенно поле `name`. Второй массив предназначен для хранения строк и имеет длину равную `0`.\n\n`````ts\nclass Animal { \n    name: string;\n}\n\nlet animals: Animal[] = [\n    new Animal(),\n    new Animal()\n];\n`````\n\nЗадача заключается в получении имен объектов из первого массива с последующим сохранением их во второй массив.\n\nДля этого потребуется определить стрелочную функцию обратного вызова (_callback_). Слева от стрелки будет расположен один параметр `value`, а справа — операция сохранения имени во второй массив с помощью метода `push`. Если обратится к декларации метода массива `forEach`, то можно убедится, что в качестве функции обратного вызова этот метод принимает функцию у которой отсутствует возвращаемое значение.\n\n`````ts\nforEach(callbackFn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n`````\n\nНо в нашем случае в теле функции обратного вызова происходит операция добавления элемента в массив. Результатом этой операции является значение длины массива. То есть, метод `push` возвращает значение, принадлежащий к типу `number`, которое в свою очередь возвращается из стрелочной функции обратного вызова, переданного в метод `forEach`, у которого этот параметр задекларирован как функция возвращающая тип `void`, что противоречит возвращенному типу `number`. В данном случае отсутствие ошибки объясняется совместимостью типа `void`, используемого в функциональных типах, со всеми остальными типами.\n\n`````ts\nclass Animal { name: string; }\n\nlet animals: Animal[] = [\n    new Animal(),\n    new Animal()\n];\n\nlet animalNameAll: string[] = [];\n\nanimalNameAll.forEach( animal => animalNameAll.push( animal.name ) ); // forEach ожидает () => void, а получает () => number, так как стрелочная функция без тела неявно возвращает значение, возвращаемое методом push.\n`````\n\nИ напоследок стоит упомянуть, что две обобщенные функции считаются совместимы, если у них в аннотации возвращаемого значения указан параметр типа.\n\n`````ts\nfunction f0<T>(p: T): T { return p; }\nfunction f1<S>(p: S): S { return p; }\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Ok\nlet v1: T1 = f0; // Ok\n`````\n\nКроме того, параметр типа совместим с любым конкретным типом данных, но не наоборот.\n\n`````ts\nfunction f0<T>(p: T): T { return p; }\nfunction f1(p: number): number { return p; }\n\ntype T0 = typeof f0;\ntype T1 = typeof f1;\n\nlet v0: T0 = f1; // Error\nlet v1: T1 = f0; // Ok\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Совместимость объектных типов (Compatible Object Types)","path":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)"},"nextPage":{"title":"Совместимость объединений (Union Types)","path":"Sovmestimost_obedinenii_(Union_Types)"}},"contentNavData":{"key":"Совместимость функциональных типов (Compatible Function Types)","level":0,"index":41,"contentIndex":0,"section":"Типизация","title":"Совместимость функциональных типов (Compatible Function Types)","path":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)","elementId":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)","children":[{"key":"Совместимость функциональных типов (Compatible Function Types)_0","index":0,"contentIndex":1,"level":1,"section":"Типизация","title":"Важно","path":"Vajno","elementId":"Vajno"},{"key":"Совместимость функциональных типов (Compatible Function Types)_1","index":1,"contentIndex":2,"level":1,"section":"Типизация","title":"Совместимость параметров","path":"Sovmestimost_parametrov","elementId":"Sovmestimost_parametrov"},{"key":"Совместимость функциональных типов (Compatible Function Types)_2","index":2,"contentIndex":3,"level":1,"section":"Типизация","title":"Совместимость возвращаемого значения","path":"Sovmestimost_vozvrashchaemogo_znacheniya","elementId":"Sovmestimost_vozvrashchaemogo_znacheniya"}]},"pageDescription":"Совместимость функциональных типов (Compatible Function Types)"},"__N_SSG":true}