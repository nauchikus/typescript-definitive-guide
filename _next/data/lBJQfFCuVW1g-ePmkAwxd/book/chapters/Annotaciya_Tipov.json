{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/011.(Синтаксические конструкции) Аннотация Типов/images/"},"sectionInfoAll":[{"key":"Аннотация Типов","elementId":"Annotaciya_Tipov","markdown":"# Аннотация Типов\nЧтобы избавится от страха возникающего от слова _типизация_, необходимо в самом начале увидеть все преобразования которые проделал _TypeScript_ над своим фундаментом коим для него является, никого не оставляющий равнодушным _JavaScript_."},{"key":"Аннотация Типов_0","elementId":"Annotaciya_Tipov_-_obshchee","markdown":"## Аннотация Типов - общее\n\nКак уже было сказано ранее, _TypeScript_ — это типизированная надстройка над _JavaScript_. Другими словами _TypeScript_ не добавляет никаких новых языковых конструкций (за исключением `Enum`, которая будет рассмотрена чуть позже), а лишь расширяет синтаксис _JavaScript_ за счет добавления в него типов. По этой причине в этой книге не будут затрагиваться темы относящиеся к _JavaScript_, так как она рассчитана на тех, кто уже знаком с его основами. Именно поэтому погружение в типизированный мир _TypeScript_ необходимо начать с рассмотрения того как типизация преобразила _JavaScript_ конструкции."},{"key":"Аннотация Типов_1","elementId":"Annotaciya_tipa","markdown":"## Аннотация типа\n\nВ _TypeScript_ аннотация типа или указание типа осуществляется с помощью оператора двоеточия `:`, после которого следует идентификатор типа. _TypeScript_ является статически типизированным языком, поэтому после того как идентификатор будет связан с типом, изменить тип будет невозможно."},{"key":"Аннотация Типов_2","elementId":"Sintaksicheskie_konstrukcii_var,let,const","markdown":"## Синтаксические конструкции var, let, const\n\n\nПри объявлении синтаксических конструкций объявляемых с помощью операторов `var`, `let` и `const`, тип данных указывается сразу после идентификатора.\n\n`````ts\nvar identifier: Type = value;\nlet identifier: Type = value;\nconst IDENTIFIER: Type = value;\n`````"},{"key":"Аннотация Типов_3","elementId":"Funkcii_(function)","markdown":"## Функции (function)\n\n\nПри объявлении функции тип возвращаемого ею значения указывается между её параметрами и телом. При наличии параметров, тип данных указывается и для них.\n\n`````ts\nfunction identifier(param1: Type, param2: Type): ReturnedType {\n\n}\n`````\n\nНе будет лишним напомнить, что в отличие от _JavaScript_, в _TypeScript_ в сигнатуру функции помимо её имени и параметров также входит и возвращаемое значение.\n\nПомимо этого, в _TypeScript_ можно объявлять параметризированные функции. Функции, имеющие параметры типа, называются обобщенными (подробнее о них речь пойдет в главе [“Типы - Обобщения (Generics)”](../032.(Типы)%20Обобщения%20(Generics))). Параметры типа заключаются в угловые скобки `<>` и располагаются перед круглыми скобками `()`, в которые заключены параметры функции.\n\n`````ts\nfunction identifier <T, U>(): ReturnedType {\n\n}\n`````\n\nКроме того, _TypeScript_ расширяет границы типизирования функций и методов с помощью незнакомого _JavaScript_ разработчикам механизма _перегрузки функций_. С помощью перегрузки функций можно аннотировать функции с одинаковыми идентификаторами, но с различными сигнатурами.\n\nДля этого перед определением функции, метода или функции-конструктора перечисляются совместимые объявления одних только сигнатур. Более подробно эта тема будет освещена позднее.\n\n`````ts\nfunction identifier(p1: T1, p2: T2): T3;\nfunction identifier(p1: T4, p2: T5): T6;\nfunction identifier(p1: T, p2: T): T {\n    return 'value';\n}\n\nconst a: T1 = 'value';\nconst b: T2 = 'value';\nconst c: T4 = 'value';\nconst d: T5 = 'value';\n\nidentifier(a, b); // валидно\nidentifier(c, d); // валидно\n\nclass Identifier {\n    constructor(p1: T1, p2: T2);\n    constructor(p1: T4, p2: T5);\n    constructor(p1: T, p2: T) {\n    \n    }\n    \n    identifier(p1: T1, p2: T2): T3;\n    identifier(p1: T4, p2: T5): T6;\n    identifier(p1: T, p2: T): T {\n        return 'value';\n    }\n}\n`````"},{"key":"Аннотация Типов_4","elementId":"Strelochnye_Funkcii_(arrow_function)","markdown":"## Стрелочные Функции (arrow function)\n\n\nК стрелочным функциям применимы те же правила указания типов данных, что и для обычных функций, за исключением того, что возвращаемый ими тип указывается между параметрами и стрелкой.\n\n`````ts\n<T, U>(param: Type, param2: Type): Type => value;\n`````"},{"key":"Аннотация Типов_5","elementId":"Klassy_(class)","markdown":"## Классы (class)\n\n\nПрежде чем продолжить рассмотрение изменений которые привнёс _TypeScript_ в нетипизированный мир _JavaScript_, хотелось бы предупредить о том, что относительно классов будет использоваться терминология заимствованная из таких языков, как _Java_ или _C#_, так как она способствует большей ясности (тем более, что в спецификации _TypeScript_ встречается аналогичная терминология). Так, _переменные экземпляра_ и _переменные класса_ (статические переменные) в этой книге обозначаются как _поля_ (_field_). _Аксессоры_ (_get_\\_set_) обозначаются как _свойства_ (_property_). А, кроме того, поля, свойства, методы, _вычисляемые свойства_ (_computed property_) и _индексируемые сигнатуры_ (_index signature_) обозначаются как _члены_ класса (_member_).\n\nПри объявлении поля класса, как и в случае с переменными, тип данных указывается сразу после идентификатора (имени класса). Для методов класса действуют те же правила указания типов, что и для обычных функций.\n\nДля свойств, в частности для `get`, указывается тип данных возвращаемого значения. Для `set` указывается лишь тип единственного параметра, а возвращаемый им тип и вовсе запрещается указывать явно.\n\nКроме того, классы в _TypeScript_ также могут быть обобщенными. В случае объявления обобщенного класса, параметры типа, заключенные в треугольные скобки, указываются сразу после идентификатора класса.\n\n`````ts\nclass Identifier<T> {\n    static staticField: Type = value; // член класса\n    \n    static get staticProperty(): Type { // член класса\n        return value;\n    }\n    \n    static set staticProperty(value: Type) { // член класса\n     \n    }\n    \n    static staticMethod <T, U>(param0: Type, param1: Type): Type { // член класса\n    \n    }\n    \n    static { // статический блок\n        \n    }\n\n    [indexSignature: Type]: Type; // член класса\n    \n    [computedProp]: Type = value; // член класса\n    \n    field: Type = value; // член класса\n    \n    get property(): Type { // член класса\n        return value;\n    }\n\n    set property(value: Type) { // член класса\n     \n    }\n    \n    constructor(param0: Type, param1: Type) {\n    \n    }\n    \n    method <T, U>(param0: Type, param1: Type): Type { // член класса\n    \n    }\n}\n`````"},{"key":"Аннотация Типов_6","elementId":"Sravnenie_Sintaksisa_TypeScript_i_JavaScript","markdown":"## Сравнение Синтаксиса TypeScript и JavaScript\n\n\nПеред тем, как подвести итоги этой главы, не будет лишним собрать все рассмотренные _TypeScript_ конструкции и наглядно сравнить их со своими нетипизированными _JavaScript_ аналогами.\n\n`````ts\n// .ts\nvar identifier: Type = value;\nlet identifier: Type = value;\nconst IDENTIFIER: Type = value;\n//  .js\nvar identifier = value;\nlet identifier = value;\nconst IDENTIFIER = value;\n\n// .ts\nfunction identifier(param1: Type, param2: Type): ReturnedType {\n\n}\n\n// .js\nfunction identifier(param1, param2) {\n\n}\n\n// .ts\nclass Identifier<T> {\n    static staticField: Type = value; \n    \n    static get staticProperty(): Type {\n        return value;\n    }\n    \n    static set staticProperty(value: Type) {\n     \n    }\n    \n    static staticMethod <T, U>(param0: Type, param1: Type): Type {\n    \n    }\n    \n    [indexSignature: Type]: Type; \n    \n    [computedProp]: Type = value; \n    \n    field: Type = value;\n    \n    get property(): Type {\n        return value;\n    }\n\n    set property(value: Type) {\n     \n    }\n    \n    constructor(param0: Type, param1: Type) {\n    \n    }\n    \n    method <T, U>(param0: Type, param1: Type): Type {\n    \n    }\n}\n\n// .js\nclass Identifier {\n    static staticField = value; \n    \n    static get staticProperty() {\n        return value;\n    }\n    \n    static set staticProperty(value) {\n     \n    }\n    \n    static staticMethod (param, param) {\n    \n    }\n    \n    [computedProp] = value; \n    \n    field = value;\n    \n    get property() {\n        return value;\n    }\n    \n    set property(value) {\n     \n    }\n    \n    constructor(param0, param1) {\n    \n    }\n    \n    method (param0, param1) {\n    \n    }\n}\n`````"},{"key":"Аннотация Типов_7","elementId":"Itog","markdown":"## Итог\n\n- Аннотация типа устанавливается оператором двоеточия `:`, после которого следует указание типа данных.\n- При объявлении переменных тип данных указывается сразу после идентификатора.\n- У функций и методов класса возвращаемый тип данных указывается между параметрами и телом.\n- У стрелочных функций возвращаемый тип данных указывается между параметрами и стрелкой.\n- У функций, стрелочных функций и методов класса, параметрам также указывается тип данных.\n- При необходимости функциям, стрелочным функциям и методам класса можно указать параметры типа, которые заключаются в угловые скобки и указываются перед круглыми скобками, в которых размещаются параметры функции.\n- В *TypeScript* аннотирование типов у функций, методов и конструкторов расширено при помощи перегрузки функций.\n- Для полей класса тип данных указывается сразу после идентификатора-имени.\n- Для геттеров (getters) указывается возвращаемый тип данных.\n- Для сеттеров (setters) указывается тип единственного параметра и вовсе не указывается возвращаемый тип."}],"githubFileInfo":{"lastUpdate":1632217990000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Ivan Khizhnyak","avatar":"https://avatars.githubusercontent.com/u/56488853?v=4","bio":"","githubUrl":"https://github.com/ivanjulian"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Совместимость типов на основе вариантности","path":"Sovmestimost_tipov_na_osnove_variantnosti"},"nextPage":{"title":"Базовый Тип Any","path":"Bazovyi_Tip_Any"}},"contentNavData":{"key":"Аннотация Типов","level":0,"index":11,"contentIndex":0,"section":"Синтаксические конструкции","title":"Аннотация Типов","path":"Annotaciya_Tipov","elementId":"Annotaciya_Tipov","children":[{"key":"Аннотация Типов_0","index":0,"contentIndex":1,"level":1,"section":"Синтаксические конструкции","title":"Аннотация Типов - общее","path":"Annotaciya_Tipov_-_obshchee","elementId":"Annotaciya_Tipov_-_obshchee"},{"key":"Аннотация Типов_1","index":1,"contentIndex":2,"level":1,"section":"Синтаксические конструкции","title":"Аннотация типа","path":"Annotaciya_tipa","elementId":"Annotaciya_tipa"},{"key":"Аннотация Типов_2","index":2,"contentIndex":3,"level":1,"section":"Синтаксические конструкции","title":"Синтаксические конструкции var, let, const","path":"Sintaksicheskie_konstrukcii_var,let,const","elementId":"Sintaksicheskie_konstrukcii_var,let,const"},{"key":"Аннотация Типов_3","index":3,"contentIndex":4,"level":1,"section":"Синтаксические конструкции","title":"Функции (function)","path":"Funkcii_(function)","elementId":"Funkcii_(function)"},{"key":"Аннотация Типов_4","index":4,"contentIndex":5,"level":1,"section":"Синтаксические конструкции","title":"Стрелочные Функции (arrow function)","path":"Strelochnye_Funkcii_(arrow_function)","elementId":"Strelochnye_Funkcii_(arrow_function)"},{"key":"Аннотация Типов_5","index":5,"contentIndex":6,"level":1,"section":"Синтаксические конструкции","title":"Классы (class)","path":"Klassy_(class)","elementId":"Klassy_(class)"},{"key":"Аннотация Типов_6","index":6,"contentIndex":7,"level":1,"section":"Синтаксические конструкции","title":"Сравнение Синтаксиса TypeScript и JavaScript","path":"Sravnenie_Sintaksisa_TypeScript_i_JavaScript","elementId":"Sravnenie_Sintaksisa_TypeScript_i_JavaScript"},{"key":"Аннотация Типов_7","index":7,"contentIndex":8,"level":1,"section":"Синтаксические конструкции","title":"Итог","path":"Itog","elementId":"Itog"}]},"pageDescription":"Аннотация Типов"},"__N_SSG":true}