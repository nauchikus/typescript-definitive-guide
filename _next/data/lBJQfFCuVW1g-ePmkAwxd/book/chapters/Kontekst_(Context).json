{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/055.(React) Контекст (Context)/images/"},"sectionInfoAll":[{"key":"Контекст (Context)","elementId":"Kontekst_(Context)","markdown":"# Контекст (Context)\n\nДанная глава посвящена рассмотрению влияния типизации на такой механизм как _контекст_, который хотя и не привносит ничего, что на текущий момент могло бы вызвать удивление, все же имеет один не очевидный момент."},{"key":"Контекст (Context)_0","elementId":"Opredelenie_konteksta","markdown":"## Определение контекста\n\nОпределение контекста осуществляется при помощи универсальной функции определяющей один обязательный параметр выступающий в качестве инициализационного значения и возвращающей объект контекста `createContext<T>(initialValue: T): Context<T>`. В случаях когда инициализационное значение в полной мере соответствует предполагаемому типу, чьё описание не включает необязательных членов, то аргументы типа можно или даже нужно не указывать. В остальных случаях это становится необходимостью.\n\n`````ts\nimport {createContext } from \"react\";\n\n\n/**Аргумента типа не требуется */\n\ninterface AContext {\n    a: number;\n    b: string;\n}\n\n         /**[0]             [1][2] */\nexport const A = createContext({\n    a: 0,\n    b: ``\n});\n\n/**\n * Поскольку при определении контекста [0]\n * в качестве обязательного аргумента было\n * установлено значение [2] полностью соответствующее\n * предполагаемому типу AContext, аргумент типа\n * универсальной функции можно опустить [1].\n * \n */\n\n\n /**Требуется аргумент типа */\n\ninterface BContext extends AContext {\n    c?: boolean;\n}\n\n                               /**[0]     [1] */\nexport const B = createContext<BContext>({\n    a: 0,\n    b: ``\n});\n\n\n/**\n * Так как инициализационное значение [1]\n * лишь частично соответствует предполагаемому\n * типу BContext тип объекта контекста необходимо\n * конкретизировать при помощью аргументов типа [0]\n */\n\n\n/**Требуется аргумент типа */\n\n                                    /**[0]       [1] */\nexport const C = createContext<BContext | null>(null);\n\n/**\n * По причине отсутствия на момент определения \n * инициализационного значения оно заменено на null [1],\n *, что требует упомянуть при конкретизации типа значения [0].\n */\n `````"},{"key":"Контекст (Context)_1","elementId":"Ispolzovanie_konteksta","markdown":"## Использование контекста\n\nПоскольку функциональные и классовые компоненты подразумевают различные подходы для взаимодействия с одними механизмами реализуемыми _React_, после регистрации контекста в _react дереве_ работа с ним зависит от вида компонента нуждающегося в поставляемых им данных.\n\nПосле определения контекста необходимо зарегистрировать в _react дереве_ предоставляемого им `Provider` установив ему необходимые данные.\n\n\n`````ts\nimport React, {createContext } from \"react\";\n\n/**0 */\nconst Context = createContext({\n    status: ``,\n    message: ``\n});\n\n/**\n * [0] определение контекста.\n */\n\n   /**[1] */\nconst App = () => (\n        /**[2]                                 [3] */\n    <Context.Provider value={{status: `init`, message: `React Context!`}}>\n\n    </Context.Provider>\n)\n\n/**\n * [1] определяем компонент представляющий точку входа\n * в приложение и регистрируем в его корне Provider [2]\n * которому при инициализации устанавливаем необходимое значение [3].\n */\n`````\n\nНа следующем шаге определим классовый компонент и добавим его в ветку, корнем которой является определенный на предыдущем шаге `Provider`.\n\n`````ts\nconst App = () => (\n    <Context.Provider value={{status: `init`, message: `React Context!`}}>\n        <ClassComponent /> \n    </Context.Provider>\n)\n\nclass ClassComponent extends Component {\n    render(){\n        return (\n        );\n    }\n}\n`````\n\nПоскольку компонент является классовым, единственный способ добраться до предоставляемых контекстом данных заключается в создании экземпляра `Consumer`, который в качестве `children` ожидает функцию обозначаемую как `render callback`. Данная функция определяет единственный параметр принадлежащий к типу данных передаваемых с помощью контекста, а возвращаемое ею значение должно принадлежать к любому допустимому типу представляющему элемент _React дерева_.\n\n`````ts\nclass ClassComponent extends Component {\n    render(){\n        return (\n                  /**[0]        [1]               [2] */\n            <Context.Consumer >{data => <span>{data.message}</span>}</Context.Consumer>\n        );\n    }\n}\n\n/**\n * Поскольку компонент ClassComponent является\n * классовым, единственный вариант получить в нем\n * данные предоставляемые контекстом заключается\n * в создании экземпляра Consumer, который в качестве\n * children ожидает функцию обозначаемую как render callback\n * единственный параметр которой принадлежит к типу данных, а\n * возвращаемое значение должно принадлежать к одному из допустимых\n * типов предполагаемых React.\n */\n `````\n\nСлучаи предполагающие определение `render callback` вне `Consumer` потребуют указания аннотации типа его единственному параметру, тип для которого лучше объявить в месте определения контекста. Если данные инициализации в полной мере соответствуют ожидаемому типу, то его получение проще выполнить с помощью механизма _запроса типа_, чем описывать вручную. В остальных случаях описание потребуется выполнять самостоятельно.\n\n`````ts\n        /**0 */\nlet initialValue = {\n    status: ``,\n    message: ``\n};\nconst Context = createContext(initialValue);\n\n      /**[1]         [2] */\ntype ContextType = typeof initialValue;\n\n/**\n * [0] определение инициализационного значения,\n * на основе которого при помощи запроса типа [2]\n * будет получен его тип [1].\n */\n `````\n\nПолученный тип необходимо будет указать в аннотации единственного параметра `render callback` при его определении.\n\n`````typeScript\nclass ClassComponent extends Component {\n    /**[0]                      [1] */\n    renderCallback = (data: ContextType) => (\n        <span>{data.message}</span>\n    );\n\n\n    render(){\n        return (\n                                    /**[2] */\n            <Context.Consumer >{this.renderCallback}</Context.Consumer>\n        );\n    }\n}\n\n/**\n * При внешнем [2] определении render callback как поля класса [0]\n * в аннотации тип его единственного параметра указан тип данных [1]\n * предоставляемых контекстом. \n * \n */\n`````\n\nЕсли данные предоставляемые контекстом принадлежать к более общему типу, то параметр `render callback` можно конкретизировать.\n\n`````ts\n/**[0] */\ninterface Message {\n    message: string;\n}\n\n/**[0] */\ninterface Status {\n    status: string;\n}\n\n      /**[1]             [2] */\ntype ContextType = Message & Status;\n\n\nlet initialValue = {\n    status: ``,\n    message: ``\n};\nconst Context = createContext(initialValue);\n\n\n\n/**\n * [0] объявление конкретных типов\n * определяющих тип пересечение [2]\n * на который ссылается прежний псевдоним [1].\n * \n * Поскольку инициализационное значение в полной\n * мере соответствует предполагаемому типу, переменную\n * initialValue и универсальную функцию можно избавить от\n * явной и излишней конкретизации.\n */\n\n\n class ClassComponent extends Component {\n                           /**[3] */\n    renderCallback = (data: Message) => (\n        <span>{data.message}</span>\n    );\n\n\n    render(){\n        return (\n            <Context.Consumer >{this.renderCallback}</Context.Consumer>\n        );\n    }\n}\n\n/**\n * [3] параметр render callback теперь ограничен типом\n * Message.\n */\n`````\n\n\nДля получения данных распространяемых контекстом внутри тела функционального компонента, помимо варианта с `Consumer`, который ничем не отличается от рассмотренного в этой теме ранее, предусмотрен более предпочтительный способ предполагающий использование предопределенного хука `useContext<T>(context)`.\n\nУниверсальная функция `useContext` ожидает в качестве своего единственного аргумента объект контекста, конкретизировать который с помощью аргумента типа не имеет никакого смысла.\n\n`````ts\nconst FunctionComponent = () => {\n    let {message, status} = useContext(Context);\n\n\n    return (\n        <span>{message}</span>\n    );\n}\n\nconst App = () => (\n    <Context.Provider value={{status: `init`, message: `React Context!`}}>\n        <FunctionComponent /> \n    </Context.Provider>\n)\n`````\n\nПри попытке с помощью аргумента типа ограничить более общий тип данных возникнет ошибка, поскольку в действие включаются правила контравариантности параметров функции.\n\n`````ts\nconst FunctionComponent = () => {\n                              /**[0]      [1] */\n    let {message} = useContext<Message>(Context); // Error\n\n\n    return (\n        <span>{message}</span>\n    );\n}\n\n/**\n * При попке ограничить тип с помощью аргумента типа [0]\n * из-за контравариантности параметров функции возникнет ошибка [1]. \n */\n`````"}],"githubFileInfo":{"lastUpdate":1633930807000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Типизированные хуки","path":"Tipizirovannye_huki"},"nextPage":{"title":"HOC (Higher-Order Components)","path":"HOC_(Higher-Order_Components)"}},"contentNavData":{"key":"Контекст (Context)","level":0,"index":55,"contentIndex":0,"section":"React","title":"Контекст (Context)","path":"Kontekst_(Context)","elementId":"Kontekst_(Context)","children":[{"key":"Контекст (Context)_0","index":0,"contentIndex":1,"level":1,"section":"React","title":"Определение контекста","path":"Opredelenie_konteksta","elementId":"Opredelenie_konteksta"},{"key":"Контекст (Context)_1","index":1,"contentIndex":2,"level":1,"section":"React","title":"Использование контекста","path":"Ispolzovanie_konteksta","elementId":"Ispolzovanie_konteksta"}]},"pageDescription":"Контекст (Context)"},"__N_SSG":true}