{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/019.(Типы) Object, Array, Tuple/images/"},"sectionInfoAll":[{"key":"Object, Array, Tuple","elementId":"Object,Array,Tuple","markdown":"# Object, Array, Tuple\n\nПришло время рассмотреть такие типы данных как `Object` и `Array`, с которыми разработчики _JavaScript_ уже хорошо знакомы. А также неизвестный им тип данных `Tuple`, который, как мы скоро убедимся, не представляет собой ничего сложного."},{"key":"Object, Array, Tuple_0","elementId":"Object_(object)_—_ssylochnyi_obektnyi_tip","markdown":"## Object (object) — ссылочный объектный тип\n\nСсылочный тип данных `Object` является базовым для всех ссылочных типов в _TypeScript_.\n\nПомимо того, что в _TypeScript_ существует объектный тип `Object`, представляющий одноименный конструктор из _JavaScript_, также существует тип `object`, представляющий любое объектное значение. Поведение типа указанного с помощью ключевого слова `object` и интерфейса `Object` различаются.\n\nПеременные, которым указан тип с помощью ключевого слова `object`, не могут хранить значения примитивных типов, чьи идентификаторы (имена) начинаются со строчной буквы (`number`, `string` и т.д.). В отличие от них тип интерфейс `Object` совместим с любым типом данных.\n\n`````ts\nlet o: object;\nlet O: Object;\n\no = 5; // Error\nO = 5; // Ok\n\no = ''; // Error\nO = ''; // Ok\n\no = true; // Error\nO = true; // Ok\n\no = null; // Error, strictNullChecks = true\nO = null; // Error, strictNullChecks = true\n\no = undefined; // Error, strictNullChecks = true\nO = undefined; // Error, strictNullChecks = true\n`````\n\nПо факту, тип, указанный как `object`, соответствует чистому объекту, то есть не имеющему никаких признаков (даже унаследованных от типа `Object`). В то время как значение, ограниченное типом `Object`, будет включать все его признаки (методы `hasOwnProperty()` и т.п.). При попытке обратиться к членам объекта, не задекларированным в интерфейсе `Object`, возникнет ошибка. Напомним, что в случаях, когда тип нужно сократить до базового, сохранив при этом возможность обращения к специфичным (определенным пользователем) членам объекта, нужно использовать тип `any`.\n\n`````ts\nclass SeaLion {\n    rotate(): void {}\n\n    voice(): void {}\n}\n\nlet seaLionAsObject: object = new SeaLion(); // Ok\nseaLionAsObject.voice(); // Error\n\nlet seaLionAsAny: any = new SeaLion(); // Ok\nseaLionAsAny.voice(); // Ok\n`````\n\nТип интерфейса `Object` идентичен по своей работе одноименному типу из _JavaScript_. Несмотря на то, что тип указанный с помощью ключевого слова `object` имеет схожее название, его поведение отличается от типа интерфейса."},{"key":"Object, Array, Tuple_1","elementId":"Array_(type[])_ssylochnyi_massivopodobnyi_tip","markdown":"## Array (type\\[\\]) ссылочный массивоподобный тип\n\nСсылочный тип данных `Array` является типизированным спископодобным объектом, содержащим логику для работы с элементами.\n\nТип данных `Array` указывается с помощью литерала массива, перед которым указывается тип данных `type[]`.\n\nЕсли при объявлении массива указать тип `string[]`, то он сможет хранить только элементы принадлежащие или совместимые с типом `string` (например `null`, `undefined`, `literal type string`).\n\n`````ts\nvar animalAll: string[] = [\n    'Elephant',\n    'Rhino',\n    'Gorilla'\n];\n\nanimalAll.push(5); // Error\nanimalAll.push(true); // Error\nanimalAll.push(null); // Ok\nanimalAll.push(undefined); // Ok\n`````\n\nВ случае неявного указания типа вывод типов самостоятельно укажет тип как `string[]`.\n\n`````ts\nvar animalAll = [\n    'Elephant',\n    'Rhino',\n    'Gorilla'\n]; // animalAll : string[]\n`````\n\nЕсли требуется, что бы массив хранил смешанные типы данных, то один из способов это сделать — указать тип объединение (`Union`). Нужно обратить внимание на то, как трактуется тип данных `Union` при указании его массиву. Может показаться, что указав в качестве типа тип объединение `Union`, массив `(Elephant | Rhino | Gorilla)[]` может состоять только из какого-то одного перечисленного типа `Elephant`, `Rhino` или `Gorilla`. Но это не совсем так. Правильная трактовка гласит, что каждый элемент массива может принадлежать к типу `Elephant` или `Rhino`, или `Gorilla`. Другими словами, типом, к которому принадлежит массив, ограничивается не весь массив целиком, а каждый отдельно взятый его элемент.\n\n`````ts\nclass Elephant {}\nclass Rhino {}\nclass Gorilla {}\n\nvar animalAll: (Elephant | Rhino | Gorilla)[] = [\n    new Elephant(),\n    new Rhino(),\n    new Gorilla()\n];\n`````\n\nЕсли для смешанного массива не указать тип явно, то вывод типов самостоятельно укажет все типы, которые хранятся в массиве. Более подробно эта тема будет рассмотрена в главе [“Типизация - Вывод типов”](../037.(Типизация)%20Вывод%20типов).\n\nВ случае, если при создании экземпляра массива типы его элементов неизвестны, то следует указать в качестве типа тип `any`.\n\n`````ts\nlet dataAll: any[] = [];\n\ndataAll.push(5); // Ok -> number\ndataAll.push('5'); // Ok -> string\ndataAll.push(true); // Ok -> boolean\n`````\n\nНужно стараться как можно реже использовать массивы со смешанными типами, а к массивам с типом `any` нужно прибегать только в самых крайних случаях. Кроме того, как было рассказано в главе [“Экскурс в типизацию - Совместимость типов на основе вариантности”](../010.(Экскурс%20в%20типизацию)%20Совместимость%20типов%20на%20основе%20вариантности), нужно крайне осторожно относиться к массивам, у которых входные типы являются ковариантными.\n\nВ случаях, требующих создания экземпляра массива с помощью оператора `new`, необходимо прибегать к типу глобального обобщённого интерфейса `Array<T>`. Обобщения будут рассмотрены чуть позднее, а пока нужно запомнить следующее. При попытке создать экземпляр массива путем вызова конструктора, операция завершится успехом в тех случаях, когда создаваемый массив будет инициализирован пустым либо с элементами одного типа данных. В случаях смешанного массива его тип необходимо конкретизировать явно с помощью параметра типа заключенного в угловые скобки. Если сейчас это не понятно, не переживайте, в будущем это будет рассмотрено очень подробно.\n\n`````ts\nlet animalData: string[] = new Array(); //Ok\nlet elephantData: string[] = new Array('Dambo'); // Ok\nlet lionData: (string | number)[];\n\nlionData = new Array('Simba', 1); // Error\nlionData = new Array('Simba'); // Ok\nlionData = new Array(1); // Ok\nlet deerData: (string | number)[] = new Array<string | number>('Bambi', 1); // Ok\n`````\n\nВ _TypeScript_ поведение типа `Array<T>` идентично поведению одноимённого типа из _JavaScript_."},{"key":"Object, Array, Tuple_2","elementId":"Tuple_([T0,T1,…,Tn])_tip_kortej","markdown":"## Tuple (\\[T0, T1, …, Tn\\]) тип кортеж\n\nТип `Tuple` (кортеж) описывает строгую последовательность множества типов, каждый из которых ограничивает элемент массива с аналогичным индексом. Простыми словами кортеж задает уникальный тип для каждого элемента массива. Перечисляемые типы обрамляются в квадратные скобки, а их индексация, так же как у массива начинается с нуля - `[T1, T2, T3]`. Типы элементов массива, выступающего в качестве значения, должны быть совместимы с типами обусловленных кортежем под аналогичными индексами.\n\nДругими словами, если кортеж составляет последовательность типов `string` и `number`, то в качестве значения должен выступать массив, первый элемент которого совместим с типом `string`, а второй с `number`. В иных ситуациях неизбежно возникнет ошибка.\n\n`````ts\nlet v0: [string, number] = ['Dambo', 1]; // Ok\nlet v1: [string, number] = [null, undefined]; // Error -> null не string, а undefined не number\nlet v3: [string, number] = [1, 'Simba']; // Error -> порядок обязателен\nlet v4: [string, number] = [,, ]; // Error -> пустые элементы массива приравниваются к undefined\n`````\n\nДлина массива-значения должна соответствовать количеству типов, указанных в `Tuple`.\n\n`````ts\nlet elephantData: [string, number] = ['Dambo', 1]; // Ok\nlet lionData: [string, number] = ['Simba', 1, 1]; // Error, лишний элемент\nlet fawnData: [string, number] = ['Bambi']; // Error, не достает одного элемента\nlet giraffeData: [string, number] = []; // Error, не достает всех элементов\n`````\n\nНо это правило не мешает добавить новые элементы после того, как массив был присвоен ссылке (ассоциирован со ссылкой). Но элементы, чьи индексы выходят за пределы установленные кортежем, обязаны иметь тип, совместимый с одним из перечисленных в этом кортеже.\n\n`````ts\nlet elephantData: [string, number] = ['Dambo', 1];\nelephantData.push(1941); // Ok\nelephantData.push('Disney'); // Ok\nelephantData.push(true); // Error, тип boolean, в, то время, как допустимы только типы совместимые с типами string и number\n\nelephantData[10] = ''; // Ok\nelephantData[11] = 0; // Ok\n\nelephantData[0] = ''; // Ok, значение совместимо с типом заданном в кортеже\nelephantData[0] = 0; // Error, значение не совместимо с типом заданном в кортеже\n`````\n\nМассив, который связан с типом кортежем, ничем не отличается от обычного, за исключением способа определения типа его элементов. При попытке присвоить элемент под индексом 0 переменной с типом `string`, а элемент под индексом `1` переменной с типом `number`, операции присваивания завершатся успехом. Но, несмотря на то, что элемент под индексом `2` хранит значение, принадлежащее к типу `string`, оно не будет совместимо со `string`. Дело в том, что элементы, чьи индексы выходят за пределы установленные кортежем, принадлежат к типу объединению (`Union`). Это означает, что элемент под индексом `2` принадлежит к типу `string | number`, а это не, то же самое, что тип `string`.\n\n`````ts\nlet elephantData: [string, number] = ['Dambo', 1]; // Ok\n\nelephantData[2] = 'nuts';\n\nlet elephantName: string = elephantData[0]; // Ok, тип string\nlet elephantAge: number = elephantData[1]; // Ok, тип number\nlet elephantDiet: string = elephantData[2]; // Error, тип string | number\n`````\n\nЕсть два варианта решения этой проблемы. Первый вариант, изменить тип переменной со `string` на тип объединение `string | number`, что ненадолго избавит от проблемы совместимости типов. Второй, более подходящий вариант, прибегнуть к приведению типов, который детально будет рассмотрен позднее.\n\nВ случае, если описание кортежа может навредить семантике кода, его можно поместить в описание псевдонима типа (`type`).\n\n`````ts\ntype Tuple = [number, string, boolean, number, string];\n\nlet v1: [number, string, boolean, number, string]; // плохо\nlet v2: Tuple; // хорошо\n`````\n\nКроме того, тип кортеж можно указывать в аннотации остаточных параметров (`...rest`).\n\n`````ts\nfunction f(...rest: [number, string, boolean]): void {}\n\nlet tuple: [number, string, boolean] = [5, '', true];\nlet array = [5, '', true];\n\nf(5); // Error\nf(5, ''); // Error\nf(5, '', true); // Ok\nf(...tuple); // Ok\nf(tuple[0], tuple[1], tuple[2]); // Ok\nf(...array); // Error\nf(array[0], array[1], array[2]); // Error, все элементы массива принадлежат к типу string | number | boolean, в, то время как первый элемент кортежа принадлежит к типу number\n`````\n\nПомимо этого, типы, указанные в кортеже, могут быть помечены как необязательные с помощью необязательного модификатора `?`.\n\n`````ts\nfunction f(...rest: [number, string?, boolean?]): void {}\n\nf(); // Error\nf(5); // Ok\nf(5, ''); // Ok\nf(5, '', true); // Ok\n`````\n\nУ кортежа, который включает типы помеченные как не обязательные, свойство длины принадлежит к типу объединения (`Union`), состоящего из литеральных числовых типов.\n\n`````ts\nfunction f(...rest: [number, string?, boolean?]): [number, string?, boolean?] {\n    return rest;\n}\n\nlet l = f(5).length; // let l: 1 | 2 | 3\n`````\n\nКроме того, для кортежа применим механизм распространения (`spread`), который может быть указан в любой части определения типа. Но существуют два исключения. Во-первых, определение типа кортежа может включать только одно распространение.\n\n`````ts\n/**\n * [0] A rest element cannot follow another rest element.ts(1265)\n *\n */\nlet v0: [...boolean[], ...string[]]; // Error [0]\nlet v1: [...boolean[], boolean, ...string[]]; // Error [0]\n\nlet v2: [...boolean[], number]; // Ok\nlet v3: [number, ...boolean[]]; // Ok\nlet v4: [number, ...boolean[], number]; // Ok\n`````\n\nИ во вторых, распространение не может быть указанно перед необязательными типами.\n\n`````ts\n/**\n * [0] An optional element cannot follow a rest element.ts(1266)\n *\n */\nlet v5: [...boolean[], boolean?]; // Error [1]\n\nlet v6: [boolean?, ...boolean[]]; // Ok\n`````\n\nВ результате распространения, получается тип с логически предсказуемой последовательностью типов, определяющих кортеж.\n\n`````ts\ntype Strings = [string, string];\ntype BooleanArray = boolean[];\n\n// type Unbounded0 = [string, string, ...boolean[], symbol]\ntype Unbounded0 = [...Strings, ...BooleanArray, symbol];\n\n// type Unbounded1 = [string, string, ...boolean[], symbol, string, string]\ntype Unbounded1 = [ ...Strings, ...BooleanArray, symbol, ...Strings]\n`````\n\nСтоит заметить, что поскольку механизм распространения участвует в рекурсивном процессе формирования типа, способного значительно замедлять компилятор, установленно ограничение в размере 10000 итераций.\n\n\nМеханизм объявления множественного распространения (`spread`) значительно упрощает аннотирование сигнатуры функции при реализации непростых сценариев, один из которых будет рассмотрен далее в главе (Массивоподобные readonly типы)[].\n\n\nЕще несколько неочевидных моментов в логике кортежа связанны с выводом типов и будут рассмотрены в главе [“Типизация - Вывод типов”](../037.(Типизация)%20Вывод%20типов) (_см реализацию функции concat_).\n\nПомимо этого семантику типов кортежей можно повышать за счет добавления им меток.\n\n`````ts\n// пример безликого кортежа\n\nconst f = (p: [string, number]) => {}\n\n/**\n * автодополнение -> f(p: [string, number]): void\n * \n * Совершенно не понятно чем конкретно являются\n * элементы представляемые типами string и number\n */\nf0()\n`````\n\n`````ts\n// пример кортежа с помеченными элементами\n\nconst f = (p: [a: string, b: number]) => {};\n\n/**\n * автодополнение -> f(p: [a: string, b: number]): void\n * \n * Теперь мы знаем, что функция ожидает не просто \n * строку и число, а аргумент \"a\" и аргумент \"b\",\n * которые в реальном проекте будут иметь более\n * осмысленное смысловое значение, например \"name\" и \"age\".\n */\nf1()\n`````\n\nПоскольку метки являются исключительной частью синтаксиса _TypeScript_ они не имеют никакой силы в коде при деструктуризации массива, представленного типом кортежа.\n\n`````ts\nconst f = (p: [a: string, b: number]) => {\n    let [c, d] = p;\n};\n`````\n\nЕдинственное правило, касающееся данного механизма, заключается в том, что кортеж, содержащий метки, не может содержать элементы описанные только типами.\n\n`````ts\ntype T = [a: number, b: string, boolean]; // Error -> Tuple members must all have names or all not have names.ts(5084)\n`````\n\nНапоследок стоит обратить внимание на тот факт, что тип переменной при присвоении ей инициализированного массива без явного указания типа, будет выведен как массив. Другими словами, вывод типа неспособен вывести тип кортеж.\n\n`````ts\nlet elephantData = ['Dambo', 1]; // type Array (string | number)[]\n`````\n\n\nТип `Tuple` является уникальным для _TypeScript_, в _JavaScript_ подобного типа не существует."}],"githubFileInfo":{"lastUpdate":1643269367000,"contributorAll":[{"name":"Romanov Yuri","avatar":"https://avatars.githubusercontent.com/u/31193144?v=4","bio":"","githubUrl":"https://github.com/darteil"},{"name":"Bohdan Petrov","avatar":"https://avatars.githubusercontent.com/u/35348648?v=4","bio":"Front-end developer","githubUrl":"https://github.com/mindyourlifeguide"},{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"},{"name":"Kartashov Alexey","avatar":"https://avatars.githubusercontent.com/u/2387592?v=4","bio":"","githubUrl":"https://github.com/antixrist"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum"},"nextPage":{"title":"Function, Functional Types","path":"Function,Functional_Types"}},"contentNavData":{"key":"Object, Array, Tuple","level":0,"index":19,"contentIndex":0,"section":"Типы","title":"Object, Array, Tuple","path":"Object,Array,Tuple","elementId":"Object,Array,Tuple","children":[{"key":"Object, Array, Tuple_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Object (object) — ссылочный объектный тип","path":"Object_(object)_—_ssylochnyi_obektnyi_tip","elementId":"Object_(object)_—_ssylochnyi_obektnyi_tip"},{"key":"Object, Array, Tuple_1","index":1,"contentIndex":2,"level":1,"section":"Типы","title":"Array (type[]) ссылочный массивоподобный тип","path":"Array_(type[])_ssylochnyi_massivopodobnyi_tip","elementId":"Array_(type[])_ssylochnyi_massivopodobnyi_tip"},{"key":"Object, Array, Tuple_2","index":2,"contentIndex":3,"level":1,"section":"Типы","title":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"Tuple_([T0,T1,…,Tn])_tip_kortej","elementId":"Tuple_([T0,T1,…,Tn])_tip_kortej"}]},"pageDescription":"Object, Array, Tuple"},"__N_SSG":true}