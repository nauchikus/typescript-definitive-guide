{"pageProps":{"innovationPage":{"key":"4.1@beta_12","title":"4.1@beta","path":"4.1@beta","coverUrl":"https://github.com/nauchikus/typescript-definitive-guide/raw/master/what-is-new/4.1@beta/metadata/cover.png","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"},"sections":[{"key":"4.1@beta_11","title":"Изменение механизма проверки индексной сигнатуры","tags":["Нововведение"],"markdown":"## Изменение механизма проверки индексной сигнатуры\n\nПоскольку механизм позволяющий определение _индексной сигнатуры_ не способен отслеживать идентификаторы (имена) полей определенных динамически, такой подход не считается типобезопасным.\n\n`````ts\ntype T = {\n    [key: string]: number | string;\n}\n\nfunction f(p: T) {\n    /**\n     * Обращение к несуществующим полям\n     */\n    p.bad.toString(); // Ok -> Ошибка времени исполнения\n    p[Math.random()].toString(); // Ok -> Ошибка времени исполнения\n}\n`````\n\nДля решения данной проблемы был создан механизм активируемый с помощью нового флага `--noUncheckedIndexedAccess` ожидающий в качестве значения `true` либо `false`. Активация механизма позволяет обращаться к динамическим полям только после подтверждения их наличия в объекте, а также совместно при совместном использовании с такими операторами, как оператор опциональной последовательности `?.` и опциональный оператор `!.`.\n\n`````json\n// @filename: tsconfig.json\n\n{\n    \"compilerOptions\": {\n        \"noUncheckedIndexedAccess\": true\n    }\n}\n`````\n\n`````ts\ntype T = {\n  [key: string]: number | string;\n}\n\n\nfunction f(p: T) {\n  /**\n   * Обращение к несуществующим полям\n   */\n  p.bad.toString(); // Error -> Object is possibly 'undefined'.ts(2532)\n  p[Math.random()].toString(); // Error -> Object is possibly 'undefined'.ts(2532)\n\n\n  // Проверка наличия поля bad\n  if(\"bad\" in p){\n      p.bad?.toString(); // Ok\n  }\n\n  // Использование опционального оператора\n  p[Math.random()]!.toString(); // Ok -> ошибка во время выполнения\n\n  p[Math.random()]?.toString();  // Ok -> Ошибка не возникнет\n}\n`````\n\nКроме этого, влияние данного механизма распространяется также и на массивы. В случае с массивом не получится избежать аналогичной ошибки при попытке обращения к его элементам при помощи индексной сигнатуры.\n\n`````ts\nfunction f(array: string[]) {\n    for(let i = 0; i < array.length; i++){\n        array[i].toString(); // Error -> Object is possibly 'undefined'.\n    }\n}\n`````\n\nПоскольку данный флаг может потребовать внесения значительных изменений в существующих проектах, он не был включён в группировку `--strict` и активируется индивидуально.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Izmenenie_mehanizma_proverki_indeksnoi_signatury","elementId":"Izmenenie_mehanizma_proverki_indeksnoi_signatury","version":{"version":"4.1@beta_1","dateRelease":"September 18, 2020","datePublication":"October 08, 2020"}},{"key":"4.1@beta_7","title":"Шаблонный литеральный строковый тип","tags":["Нововведение"],"markdown":"## Шаблонный литеральный строковый тип\n\nДумаю, что каждый знакомый с _TypeScript_ не понаслышке, не в состоянии забыть пользу от _строковых литеральных типов_ которые эффективно помогают выявлять орфографические ошибки строковых значений на этапе компиляции...\n\n`````ts\nfunction setAnimation(animationType: \"ease\" | \"ease-in\" | \"ease-out\"){\n    // ... какая-то логика\n}\nsetAnimation(\"ease\"); // Error -> Argument of type '\"ease\"' is not assignable to parameter of type '\"ease\" | \"ease-in\" | \"ease-out\"'.\n`````\n\n...а также используются при определении новых типов выступают в качестве ключей сопоставленных типов.\n\n`````ts\ntype Animation = {\n    [K in \"ease\" | \"ease-in\" | \"ease-out\"]?: boolean;\n}\n`````\n\nИ вот, начиная с версии `v4.1` они нашли новое применение в удивительном механизме получившем название _Шаблонный литеральный строковый тип_.\n\n_Шаблонный литеральный строковый тип_ — это тип, позволяющий на основе литеральных строковых типах динамически определять новый литеральный строковый тип. Простыми словами, это известный по _JavaScript_ механизм создания шаблонных строк только для типов.\n\n`````ts\ntype Type = \"Type\";\ntype Script = \"Script\";\n\n/**\n * type Message = \"I ❤️ TypeScript\"\n */\ntype Message = `I ❤️ ${Type}${Script}`;\n`````\n\nНо вся мощь данного типа раскрывается в момент определение нового типа на основе объединения (`union`). В подобных случаях новый тип будет также представлять объединение элементы которого представляют все возможные варианты полученные на основе исходного объединения. \n\n`````ts\ntype Sides = \"top\" | \"right\" | \"bottom\" | \"left\";\n\n/**\n * type PaddingSides = \"padding-top\" | \"padding-right\" | \"padding-bottom\" | \"padding-left\"\n */\ntype PaddingSides = `padding-${Sides}`;\n`````\n\nАналогичное поведение будет справедливо и для нескольких типов объединения.\n\n`````ts\ntype AxisX = \"top\" | \"bottom\";\ntype AxisY = \"left\" | \"right\";\n\n\n/**\n * type Sides = \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\n */\ntype Sides = `${AxisX}-${AxisY}`;\n\n/**\n * type BorderRadius = \"border-top-left-radius\" | \"border-top-right-radius\" | \"border-bottom-left-radius\" | \"border-bottom-right-radius\"\n */\ntype BorderRadius = `border-${Sides}-radius`;\n`````\n\nПоскольку с высокой долей вероятности в подобных операциях потребуется трансформация регистра строк, создателями данного механизма так же были добавлены новые операторы преобразования `uppercase`, `lowercase`, `capitalize` и `uncapitalize`. Данные операторы применяются непосредственно к литеральному строковому типу который указывается справа от него.\n\n`````ts\ntype A = `${uppercase \"AbCd\"}`; // type A = \"ABCD\"\ntype B = `${lowercase \"AbCd\"}`; // type B = \"abcd\"\ntype C = `${capitalize \"abcd\"}`; // type C = \"Abcd\"\ntype D = `${uncapitalize \"Abcd\"}`; // type D = \"abcd\"\n`````\n\nНужно обратить внимание, что в конечном релизе данные операторы могут быть определены в виде типов, о чем непременно будет упомянуто.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Shablonnyi_literalnyi_strokovyi_tip","elementId":"Shablonnyi_literalnyi_strokovyi_tip","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_1","title":"Переопределение ключей в сопоставленных типах","tags":["Нововведение"],"markdown":"## Переопределение ключей в сопоставленных типах\n\nДо сих пор сопоставленные типы позволяли работать с ключами только в том виде в котором они были определены в исходном типе. Начиная с текущей версии стало возможно переопределять ключи непосредственно в сопоставленных типах при помощи ключевого слова `as` указываемого после строкового перечисления.\n\n`````ts\ntype T = {\n    [K in STRING_VALUES as NEW_KEY]: K // K преобразованный\n}\n`````\n\nТаким образом совмещая данный механизм с _шаблонными литеральными строковыми типами_ можно добиться переопределения исходных ключей.\n\n`````ts\ntype ToGetter<T> = `get${capitalize T}`;\ntype Getters<T> = {\n    [K in keyof T as ToGetter<K>]: () => T[K];\n}\n\ntype Person = {\n    name: string;\n    age: number;\n}\n\n/**\n * type T = {\n *  getName: () => string;\n *  getAge: () => number;\n * }\n */\ntype T = Getters<Person>\n````` \n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Pereopredelenie_kluchei_v_sopostavlennyh_tipah","elementId":"Pereopredelenie_kluchei_v_sopostavlennyh_tipah","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_0","title":"Рекурсивные условные типы","tags":["Изменение"],"markdown":"## Рекурсивные условные типы\n\nПри разработке программ часто возникают потребности в создании значений при помощи рекурсии в основе которой лежит логическое условие. \n\n`````ts \nfunction flat(value){\n    if(Array.isArray(value)){ // логическое условие\n        return value.reduce((result, current) => [\n            ...result, \n            ...flat(current)\n        ], []);\n    }\n\n    return [value];\n}\n\nflat([0, [1, [2]], 3]); // [0, 1, 2, 3]\n````` \n\nНо до текущего момента описать подобную логику с помощью типов было практически невозможно. Поэтому начиная с текущей версии _TypeScript_ делает послабления на установленные правила относительно рекурсивных типов. \n\n`````ts\ntype GetItemType<T> = T extends ReadonlyArray<infer U> ? GetItemType<U> : T;\n\ndeclare function flat<T extends readonly unknown[]>(value: T): GetItemType<T>[];\n\n\nlet result = flat([0, [1, [2]], 3]); // let result: number[] = [0, 1, 2, 3]\n`````\n\nНо рекурсивные типы необходимо использовать крайне осторожно, поскольку помимо нагрузки на процессор, при больших объемах данных, данный механизм может из-за превышения максимальной вложенности объектов, привести к исключению во время компиляции. В общем лучше вообще не использовать этот механизм, чем создавать с его помощью универсальные типы способные покрыть все возможные случаи. Снимайте нагрузку зха счет определения типов максимально соответствующих каждому конкретному случаю.\n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Rekursivnye_uslovnye_tipy","elementId":"Rekursivnye_uslovnye_tipy","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_10","title":"paths без baseUrl","tags":["Изменение"],"markdown":"## paths без baseUrl\n\nРанее указание псевдонима для пути с помощью `paths` требовало также установление значения параметру `baseUrl`. Это не позволяло автоимпорту указывать правильные пути. Поэтому начиная с текущей версии `paths` больше не зависит от параметра `baseUrl`. \n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"paths_bez_baseUrl","elementId":"paths_bez_baseUrl","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_5","title":"checkJs не требует активации allowJs","tags":["Изменение"],"markdown":"## checkJs не требует активации allowJs\n\nРаньше, что бы активировать проверку _JavaScript_ кода с помощью параметра `checkJs` было необходимо также активировать флаг `allowJs`. Поскольку указание выполнять проверку _JavaScript_ кода де-факто подразумевает его наличие на конвейере _TypeScript_, данный факт раздражал многих разработчиков. Поэтому начиная с текущей версии активация параметра `checkJs` больше не требует активации `allowJs`.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"checkJs_ne_trebuet_aktivacii_allowJs","elementId":"checkJs_ne_trebuet_aktivacii_allowJs","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_9","title":"jsx фабрики для React 17","tags":["Изменение"],"markdown":"## jsx фабрики для React 17\n\nТекущая версия _TypeScript_ получила поддержку будущих `jsx` и `jsxs` фабрик предполагаемых _React 17_. Для этого были реализованны две новые опции `react-jsx` и `react-jsxdev`.\n\nПри разделении конфигурации на _production_ и _development_ конфигурация проекта могла бы выглядеть следующим образом.\n\n`````json\n// tsconfig.json\n{\n    \"compilerOptions\": {\n        \"module\": \"esnext\",\n        \"target\": \"es2015\",\n        \"jsx\": \"react-jsx\",\n        \"strict\": true\n    },\n    \"include\": [\n        \"./**/*\"\n    ]\n}\n`````\n`````json\n// tsconfig.dev.json\n{\n    \"extends\": \"./tsconfig.json\",\n    \"compilerOptions\": {\n        \"jsx\": \"react-jsxdev\"\n    }\n}\n`````\n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"jsx_fabriki_dlya_React_17","elementId":"jsx_fabriki_dlya_React_17","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_3","title":"Поддержка тега @see для JSDoc","tags":["Изменение"],"markdown":"## Поддержка тега @see для JSDoc\n\nТеперь _JSDoc_ поддерживает тег `@see` упрощающий работу с кодом за счет возможности перехода к определению (_go-to-definition_).\n\n`````ts\n// @filename: animals.ts\nexport class Animal { }\nexport class Fish { }\nexport class Bird { }\n\n// @filename: index.js\nimport * as animals from './animals';\n\n/**\n * @see animals.Bird\n */\nfunction related() { }\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"Podderjka_tega_@see_dlya_JSDoc","elementId":"Podderjka_tega_@see_dlya_JSDoc","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_8","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] abstract больше не совместим с async","tags":["Критическое изменение"],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] abstract больше не совместим с async\n\nНачиная с текущей версии абстрактные методы не могут помечаться ключевым словом `async`.\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_abstract_bolshe_ne_sovmestim_s_async","elementId":"[KRITIChESKOE_IZMENENIE]_abstract_bolshe_ne_sovmestim_s_async","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_2","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] any и unknown доминируют в ложных позициях","tags":["Критическое изменение"],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] any и unknown доминируют в ложных позициях\n\nЕсли в условии с логическим _И_ (`&&`) значение левого операнда принадлежало к типу `any` или `unknown`, то вывод типа выводил тип правого операнда. Начиная с текущей версии в подобных условиях всегда будут выводиться `any` или `unknown`.\n\n`````ts \ndeclare let a: any;\ndeclare let n: number;\ndeclare let u: unknown;\n\n/**\n * Вывод типов видит так ->\n *         <v4.1  |  >=v4.1\n * let v0: number    any\n * let v1: number    unknown\n * let v2: any       any\n * let v3: unknown   unknown\n */\nlet v0 = a && n;\nlet v1 = u && n;\nlet v2 = n && a;\nlet v3 = n && u;\n````` \n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_any_i_unknown_dominiruut_v_lojnyh_poziciyah","elementId":"[KRITIChESKOE_IZMENENIE]_any_i_unknown_dominiruut_v_lojnyh_poziciyah","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_4","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] --declaration и --outFile требуют имя корневого пакета","tags":["Критическое изменение"],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] --declaration и --outFile требуют имя корневого пакета\n\nДо текущего момента при совместном использовании `--declaration` и `--outFile` пути в `.d.ts` файлах выглядели привычным образом.\n\n`````ts\n/**\n * До компиляции\n */\n\n// @filename: ./utils.ts\nexport const toLowerCase = (text: string) => text.toLowerCase();\n\n// @filename: ./index.js\nexport * from \"./utils\";\n`````\n\n`````ts\n/**\n * После компиляции .d.ts\n */\n\ndeclare module \"utils\" {\n    export const toLowerCase: (text: string) => string;\n}\ndeclare module \"index\" {\n    export * from \"utils\";\n}\n`````\n\nНачиная с текущей версии при совместном использовании параметров `--declaration` и `--outFile` необходимо задавать значение (имя пакета) параметру `bundledPackageName`. В противном случае возникнет ошибка - `The `bundledPackageName` option must be provided when using outFile and node module resolution with declaration emit.`.\n\n\n`````json\n{\n    \"compilerOptions\": {\n        \"module\": \"amd\",\n        \"target\": \"esnext\",\n        \"jsx\": \"preserve\",\n        \"sourceMap\": true,\n\n        \"declaration\": true,\n        \"outFile\": \"./dest/my-lib.js\",\n        \"bundledPackageName\": \"my-lib\"\n    },\n    \"include\": [\"./src/\"],\n    \"exclude\": [\n        \"node_modules\",\n        \"**/node_modules/*\"\n    ]\n}\n`````\n\n`````ts\n/**\n * После компиляции .d.ts\n */\n\ndeclare module \"my-lib/utils\" {\n    export const toLowerCase: (text: string) => string;\n}\ndeclare module \"my-lib/index\" {\n    export * from \"utils\";\n}\n`````\n\n\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_--declaration_i_--outFile_trebuut_imya_kornevogo_paketa","elementId":"[KRITIChESKOE_IZMENENIE]_--declaration_i_--outFile_trebuut_imya_kornevogo_paketa","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}},{"key":"4.1@beta_6","title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] параметры resolve теперь обязательные","tags":["Критическое изменение"],"markdown":"## \\[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ\\] параметры resolve теперь обязательные\n\nДо текущей версии функцию `resolve`, участвующей в работе логики `Promise`, можно было вызывать без аргументов, поскольку её параметры описаны, как необязательные.\n\n`````ts\nnew Promise(resolve => {\n    resolve(); // Ok\n});\n`````\n\nНачиная с текущей версии описание функции `resolve` изменило поведение для её параметров сделав их обязательными. Теперь при отсутствии параметров будет возникать ошибка.\n\n`````ts\nnew Promise(resolve => {\n    resolve(); // Error -> Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'?\n});\n`````\n\nКак следует из ошибки, при сценариях подразумевающих вызов функции `resolve` без аргументов, `Promise` в качестве аргумента типа необходимо установить тип `void`.\n\n`````ts\nnew Promise<void>(resolve => {\n    resolve(); // Ok \n});\n`````\n","githubFileInfo":{"lastUpdate":null,"contributorAll":[]},"path":"[KRITIChESKOE_IZMENENIE]_parametry_resolve_teper_obyazatelnye","elementId":"[KRITIChESKOE_IZMENENIE]_parametry_resolve_teper_obyazatelnye","version":{"version":"4.1@beta","dateRelease":"September 18, 2020","datePublication":"September 18, 2020"}}]},"contentNavData":{"key":"4.1@beta","level":0,"index":0,"contentIndex":0,"title":"4.1@beta","path":"4.1@beta","elementId":"4.1@beta","children":[{"key":"Изменение механизма проверки индексной сигнатуры_0","level":1,"index":1,"contentIndex":1,"title":"Изменение механизма проверки индексной сигнатуры","path":"Izmenenie_mehanizma_proverki_indeksnoi_signatury","elementId":"Izmenenie_mehanizma_proverki_indeksnoi_signatury"},{"key":"Шаблонный литеральный строковый тип_1","level":1,"index":2,"contentIndex":2,"title":"Шаблонный литеральный строковый тип","path":"Shablonnyi_literalnyi_strokovyi_tip","elementId":"Shablonnyi_literalnyi_strokovyi_tip"},{"key":"Переопределение ключей в сопоставленных типах_2","level":1,"index":3,"contentIndex":3,"title":"Переопределение ключей в сопоставленных типах","path":"Pereopredelenie_kluchei_v_sopostavlennyh_tipah","elementId":"Pereopredelenie_kluchei_v_sopostavlennyh_tipah"},{"key":"Рекурсивные условные типы_3","level":1,"index":4,"contentIndex":4,"title":"Рекурсивные условные типы","path":"Rekursivnye_uslovnye_tipy","elementId":"Rekursivnye_uslovnye_tipy"},{"key":"paths без baseUrl_4","level":1,"index":5,"contentIndex":5,"title":"paths без baseUrl","path":"paths_bez_baseUrl","elementId":"paths_bez_baseUrl"},{"key":"checkJs не требует активации allowJs_5","level":1,"index":6,"contentIndex":6,"title":"checkJs не требует активации allowJs","path":"checkJs_ne_trebuet_aktivacii_allowJs","elementId":"checkJs_ne_trebuet_aktivacii_allowJs"},{"key":"jsx фабрики для React 17_6","level":1,"index":7,"contentIndex":7,"title":"jsx фабрики для React 17","path":"jsx_fabriki_dlya_React_17","elementId":"jsx_fabriki_dlya_React_17"},{"key":"Поддержка тега @see для JSDoc_7","level":1,"index":8,"contentIndex":8,"title":"Поддержка тега @see для JSDoc","path":"Podderjka_tega_@see_dlya_JSDoc","elementId":"Podderjka_tega_@see_dlya_JSDoc"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] abstract больше не совместим с async_8","level":1,"index":9,"contentIndex":9,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] abstract больше не совместим с async","path":"[KRITIChESKOE_IZMENENIE]_abstract_bolshe_ne_sovmestim_s_async","elementId":"[KRITIChESKOE_IZMENENIE]_abstract_bolshe_ne_sovmestim_s_async"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] any и unknown доминируют в ложных позициях_9","level":1,"index":10,"contentIndex":10,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] any и unknown доминируют в ложных позициях","path":"[KRITIChESKOE_IZMENENIE]_any_i_unknown_dominiruut_v_lojnyh_poziciyah","elementId":"[KRITIChESKOE_IZMENENIE]_any_i_unknown_dominiruut_v_lojnyh_poziciyah"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] --declaration и --outFile требуют имя корневого пакета_10","level":1,"index":11,"contentIndex":11,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] --declaration и --outFile требуют имя корневого пакета","path":"[KRITIChESKOE_IZMENENIE]_--declaration_i_--outFile_trebuut_imya_kornevogo_paketa","elementId":"[KRITIChESKOE_IZMENENIE]_--declaration_i_--outFile_trebuut_imya_kornevogo_paketa"},{"key":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] параметры resolve теперь обязательные_11","level":1,"index":12,"contentIndex":12,"title":"[КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ] параметры resolve теперь обязательные","path":"[KRITIChESKOE_IZMENENIE]_parametry_resolve_teper_obyazatelnye","elementId":"[KRITIChESKOE_IZMENENIE]_parametry_resolve_teper_obyazatelnye"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"4.0","path":"4.0"},"nextPage":{"title":"4.2","path":"4.2"}}},"__N_SSG":true}