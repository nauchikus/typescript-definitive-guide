{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/049.(Синтаксические конструкции) Синтаксические конструкции и операторы/images/"},"sectionInfoAll":[{"key":"Синтаксические конструкции и операторы","elementId":"Sintaksicheskie_konstrukcii_i_operatory","markdown":"# Синтаксические конструкции и операторы\n\nКроме типизации, _TypeScript_ пытается сделать жизнь разработчиков более комфортной за счет добавления синтаксического сахара в виде операторов не существующих в _JavaScript_ мире. Помимо этого, текущая глава поведает о неоднозначных моментах связанных с уже хорошо известными, по _JavaScript_, операторами."},{"key":"Синтаксические конструкции и операторы_0","elementId":"Operatory_prisvaivaniya_korotkogo_zamykaniya_(&&=,||=,&&=)","markdown":"## Операторы присваивания короткого замыкания (&&=, ||=, &&=)\n\nВ большинстве языков, в том числе и _JavaScript_, существует такое понятие как составные операторы присваивания (_compound assignment operators_) позволяющие совмещать операцию присваивания при помощи оператора `=`, с какой-либо другой допустимой операции (`+-*/!` и т.д.) и тем самым значительно сокращать выражения.\n\n`````ts\nlet a = 1;\nlet b = 2;\n\na += b; // тоже самое, что a = a + b\na *= b; // тоже самое, что a = a * b\n// и т.д.\n`````\n\nМножество существующих операторов совместимы с оператором `=` за исключением трех, таких часто применяемых операторов, как _логическое И_ (`&&`), _логическое ИЛИ_ (`||`) и оператор _нулевого слияния_ (`??`).\n\n`````ts\na = a && b;\na = a || b;\na = a ?? b;\n`````\n\nПоскольку дополнительные синтаксические возможности лишь упрощают процесс разработки программ, благодаря комьюнити, в _TypeScript_ появился механизм обозначаемый как _операторы присваивания короткого замыкания_. Данный механизм позволяет совмещать упомянутые ранее операторы `&&`, `||` и `??` непосредственно с оператором присваивания.\n\n\n`````ts\nlet a = {};\nlet b = {};\n\na &&= b; // a && (a = b)\na ||= b; // a || (a = b);\na ??= b; // a !== null && a !== void 0 ? a : (a = b);\n`````"},{"key":"Синтаксические конструкции и операторы_1","elementId":"Operandy_dlya_delete_doljny_byt_neobyazatelnymi","markdown":"## Операнды для delete должны быть необязательными\n\nПредставьте случай при котором в _JavaScript_ коде вам необходимо удалить у объекта одно из трех определенных в нем полей.\n\n`````js\nlet o = {\n    a: 0,\n    b: '',\n    c: true\n};\n\nconst f = o => delete o.b;\n\nf(0); // удаляем поле b\n\nObject\n    .entries(o)\n    .forEach( ([key, value]) => console.log(key, value) );\n/**\n * log -\n * -> a, 0\n * -> b, true\n */\n`````\n\nЗадача предельно простая только с точки зрения динамической типизации _JavaScript_. С точки зрения статической типизации _TypeScript_, удаление члена объекта нарушает контракт представляемый декларацией типа. Простыми словами, _TypeScript_ не может гарантировать типобезопасность, пока не может гарантировать существование членов объекта описанных в его типе.\n\n\n`````ts\ntype O = {\n    a: number;\n    b: string;\n    c: boolean;\n}\n\nlet o: O = {\n    a: 0,\n    b: '',\n    c: true\n};\n\nconst f = (o: O) => delete o.b; // [*]\n\nf(o); // удаляем поле b\n\n/**\n * [*] Error ->\n * Объект o больше не отвечает\n * типу O поскольку в нем нет\n * обязательного поля b. Поэтому\n * если дальше по ходу выполнения\n * программы будут производится\n * операции над удаленным полем,\n *, то возникнет ошибка времени выполнения.\n */\n\n`````\n\nПоэтому _TypeScript_ позволяет удалять члены объекта при помощи оператора `delete` только в том случае, если они имеют тип `any`, `unknown`, `never` или объявлены как необязательные.\n\n`````ts\ntype T0 = {\n    field: any;\n}\n\nconst f0 = (o: T0) => delete o.field; // Ok\n\n\ntype T1 = {\n    field: unknown;\n}\n\nconst f1 = (o: T1) => delete o.field; // Ok\n\n\ntype T2 = {\n    field: never;\n}\n\nconst f2 = (o: T2) => delete o.field; // Ok\n\n\ntype T3 = {\n    field?: number;\n}\n\nconst f3 = (o: T3) => delete o.field; // Ok\n\n\ntype T4 = {\n    field: number;\n}\n\nconst f4 = (o: T4) => delete o.field; // Error -> The operand of a 'delete' operator must be optional.\n\n`````"},{"key":"Синтаксические конструкции и операторы_2","elementId":"Obyavlenie_peremennyh_'neobyazatelnymi'_pri_destrukturizacii_massivopodobnyh_obektov","markdown":"## Объявление переменных 'необязательными' при деструктуризации массивоподобных объектов\n\nПри активном рекомендуемым флаге `--noUnusedLocals`, компилятор выбрасывает ошибки, если переменные, объявленные при деструктуризации массивоподобных объектов, не задействованы в коде.\n\n`````ts\nfunction getPlayerControlAll(){\n    return [()=>{}, ()=>{}];\n}\n\n/**\n * Где-то в другом файле\n */\nfunction f(){\n    /**\n     * [*] Error -> 'stop' is declared but its value is never read.\n     */\n    let [stop /** [*] */, play] = getPlayerControlAll();\n\n    return play;\n}\n`````\n\nНесмотря на то, что существует способ получать только необходимые значения, это не решит проблему семантики кода, поскольку идентификатор переменной является частью мозаики иллюстрирующей работу логики. И хотя в _TypeScript_, эту проблему можно решить и другими способами, они ни чем не смогут помочь скомпилированному в _JavaScript_ коду.\n\n`````ts\nfunction getPlayerControlAll(){\n    return [()=>{}, ()=>{}];\n}\n\n/**\n * Где-то в другом файле\n */\nfunction f(){\n    /**\n     * Ошибки больше нет, поскольку первый, неиспользуемый\n     * элемент пропущен. Но не смотря на это, семантически становится\n     * не понятно, что же возражает функция getPlayerControlAll().\n     *\n     * И несмотря на способы способные решить проблему в TypeScript,\n     * в скомпилированном виде, от них не останется и следа.\n     */\n    let [, play] = getPlayerControlAll();\n\n    return play;\n}\n\n`````\n\nДля таких случаев, в _TypeScript_ существует возможность, при деструктуризации массивоподобных объектов, объявлять переменные, как _необязательные_. Что бы переменная расценивалась компилятором, как _необязательная_, её идентификатор должен начинаться с нижнего подчёркивания `_identifier`.\n\n`````ts\nfunction getPlayerControlAll(){\n    return [()=>{}, ()=>{}];\n}\n\n/**\n * Где-то в другом файле\n */\nfunction f(){\n    /**\n     * [*] Ok -> несмотря на то, что переменная stop не\n     * задействована в коде, ошибки не возникает, что позволяет\n     * более глубоко понять логику кода. \n     */\n    let [_stop /** [*] */, play] = getPlayerControlAll();\n\n    return play;\n}\n`````"},{"key":"Синтаксические конструкции и операторы_3","elementId":"Modifikator_abstract_dlya_opisaniya_tipa_konstruktora","markdown":"## Модификатор abstract для описания типа конструктора\n\nАбстрактные классы предназначены исключительно для расширения (невозможно создать его экземпляр с помощью оператора `new`), а его абстрактные члены должны обязательно должны быть переопределены потомками.\n\n`````ts\n/**\n * Абстрактный класс с одним абстрактным методом.\n */\nabstract class Shape {\n    abstract getRectangle(): ClientRect;\n}\n\n/**\n * Из-за того, что класс абстрактный не получится создать его экземпляр с помощью оператора new.\n */\nnew Shape(); // Error -> Cannot create an instance of an abstract class.ts(2511)\n\n\n/**\n * [0] Кроме этого, подкласс обязательно должен переопределять абстрактные члены своего суперкласса.\n */\nclass Circle extends Shape {\n    getRectangle(){// [0]\n        return {\n            width:0,\n            height: 0,\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        };\n    }\n}\n`````\n\nНо правила, с помощью которых компилятор работает с абстрактными классами, делают типы абстрактных и конкретных конструкторов несовместимыми. Другими словами, абстрактный класс нельзя передать по ссылке ограниченной более общим типом.\n\n`````ts\ninterface IHasRectangle {\n    getRectangle(): ClientRect;\n}\n\ntype HasRectangleClass = new() => IHasRectangle;\n\n/**\n * [*] Type 'typeof Shape' is not assignable to type 'HasRectangleClass'.\n Cannot assign an abstract constructor type to a non-abstract constructor type.ts(2322)\n */\nlet ClassType: HasRectangleClass = Shape; // Error [*]\n\n`````\n\nКроме этого, невозможно получить тип экземпляра абстрактного класса с помощью вспомогательного типа `InstanceType<T>`.\n\n`````ts\n/**\n * [*] Type 'typeof Shape' does not satisfy the constraint 'new (...args: any) => any'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.ts(2344)\n */\ntype Instance = InstanceType<typeof Shape>; // Error [*]\n`````\n\nЭто в свою очередь не позволяет реализовать механизм динамического наследования.\n\n`````ts\nfunction subclassCreator(Base: new() => IHasRectangle){\n    return class extends Base {\n        getRectangle(){\n            return {\n                width:0,\n                height: 0,\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0\n            };\n        }\n    }\n}\n\n/**\n * [*] Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => IHasRectangle'.\n Cannot assign an abstract constructor type to a non-abstract constructor type.ts(2345)\n */\nsubclassCreator(Shape); // Error [*] -> передача в качестве аргумента абстрактный класс\nsubclassCreator(Circle); // Ok -> передача в качестве аргумента конкретный класс\n`````\n\nДля решения этой проблемы, в _TypeScript_ существует модификатор `abstract` предназначенный для указания в описании типа конструктора.\n\n`````ts\ninterface IHasRectangle {\n    getRectangle(): ClientRect;\n}\n\ntype HasRectangleClass = abstract new() => IHasRectangle;\n\n\nlet ClassType: HasRectangleClass = Shape; // Ok\n`````\n\nНесмотря на то, что тип класса имеет абстрактный модификатор, он также остается совместимым с типами конкретных классов.\n\n`````ts\nfunction subclassCreator(Base: abstract new() => IHasRectangle){\n    return class extends Base {\n        getRectangle(){\n            return {\n                width:0,\n                height: 0,\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0\n            };\n        }\n    }\n}\n\nsubclassCreator(Shape); // Ok -> абстрактный класс\nsubclassCreator(Circle); // Ok -> конкретный класс\n`````\n\nТакже с помощью данного оператора можно реализовать собственный вспомогательный тип, позволяющий получить тип экземпляра.\n\n`````ts\ntype AbstractInstanceType<T extends abstract new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\n\ntype Instance = AbstractInstanceType<typeof Shape>; // Ok\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Massivopodobnye_readonly_tipy,ReadonlyArray,ReadonlyMap,ReadonlySet"},"nextPage":{"title":"Типизированный React","path":"Tipizirovannyi_React"}},"contentNavData":{"key":"Синтаксические конструкции и операторы","level":0,"index":49,"contentIndex":0,"section":"Синтаксические конструкции","title":"Синтаксические конструкции и операторы","path":"Sintaksicheskie_konstrukcii_i_operatory","elementId":"Sintaksicheskie_konstrukcii_i_operatory","children":[{"key":"Синтаксические конструкции и операторы_0","index":0,"contentIndex":1,"level":1,"section":"Синтаксические конструкции","title":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"Operatory_prisvaivaniya_korotkogo_zamykaniya_(&&=,||=,&&=)","elementId":"Operatory_prisvaivaniya_korotkogo_zamykaniya_(&&=,||=,&&=)"},{"key":"Синтаксические конструкции и операторы_1","index":1,"contentIndex":2,"level":1,"section":"Синтаксические конструкции","title":"Операнды для delete должны быть необязательными","path":"Operandy_dlya_delete_doljny_byt_neobyazatelnymi","elementId":"Operandy_dlya_delete_doljny_byt_neobyazatelnymi"},{"key":"Синтаксические конструкции и операторы_2","index":2,"contentIndex":3,"level":1,"section":"Синтаксические конструкции","title":"Объявление переменных 'необязательными' при деструктуризации массивоподобных объектов","path":"Obyavlenie_peremennyh_'neobyazatelnymi'_pri_destrukturizacii_massivopodobnyh_obektov","elementId":"Obyavlenie_peremennyh_'neobyazatelnymi'_pri_destrukturizacii_massivopodobnyh_obektov"},{"key":"Синтаксические конструкции и операторы_3","index":3,"contentIndex":4,"level":1,"section":"Синтаксические конструкции","title":"Модификатор abstract для описания типа конструктора","path":"Modifikator_abstract_dlya_opisaniya_tipa_konstruktora","elementId":"Modifikator_abstract_dlya_opisaniya_tipa_konstruktora"}]},"pageDescription":"Синтаксические конструкции и операторы"},"__N_SSG":true}