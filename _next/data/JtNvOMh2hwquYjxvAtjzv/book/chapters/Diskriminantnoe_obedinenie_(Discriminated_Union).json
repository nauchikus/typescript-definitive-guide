{"pageProps":{"urlResolver":{"image":"https://raw.githubusercontent.com/nauchikus/typescript-definitive-guide/master/book/ru/chapters/035.(Типы) Дискриминантное объединение (Discriminated Union)/images/"},"sectionInfoAll":[{"key":"Дискриминантное объединение (Discriminated Union)","elementId":"Diskriminantnoe_obedinenie_(Discriminated_Union)","markdown":"# Дискриминантное объединение (Discriminated Union)\n\nЧтобы вывод типов мог отличить один тип, входящий в множество `union`, от другого, необходимо, что бы каждый из них определял специальное поле, способное идентифицировать его уникальным образом. Данная глава расскажет как определить подобные поля и научит как на их основе привязывать тип к лексическому окружению."},{"key":"Дискриминантное объединение (Discriminated Union)_0","elementId":"Diskriminantnoe_obedinenie","markdown":"## Дискриминантное объединение\n\nТип `Discriminated Unions` (_дискриминантное объединение_), часто обозначаемое как `Tagged Union` (_размеченное объединение_), так же как и тип `union` (объединение), является множеством типов, перечисленных через прямую черту `|`. Значение, ограниченное дискриминантным объединением, может принадлежать только к одному типу из множества. \n\n`````ts\nlet v1: T1 | T2 | T3;\n`````\n\nИз-за того, что все описанное ранее для типа `union` (глава [“Типы - Union, Intersection”](../016.(Типы)%20Типы%20-%20Union,%20Intersection)) идентично и для `Tagged Union`, будет более разумно не повторяться, а сделать упор на различия. Но, так как полностью открыть завесу тайны `Tagged Union` на данный момент будет преждевременным, остается лишь описать детали, к которым рекомендуется вернуться при необходимости.\n\nНесмотря на то, что `Discriminated Union` в большей степени идентичен типу `Union`, все же существует два отличия. Первое отличие заключается в том, что типу `Discriminated Union` могут принадлежать только ссылочные типы данных. Второе отличие в том, что каждому объектному типу (также называемые _варианты_), составляющему `Discriminated Union`, указывается идентификатор варианта _дискриминант_.\n\nПомните, что вывод типов, без помощи разработчика, способен работать лишь с общими для всех типов признаками?\n\n`````ts\nclass Bird {\n    fly(): void {}\n\n    toString(): string {\n        return 'bird';\n    }\n}\n\nclass Fish {\n    swim(): void {}\n\n    toString(): string {\n        return 'fish';\n    }\n}\nclass Insect {\n    crawl(): void {}\n\n    toString(): string {\n        return 'insect';\n    }\n}\n\nfunction move(animal: Bird | Fish | Insect): void {\n    animal.fly(); // Error -> [*]\n    animal.swim(); // Error -> [*]\n    animal.crawl(); // Error -> [*]\n\n    animal.toString(); // Ok -> [*]\n\n    /**\n     * [*]\n     * \n     * Поскольку вывод типов не может\n     * определить к какому конкретно\n     * из трех типов принадлежит параметр\n     * animal, он не позволяет обращаться к\n     * уникальным для каждого типа членам,\n     * коими являются методы fly, swim, crawl.\n     * \n     * В отличии от этих методов, метод toString\n     * определен в каждом из возможных типов,\n     * поэтому при его вызове ошибки не возникает. \n     */\n    \n}\n`````\n\nЧтобы компилятор мог работать с членами присущих конкретным типам, составляющих дискриминантное объединение, одним из способов является сужение диапазона типов при помощи _дискриминанта_.\n\n`````ts\nclass Bird {\n    type: 'bird' = 'bird'; // дискриминант\n\n    fly(): void {}\n\n    toString(): string {\n        return 'bird';\n    }\n}\n\nclass Fish {\n    type: 'fish' = 'fish'; // дискриминант\n\n    swim(): void {}\n\n    toString(): string {\n        return 'fish';\n    }\n}\n\nclass Insect {\n    type: 'insect' = 'insect'; // дискриминант\n\n    crawl(): void {}\n\n    toString(): string {\n        return 'insect';\n    }\n}\n\nfunction move(animal: Bird | Fish | Insect): void {\n    if (animal.type === 'bird') {\n        animal.fly(); // Ok\n    } else if (animal.type === 'fish') {\n        animal.swim(); // Ok\n    } else {\n        animal.crawl(); // Ok\n    }\n\n    animal.toString(); // Ok\n}\n`````\n\nМеханизм, с помощью которого разработчик помогает выводу типов, называется _защитники типа_ (`type guard`), и будет рассмотрен позднее в одноимённой главе (глава [“Типизация - Защитники типа”](../036.(Типизация)%20Защитники%20типа)). А пока стоит сосредоточиться на самих идентификаторах вариантов.\n\nПрежде всего стоит прояснить, что дискриминант, это поле, которое обязательно должно принадлежать к литеральному типу отличному от `unique symbol` и определенное в каждом типе, составляющем _дискриминантное объединение_. Кроме того, поля обязательно должны быть инициализированы при объявлении или в конструкторе. Также не будет лишним напомнить, что список литеральных типов, к которому может принадлежать дискриминант, состоит из `Literal Number`, `Literal String`, `Template Literal String`, `Literal Boolean` и `Literal Enum`.\n\n`````ts\nclass Bird {\n    type: 'bird' = 'bird'; // инициализация в момент объявления поля\n\n    fly(): void {}\n}\n\nclass Fish {\n    type: 'fish' = 'fish'; // инициализация в момент объявления поля\n\n    swim(): void {}\n}\n\nclass Insect {\n    type: 'insect';\n\n    constructor(){\n        this.type = 'insect'; // инициализация в конструкторе\n    }\n\n    crawl(): void {}\n}\n\nfunction move(animal: Bird | Fish | Insect): void {}\n`````\n\nВ случае, когда типы полей являются уникальными для всего множества, они идентифицируют только свой тип.\n\n`````ts\nclass Bird {\n    groupID: 0 = 0;\n\n    fly(): void {}\n}\n\nclass Fish {\n    groupID: 1 = 1;\n\n    swim(): void {}\n}\n\nclass Insect {\n    groupID: 2 = 2;\n\n    crawl(): void {}\n}\n\n// groupID 0 === Bird\n// groupID 1 === Fish\n// groupID 2 === Insect\n`````\n\nТогда, когда тип поля не является уникальным, он идентифицирует множество типов, у которых совпадают типы одноимённых идентификаторов вариантов.\n\n`````ts\nclass Bird {\n    groupID: 0 = 0;\n\n    fly(): void {}\n}\n\nclass Fish {\n    groupID: 0 = 0;\n\n    swim(): void {}\n}\n\nclass Insect {\n    groupID: 1 = 1;\n\n    crawl(): void {}\n}\n\n// groupID 0 === Bird | Fish\n// groupID 1 === Insect\n`````\n\nКоличество полей, которые служат идентификаторами вариантов, может быть любым.\n\n`````ts\nenum AnimalTypes {\n    Bird = 'bird',\n    Fish = 'fish',\n}\n\n\nclass Bird {\n    type: AnimalTypes.Bird = AnimalTypes.Bird;\n\n    fly(): void {}\n}\nclass Robin extends Bird {\n    id: 0 = 0;\n}\nclass Starling extends Bird {\n    id: 1 = 1;\n}\n\n\nclass Fish {\n    type: AnimalTypes.Fish = AnimalTypes.Fish;\n\n    swim(): void {}\n}\nclass Shark extends Fish {\n    id: 0 = 0;\n}\nclass Barracuda extends Fish {\n    id: 1 = 1;\n}\n\n\n\ndeclare const animal: Robin | Starling | Shark | Barracuda;\n\n\n\nif (animal.type === AnimalTypes.Bird) {\n    /**\n     * В области видимости этого блока if\n     * константа animal принадлежит к типу Bird или Starling\n     */\n    animal; // const animal: Robin | Starling\n\n    if (animal.id === 0) {\n        /**\n         * В области видимости этого блока if\n         * константа animal принадлежит к типу Robin\n         */\n        animal; // const animal: Robin\n    } else {\n        /**\n         * В области видимости этого блока else\n         * константа animal принадлежит к типу Starling\n         */\n\n        animal; // const animal: Starling\n    }\n} else {\n    /**\n     * В области видимости этого блока if\n     * константа animal принадлежит к типу Shark или Barracuda\n     */\n\n    animal; // const animal: Shark | Barracuda\n\n    if (animal.id === 0) {\n        /**\n         * В области видимости этого блока if\n         * константа animal принадлежит к типу Shark\n         */\n        animal; // const animal: Shark\n    } else {\n        /**\n         * В области видимости этого блока else\n         * константа animal принадлежит к типу Barracuda\n         */\n\n        animal; // const animal: Barracuda\n    }\n}\n\n`````\n\nПри необходимости декларирования поля, выступающего в роли дискриминанта, в интерфейсе, ему указывается более общий совместимый тип. Для литерального строкового типа, это тип `string`, для литерального числового, это `number` и т.д.\n\n`````ts\ninterface IT {\n  /**\n   * Дискриминантное поле\n   */\n  type: string; // это поле предполагается использовать в качестве дискриминанта поля\n}\n\n\nclass A implements IT {\n  type: \"a\" = \"a\"; // переопределение более конкретным типом\n}\nclass B implements IT {\n  type: \"b\" = \"b\"; // переопределение более конкретным типом\n}\n\n\nfunction valid(value: A | B) {\n  if (value.type === \"a\") {\n    // здесь value расценивается как принадлежащее к типу A\n  } else if (value.type === \"b\") {\n    // здесь value расценивается как принадлежащее к типу B\n  }\n\n  // здесь value расценивается как тип обладающий общими для A b B признаками\n}\n`````"}],"githubFileInfo":{"lastUpdate":1617711223000,"contributorAll":[{"name":"nauchikus","avatar":"https://avatars.githubusercontent.com/u/31518738?v=4","bio":"@TechnoFanatic(\"🍬\")\r\n","githubUrl":"https://github.com/nauchikus"}]},"pageNav":{"isPrevPage":true,"isNextPage":true,"prevPage":{"title":"Обобщения (Generics)","path":"Obobshcheniya_(Generics)"},"nextPage":{"title":"Импорт и экспорт только типа","path":"Import_i_eksport_tolko_tipa"}},"contentNavData":{"key":"Дискриминантное объединение (Discriminated Union)","level":0,"index":35,"contentIndex":0,"section":"Типы","title":"Дискриминантное объединение (Discriminated Union)","path":"Diskriminantnoe_obedinenie_(Discriminated_Union)","elementId":"Diskriminantnoe_obedinenie_(Discriminated_Union)","children":[{"key":"Дискриминантное объединение (Discriminated Union)_0","index":0,"contentIndex":1,"level":1,"section":"Типы","title":"Дискриминантное объединение","path":"Diskriminantnoe_obedinenie","elementId":"Diskriminantnoe_obedinenie"}]},"pageDescription":"Дискриминантное объединение (Discriminated Union)"},"__N_SSG":true}